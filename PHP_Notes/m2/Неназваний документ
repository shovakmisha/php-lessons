1) Щоб роут працював, навыть не обовязково щоб тема була включена. Модуль Хелоуворд взагалі у іншій кампанії, але всеодно работає роут 
2) Маджента дивно працює в тому плані, що коли я пишу якиїсь метод обєкту, то у пхп штормі якшло клацнути на цей метод, мене кине або на інтерфейс або на абстрактний клас цього метода. А вже сам клас, у якого буде цей метод оприділяється у файлі di.xml(кастомний або нативний маджентовський) Суть у тому що метод відпрацюовує, але якщо клацнути по ньому, то його немає у файлі на який мене кине. Треба йти у файл di.xml і шукати кому він присвоїний
	- модулі у мадженті спілкуються через папку API. Але це не то апі що rest, soap,... Навіть щоб до свого модуля звернутись, треба звертатись через апішний інтерфейс. Тепер більш менш понятна логіка. Всі спілкуються через апішку, а щоб в апішці не писати весь функціонал, його переоприділяють у депенденсі інжектіон
	- Взагалы прийнято так, що апішку не змінюють при невеликих оновленнях (2.0.3, 2.0.4). Та і взагалі мабуть 2.1.0 страратись не міняти
	- Тепер зрозуміло. Вова казав що не можна просто взяти якиїсь клас (його неймспейс наприклад) і затягнути собі у клас, навіть з свого модуля. Звертатись можна тільки через апішку (в апішці зазвичай інтерфейси і абстрактні класи, а через депенденсі вже переоприділяється)
	- Коли пишу від чого буде залежати мій клас (від класа або інрерфейса), старатись вибирати інтерфейс
3) 
	- По общих рекомендаціях інтерфейси і класи API не можуть міняти свою поведінку
4) Всі обработчики xml-ок по наним стандартам поміщаються в папку Config/Module_name

 - $this->getRequest()->getParams('це я витягую гет пост параметри і тд. По ходу те що в глобальному масиві Request');

5) В м1 для получення моделі, використовували статичні методи Mage:: getModel getSinglton

5) Код для обробки xml конфігів пишуться у папці модуля Config
5) Вова казав не придумовувати нічого нового, а робити свої класи на базі вже існуючого функціоналу (класів, інтерфейсів)
5) Якщо дописати Factroy вкінці класа, то Маджента автоматично буде ствроювати обєкт з цього класу myClassFcctory. типу для роботи з продуктом мены треба працювати з його фабрикою. Magento\Catalog\Model\Product - це існуючий файл, але мені треба його фабрика, тому я дописую до нього Magento\Catalog\Model\ProductFactory
5) B di.xml можна переоприділяти не тільки класи а і отдільні атрибути, аргументи (короче все підряд)

6) В депенленсі інжекшн взагалі все пожна поставити. Які там конфіги прописати, таким новий клас і буде
7) якщо я змінив щось у конструкторі, це пишеться у папку generation, яку постоянно треба очищувати. Його гонерує депенденсі інжекшн
	- В конструкторі вказано які файли будуть загружені через di.xml. Спочатку всі, потім прекриваютьться, якщо є чим перекрити(etc/frontend etc/adminhtml). Потім створюьться класи і ці класи повертаються обєктним менеджерам
8) Бля як тут все запутано, без підсказок над методом я б взагалі кончився. Наприклад щоб взнати звідки береться метод appendBody() ($this->getResponse()->appendBody('Hello');) у нативному контролері, можна клацнути на метод getResponse - мене кине на абстрактний клас AbstractAction. По якому принципу воно перекидує я так і не догнав. Вроді ж би мало на найнижчий(інтерфейс наприклад) і потім в депенденсі оприділятиякий це насправді буде клас, але тут кидає на клас, який реалізовується від інтерфейса. Але тепер не про тото. Як це все працює
	1) самий простий клас Index у контролері, наслідується від \Magento\Framework\App\Action\Action
	2) \Magento\Framework\App\Action\Action не має метода AbstractAction(), він наслідується від класа AbstractAction, який знаходиться у неймспейсі AbstractAction і у ньго є цей метод
	3) AbstractAction має метод getResponse(), який повертає змінну $_response. Над методом getResponse() є підсказка, що він повертає обєкт, екземпляр класа ResponseInterface @return \Magento\Framework\App\ResponseInterface 
	- Перед тим як писати далі, треба сказати, що значення змінної $_response у класі AbstractAction, береться з Magento\Framework\App\Action\Context, у якому є метод getResponse(), який повертає змінну $response. У неймспейсі Context, змінна $response береться з \Magento\Framework\App\ResponseInterface, але \Magento\Framework\App\ResponseInterface не має цього метода, він переоприділяється в головному di.xml (<preference for="Magento\Framework\App\ResponseInterface" type="Magento\Framework\App\Response\Http" />)
	- А вже у Magento\Framework\App\Response\Http має метод appendBody. Не прям в самому Magento\Framework\App\Response\Http, цей метод йому прийшов по наслідуванню. Щоб це перевірити, можна клацнути на структуру файлу і там побачити цей метод
9) Важливий момент, але я не можу це спіймати як закономірність. Якщо я використовую якиїсь неймспейс(будь який, не обовязково напряму. Тобто якщо я наслідую клас який використовує якиїсь неймспейс) мені теж треба прописати його у своєму файлі


10) В м2 створюванням класів займається обєкт менеджер(ObjectManager). В нього є 2 методи. Але саме через нього не рекомендується стрворювати обєкти
	- create() - Аналог в першій мадженті Mage::getModel() - завжди новий обєкт
	- get - Аналог в першій мадженті Mage::getSinglton() - один і той самий обєкт
 - Типу є інжектбіл і не інжектбл класи. інжектбл це ті обєкти, які може створити обєкт менеджер. На скільки я зрозумів, вони завжди повертають одні і ті самі дані (сінглтон наприклад). А не інжектбл це динамічні дані, це наприклад модельки(майже всі взагалі модельки) продуктів, томущо там як мінімум айдішки продуктів завжди різні запрашуються. Тому не можна створювати можелюки за допомогою обєкт менеджера. 
	- Також не треба щоб не інектбл класи брали дані від інжектбл, по тих же самих причинах. Завжди краще, щоб коли працювати з базою наприклад, я брав дані зразу з бази. А то в сінглтоні може бути случайно щось не то
 	- Навіть якщо інжектіруємий клас має повернути не інжектбл (продукт наприклад), то він в своєму конструкторі має попросити фабрику(вона не інжектбл) продукта. Взагалі всі залежнасті наскільки я зрозумів треба писати в конструкторі
	- Якщо метод інжектіруємого обєкту щось міняє в не інжектіруємому (наприкдад щось міняє в продукті), то цей продукт має передаватись цьому методу в якості аргументу. А той хто буде викликати цей метод має піклуватись щоб цей продукт завжди тяг актуальні дані з бази (тобто не був сінглтоном)
11) bin/magento setup:di:compile - генерує код який створиться після того як маджента згенерує всі залежності. Цю команду добре зробити при перекиданні сайту в продакшн (після деплою), щоб код не генерувався на сервері з di.xml а був вже згенерований. Результати цієї команди буде видно в папках /var/di i /var/generation
12) Щоб згенерувати івент, цей клас має мати в залежностях Magento\Framework\Event\ObserverInterface; і викликаний його метод dispatch('назва івента' [параметри (хоча у вови динамічні дані були не на пряму записані 'arg' => $arg) ]). Цей метод приймає 1 аргумент - Magento\Framework\Event\ObserverInterface $observer
	- І ще дуже важливо щоб обсерсери працювали не зі змінними а з ссилками на участок памяті (Вова використорував class->value наприклад, так як класи передаються по ссилці), щоб це значення мінялось, а інакше буде каша - один обсервер поміняв якесь значення, а в системі воно не помінялось.
13) У файлі /etc/events.xml треба вказати який івент я хочу зловити. У ньому буде
	- <event name="назва івента який я хочу зловити">
		- <observer 
			name="тут напишу імя яке хочу дати моєму обсерверу"
			instance="тут клас, який це буде обробляти"
			shared="true/false"- чи будуть оброблятись ці івенти по сінглтоном. Тобто якщо він обробляє зразу декілька івентів, то чи буде він перед кожним івентом оновлюватись чи ні
			>
14) У смайлі функціонал обсерверів пишеться у папці Observer
15) Вова ще написав у залежності конструктора класа обсервера пср-стандарт клас Psr\Log\LoggerInterface, але я не догнав нахер
 !ФІШКА Якщо не знаю які залежності треба для класу, то можна написати в коді що я використовую цей клас і шторм може підтягнути його і прописати в use \Class\
16) Плагіни створені щоб міняти якиїсь public метод в класі. 
	- Принцип роботи у тому що плагін оверайдить клас, тож є вірогідність що і протектед методи можна заплагінити. Але final методи звичайно в такому разі не можна плагінити
	- before - передаються 2 аргументи - 1-й це неймспейс класа з змінною, якій він буде присвоїний - \Path\Class $subject, 2-й і всі інші - це будуть аргументи метода, якого я плагіню. Наприклад У плагіні можна додати кастомні аргументи або змінити оринінальний. Вова взагалі повертав у плагіні не значення, а масив у якому було значення - return array($value); не знаю чому і навіщо, але це работало.
Коли б там було декілька значень або аргументів, які треба повернути, я б це розіумів, але якщо тільки 1, я то не розумію
	- around - Вова пояснював що цей код буде замість метода, хоча мені здається що код плагіна якось мікситься - треба перевірити. Вова казав що around може бути використаний для того щоб виконати спочатку мій кастомний код, потім той що я плагіню (або не викликати), потім знов мій кастомний. Тож по ходу моя версія з міксингом хибна. Вова казав що це обєднання метода бефор і афтер. Тож є вірогідність, що той що стоїть перед оригіналом попаде в ордер сорт бефор і той що після в ордер сорт афтер
	- after - приймає 2 аргументи - 1-й це такий самий як і в before, а 2-й - це значення, яке повертає метод, який я плагіную. Має повертати 2-й аргумент. Тут Вова теж ретурнив масив
	- У одного метода може бути декілька плагінів, порядок їх виконання управляється через атрибут sortOrder. По ходу воно так работає, що спочатку виконується ципочка бефор, потім оригінальний метод, потім ципочка афтер
	- У смайлі плагіни розташовуються у папці Plugin
	- disabled - атрибут який включає або виключає плагін

17) У PSR протестед методи не починаються з андерскора, у смайлы теж.
18) url-ками у 2-й мадженты займаэться Magento\Framework\UrlInterface - він звичайно є переоприділений в di.xml
	- У нього є метод getUrl(сюди передається шлях до колнтролера модуля, який мені треба. Якщо це Index, то не треба писати controler/index, просто controler ). Але Вова казав, що коли це дефолтний контролер модуля, тобто знаходиться у папці Index і має назву Index.php, то по правильному шлях би був getUrl('controlerName/index/index');
	- Також getUrl може приймати у аргументи масив. Вова це використав коли екшни у контролера треба додати динамічні значення (типу це будуть юрлки різних сторінок) getUrl('path',['action' => $value] - getUrl('shop/index/view', ['code' => $code]
	
19) В м2 не можна передавати все що завгодно, ко що завгодно. Наприклад не можна працювати з моделькою кастомера в модельці продукту. Якщо я реврайчу якиїсь клас, то цей клас або має наслідуватись від класа, або реалізовувати його інтерфейс. Реврайти будуть знаходитись в папці модуля Rewrite
	- Реврайти не то що будуть знаходитись у папці Rewrite, просто є така можливість. Наприклад Вова реврайтив модуль Catalog, але не писав Catalog, а назвав папку Rewrite. І в ній вже повторював структуру оригінального Catalog. Мабуть цим він хотів показати що не важливо як називаються папки, головне щоб клас або наслідував або реалізовував інтерфейс класа, якого я реврайчу
	- Не знаю чи це выдноситься до цієї теми, але скоріш за все мені і вдалось зробити видимим клас обсервера а треніровочному модулі тільки тоді, як він почав реалізовувати інтерфейс апішки





11) Фабрики для класів генеруються автоматично



- parent __constructor() треба викликати якщо у текущому класі я розширяю парент клас. Для плагінів його не треба викликати, так як я розширяю тільки метод класа




