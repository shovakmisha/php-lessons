 - На сервері папка pub маэ права рід онлі за замовчуванням
 - Вова казав що в папці var лежать временні файли (логи, ....) 
 - etc/di.xml - базовий xml на який інші будуть накатуватись
 - env.php - тут маджента записує дані для підключення з базою, паролі до адмінки, корочі базові штуки для роботи
	- Також у цьому файлі є дані про кеші, які є, які включені. Тож у цьому файлику можна відключити або включити кеші
 - В продакшн моді файли у папці pub не генеруються заново при кожній загрузці сторінки на відміну від девелоп мода. Вони взагалі не генеруються. Тож треба згенерувати їх Ще в дев моді а потім переносити в продакшн
 	- При дефолтному моді ексепшени так як і в продакшні не показуються в браузері, а записуються в логи. А з файлами трохи по іншому. Якщо якогось файла не існує, то він згенерується але тільки 1 раз, всі наступні рази буде використовуватись цей файл.
 - Модулі в мадженті розділені по функціональності. І при створенні кастомних модулів ця тинденція має зберігатись. 1 модуль 1 функціонал
 - Вова каже що апі це єдине місце де інші модулі можуть взаємодіяти з текущим модулем. Хоча я брав функціонал інших модулів у свій. Типу що продукти можна вибирати тільки в каталозі. А якщо хочу вибрати в іншому модулі, то вже використовувати апі.
 - Кожен модуль може мати свої скріпти ( типу bin/magento ... ) і писати їх треба буде у папці Console
 - squence від яких модулів буде залежаи мій модуль
	<squence>
		<module name="Magento_Catalog" />
		<module name="Magento_Backend" />
	    </squence>
/
 - Цей файлик схем що я створював на уроках Вови, працює на весь модуль. Але є можливість створювати отдільний xsd для кожного xml. Це треба буде щось загуглити вроді перфайл схема або щось в такому роді, тобто схема для одного файла
	- Також Вова казав що інтерфейс файл, який лежить в папці апі потребен щоб модуль міг читати ці конфігурації що я створив. Тож скоріш за все мені не треба створювати в кожному модулі папку апі з цим файлом інтерфейсу, досить просто забрати собі цей файл з класом, який реалізовує цей інтерфейс. Але Вова казав що інші модулі теж зможуть створити свої магазини, на основі цієї хмл-ки з магазинами, тож треба провірити як це працює

1) Щоб роут працював, навыть не обовязково щоб тема була включена. Модуль Хелоуворд взагалі у іншій кампанії, але всеодно работає роут
1) Якщо я в адресній строці написав тільки фронтнейм модуля, то щой обробити цей запрос, маджента буде шукати мудуль з цим фронтнеймом, і файл по шляху Controller/Index/Index.php
1) Якщо не маэ файла registration.php то модуль і так можна буде включити в файлі конфігів або командою енейбл модуль. Але краще щоб він був. Дивно в тому плані що наскільки я зрозумів - цей файл дає знати мадженті що в нас є цей модуль і включає його, а Томчак казав що досить поставити 0 в конфігах щоб модуль на деві не включався, хоча файл реєстрації в нього був
2) Маджента дивно працює в тому плані, що коли я пишу якиїсь метод обєкту, то у пхп штормі якшло клацнути на цей метод, мене кине або на інтерфейс або на абстрактний клас цього метода. А вже сам клас, у якого буде цей метод оприділяється у файлі di.xml(кастомний або нативний маджентовський) Суть у тому що метод відпрацюовує, але якщо клацнути по ньому, то його немає у файлі на який мене кине. Треба йти у файл di.xml і шукати кому він присвоїний
	- модулі у мадженті спілкуються через папку API. Але це не то апі що rest, soap,... Навіть щоб до свого модуля звернутись, треба звертатись через апішний інтерфейс. Тепер більш менш понятна логіка. Всі спілкуються через апішку, а щоб в апішці не писати весь функціонал, його переоприділяють у депенденсі інжектіон
	- Взагалы прийнято так, що апішку не змінюють при невеликих оновленнях (2.0.3, 2.0.4). Та і взагалі мабуть 2.1.0 страратись не міняти. Це зроблено щоб нічого не ламалось (як в композері)
	- Apі модулі знаходяться в папці Api. Api конфіги в папці Api/Config (В цій папці я писав свій інтерфейс через який я звертався до конфігурацій (xml-ок) )
	- Тепер зрозуміло. Вова казав що не можна просто взяти якиїсь клас (його неймспейс наприклад) і затягнути собі у клас, навіть з свого модуля. Звертатись можна тільки через апішку (в апішці зазвичай інтерфейси і абстрактні класи, а через депенденсі вже переоприділяється) .
	- Все ж таки, якщо я хочу забрати інтерфейс, клас якого реалізовує читання конфігів (або щось інше), треба тягнути собі інтерфейс а не клас. 
	- Коли пишу від чого буде залежати мій клас (від класа або інрерфейса), старатись вибирати інтерфейс
3) 
	- По общих рекомендаціях інтерфейси і класи API не можуть міняти свою поведінку
4) Всі обработчики xml-ок по наним стандартам поміщаються в папку Config/Module_name

 - $this->getRequest()->getParams('це я витягую гет пост параметри і тд. По ходу те що в глобальному масиві Request');

5) В м1 для получення моделі, використовували статичні методи Mage:: getModel getSinglton

5) Код для обробки xml конфігів пишуться у папці модуля Config
5) Вова казав не придумовувати нічого нового, а робити свої класи на базі вже існуючого функціоналу (класів, інтерфейсів)
5) Якщо дописати Factroy вкінці класа, то Маджента автоматично буде ствроювати обєкт з цього класу myClassFcctory. типу для роботи з продуктом мены треба працювати з його фабрикою. Magento\Catalog\Model\Product - це існуючий файл, але мені треба його фабрика, тому я дописую до нього Magento\Catalog\Model\ProductFactory
5) B di.xml можна переоприділяти не тільки класи а і отдільні атрибути, аргументи (короче все підряд)

6) В депенленсі інжекшн взагалі все пожна поставити. Які там конфіги прописати, таким новий клас і буде
7) якщо я змінив щось у конструкторі, це пишеться у папку generation, яку постоянно треба очищувати. Його гонерує депенденсі інжекшн
	- В конструкторі вказано які файли будуть загружені через di.xml. Спочатку всі, потім прекриваютьться, якщо є чим перекрити(etc/frontend etc/adminhtml). Потім створюьться класи і ці класи повертаються обєктним менеджерам
8) Бля як тут все запутано, без підсказок над методом я б взагалі кончився. Наприклад щоб взнати звідки береться метод appendBody() ($this->getResponse()->appendBody('Hello');) у нативному контролері, можна клацнути на метод getResponse - мене кине на абстрактний клас AbstractAction. По якому принципу воно перекидує я так і не догнав. Вроді ж би мало на найнижчий(інтерфейс наприклад) і потім в депенденсі оприділятиякий це насправді буде клас, але тут кидає на клас, який реалізовується від інтерфейса. Але тепер не про тото. Як це все працює
	1) самий простий клас Index у контролері, наслідується від \Magento\Framework\App\Action\Action
	2) \Magento\Framework\App\Action\Action не має метода AbstractAction(), він наслідується від класа AbstractAction, який знаходиться у неймспейсі AbstractAction і у ньго є цей метод
	3) AbstractAction має метод getResponse(), який повертає змінну $_response. Над методом getResponse() є підсказка, що він повертає обєкт, екземпляр класа ResponseInterface @return \Magento\Framework\App\ResponseInterface 
	- Перед тим як писати далі, треба сказати, що значення змінної $_response у класі AbstractAction, береться з Magento\Framework\App\Action\Context, у якому є метод getResponse(), який повертає змінну $response. У неймспейсі Context, змінна $response береться з \Magento\Framework\App\ResponseInterface, але \Magento\Framework\App\ResponseInterface не має цього метода, він переоприділяється в головному di.xml (<preference for="Magento\Framework\App\ResponseInterface" type="Magento\Framework\App\Response\Http" />). Тобто у змінніу $response у файлі Magento\Framework\App\Action\Context на самом ділі повернеться не \Magento\Framework\App\ResponseInterface, а Magento\Framework\App\Response\Http (цей клас буде в цій змінній). І потім з змінної $response можна буде витягнути методи класу 
	- А вже у Magento\Framework\App\Response\Http має метод appendBody. Не прям в самому Magento\Framework\App\Response\Http, цей метод йому прийшов по наслідуванню. Щоб це перевірити, можна клацнути на структуру файлу і там побачити цей метод
9) Важливий момент, але я не можу це спіймати як закономірність. Якщо я використовую якиїсь неймспейс(будь який, не обовязково напряму. Тобто якщо я наслідую клас який використовує якиїсь неймспейс) мені теж треба прописати його у своєму файлі

 9) Конфігураційні файли що лежать в etc (xml, xsd) предназначені не тільки для того щоб з них брати інфу, ними можна також переписувати існуючі xml, xsd і маджента буде їх збирати до купи з кастомними конфігами в приорітеті і будувати лейаути враховуючи їх 
 9) Про синтаксис xsd можна почитати на https://www.w3schools.com/ (Вова казав, там і приклади схем є)
 9) По смайлівським стандартам, всі конвертери, рідери мають знаходитись в папці Config і підпапці того тега, який я обробляю цими пхп файлами. Я читав тег <shop>, то файли які його читали, були в Module/Config/Shop
	- Але саме головний файл у якому був клас, який збирав це до купи, не був у папці Shop, він був у папці Config і мав назву Shop.php і в ньому був клас Shop
 11) Клас для контролерів(екшнів) Shop, я писав абстрактним. Вова казав що у абстрактного екшна може не бути метода execute()


10) В м2 створюванням класів займається обєкт менеджер(ObjectManager). В нього є 2 методи. Але саме через нього не рекомендується стрворювати обєкти
	- create() - Аналог в першій мадженті Mage::getModel() - завжди новий обєкт
	- get - Аналог в першій мадженті Mage::getSinglton() - один і той самий обєкт
10) В мадженті 2 я можу використовувати тільки ті класи, які мені дає менеджер. Якщо мені треба створити обєкт цього класу, то треба взяти фабрику цього обєкту. Фабрики створюються автоматично
	- Якщо я напишу клас в методі ( public function test(\Namespace\Class $var) ) у $var буде обэкт класа який прийшов з неймспейса класа. Так як конструктор теж метод, якщо я затягнув якиїсь клас собі у конструктор, обєкт створиться. В принципі це і є рекомендовані способи створення обєктів у мадженті

 - Типу є інжектбіл і не інжектбл класи. інжектбл це ті обєкти, які може створити обєкт менеджер. На скільки я зрозумів, вони завжди повертають одні і ті самі дані (сінглтон наприклад). А не інжектбл це динамічні дані, це наприклад модельки(майже всі взагалі модельки) продуктів, томущо там як мінімум айдішки продуктів завжди різні запрашуються. Тому не можна створювати можелюки за допомогою обєкт менеджера. 
	- Також не треба щоб не інектбл класи брали дані від інжектбл, по тих же самих причинах. Завжди краще, щоб коли працювати з базою наприклад, я брав дані зразу з бази. А то в сінглтоні може бути случайно щось не то
 	- Навіть якщо інжектіруємий клас має повернути не інжектбл (продукт наприклад), то він в своєму конструкторі має попросити фабрику(вона не інжектбл) продукта. Взагалі всі залежнасті наскільки я зрозумів треба писати в конструкторі
	- Якщо метод інжектіруємого обєкту щось міняє в не інжектіруємому (наприкдад щось міняє в продукті), то цей продукт має передаватись цьому методу в якості аргументу. А той хто буде викликати цей метод має піклуватись щоб цей продукт завжди тяг актуальні дані з бази (тобто не був сінглтоном)
11) bin/magento setup:di:compile - генерує код який створиться після того як маджента згенерує всі залежності. Цю команду добре зробити при перекиданні сайту в продакшн (після деплою), щоб код не генерувався на сервері з di.xml а був вже згенерований. Результати цієї команди буде видно в папках /var/di i /var/generation
12) Щоб згенерувати івент, цей клас має мати в залежностях Magento\Framework\Event\ObserverInterface; і викликаний його метод dispatch('назва івента' [параметри (хоча у вови динамічні дані були не на пряму записані 'arg' => $arg) ]). Цей метод приймає 1 аргумент - Magento\Framework\Event\ObserverInterface $observer
	- І ще дуже важливо щоб обсерсери працювали не зі змінними а з ссилками на участок памяті (Вова використорував class->value наприклад, так як класи передаються по ссилці), щоб це значення мінялось, а інакше буде каша - один обсервер поміняв якесь значення, а в системі воно не помінялось.
13) У файлі /etc/events.xml треба вказати який івент я хочу зловити. У ньому буде
	- <event name="назва івента який я хочу зловити">
		- <observer 
			name="тут напишу імя яке хочу дати моєму обсерверу"
			instance="тут клас, який це буде обробляти"
			shared="true/false"- чи будуть оброблятись ці івенти по сінглтоном. Тобто якщо він обробляє зразу декілька івентів, то чи буде він перед кожним івентом оновлюватись чи ні
			>
14) У смайлі функціонал обсерверів пишеться у папці Observer
15) Вова ще написав у залежності конструктора класа обсервера пср-стандарт клас Psr\Log\LoggerInterface, але я не догнав нахер
 !ФІШКА Якщо не знаю які залежності треба для класу, то можна написати в коді що я використовую цей клас і шторм може підтягнути його і прописати в use \Class\
16) Плагіни створені щоб міняти якиїсь public метод в класі. 
	- Принцип роботи у тому що плагін оверайдить клас, тож є вірогідність що і протектед методи можна заплагінити. Але final методи звичайно в такому разі не можна плагінити
	- before - передаються 2 аргументи - 1-й це неймспейс класа з змінною, якій він буде присвоїний - \Path\Class $subject, 2-й і всі інші - це будуть аргументи метода, якого я плагіню. Наприклад У плагіні можна додати кастомні аргументи або змінити оринінальний. Вова взагалі повертав у плагіні не значення, а масив у якому було значення - return array($value); не знаю чому і навіщо, але це работало.
Коли б там було декілька значень або аргументів, які треба повернути, я б це розіумів, але якщо тільки 1, я то не розумію
	- around - Вова пояснював що цей код буде замість метода, хоча мені здається що код плагіна якось мікситься - треба перевірити. Вова казав що around може бути використаний для того щоб виконати спочатку мій кастомний код, потім той що я плагіню (або не викликати), потім знов мій кастомний. Тож по ходу моя версія з міксингом хибна. Вова казав що це обєднання метода бефор і афтер. Тож є вірогідність, що той що стоїть перед оригіналом попаде в ордер сорт бефор і той що після в ордер сорт афтер
	- after - приймає 2 аргументи - 1-й це такий самий як і в before, а 2-й - це значення, яке повертає метод, який я плагіную. Має повертати 2-й аргумент. Тут Вова теж ретурнив масив
	- У одного метода може бути декілька плагінів, порядок їх виконання управляється через атрибут sortOrder. По ходу воно так работає, що спочатку виконується ципочка бефор, потім оригінальний метод, потім ципочка афтер
	- У смайлі плагіни розташовуються у папці Plugin
	- disabled - атрибут який включає або виключає плагін

17) У PSR протестед методи не починаються з андерскора, у смайлы теж.
18) url-ками у 2-й мадженты займаэться Magento\Framework\UrlInterface - він звичайно є переоприділений в di.xml
	- У нього є метод getUrl(сюди передається шлях до колнтролера модуля, який мені треба. Якщо це Index, то не треба писати controler/index, просто controler ). Але Вова казав, що коли це дефолтний контролер модуля, тобто знаходиться у папці Index і має назву Index.php, то по правильному шлях би був getUrl('controlerName/index/index');
	- Також getUrl може приймати у аргументи масив. Вова це використав коли екшни у контролера треба додати динамічні значення (типу це будуть юрлки різних сторінок) getUrl('path',['action' => $value] - getUrl('shop/index/view', ['code' => $code]
	
19) В м2 не можна передавати все що завгодно, ко що завгодно. Наприклад не можна працювати з моделькою кастомера в модельці продукту. Якщо я реврайчу якиїсь клас, то цей клас або має наслідуватись від класа, або реалізовувати його інтерфейс. Реврайти будуть знаходитись в папці модуля Rewrite
	- Реврайти не то що будуть знаходитись у папці Rewrite, просто є така можливість. Наприклад Вова реврайтив модуль Catalog, але не писав Catalog, а назвав папку Rewrite. І в ній вже повторював структуру оригінального Catalog. Мабуть цим він хотів показати що не важливо як називаються папки, головне щоб клас або наслідував або реалізовував інтерфейс класа, якого я реврайчу
	- Не знаю чи це выдноситься до цієї теми, але скоріш за все мені і вдалось зробити видимим клас обсервера а треніровочному модулі тільки тоді, як він почав реалізовувати інтерфейс апішки





11) Фабрики для класів генеруються автоматично



- parent __constructor() треба викликати якщо у текущому класі я розширяю парент клас. Для плагінів його не треба викликати, так як я розширяю тільки метод класа

 https://pocketbook-dev2.smile-magento.com/contact/
 	- pocketbookdev2
	- b2aFQedGrlns
	


 Попробувати доповнити якиїсь xml файл, обєднаною схемою 

 Я поки не розумію як конвертер(Converter.php) розуміє що треба використовувати мою схему (ShremaLocator.php)


 макхост



