Роути
Ф-ція роута міняти адресну строку. Тобто в юрл твориться казна що, а роут переробляє це в вид який підходить щоб його обробив контролер. Це неточно і дуже загально, я просхо хотів сформулювати, що роут редіректить, тобто приймає адресну строку, робить те що треба мадженті, міняє вид строки якщо потрібно і асайнить на перероблену юрл 
	
1) В м2 кожний екшн - це отдільний клас і кожен клас має 1 метод execute()
2) Все що знаходиться в папці Controller - екшни. https://mustela.lxc/helloworld(це контролер або модуль (frontname) )/product(це фізична папка. Це група екшнів)/index(це екшн)/id/2
2) \Magento\Framework\App\FrontController::dispatch() У цьому методы можна подивити як проходить роутінг
2) ФронтКонтролер перебирає роути і назначає який контролер буде обробляти юрл. vendor/magento/framework/App/FrontController.php 
	1) У його конструкторі загружається інтерфейс списка роутів - Magento\Framework\App\RouterListInterface. Цей інтерфейс переоприділяється у класі vendor/magento/framework/App/FrontController.php
	2) Якщо я хочу створити свій роут, треба у своєму модулі у di.xml переоприділити(або вказати, я так ы не поняв як це називаэться) його <type name="Magento\Framework\App\RouterList">. І тоді мій роут буде у списку. Фронт контролер буде рахувати скільки в коді є добавлених роутів (Magento\Framework\App\RouterList це масив і через форіч вони проганяються у фронтконтролері). Вова казав що у файлі вепенденсі я буду міняти аргументи Magento\Framework\App\RouterList, але сам функціонал чому роут додається а не переоприділяється я не знаю.
	2) Також у якомусь дефолтному роуті були вказані 2 айтеми яким було і у кожного з них був свій клас. Получається що і по них якось проходить циклом який клас(екшн) може обробити запрос
	3) І получається що кожен роут має реалізовувати RouterListInterface
	4) Кожен(контролер) роутер в системі має  реалізовувати RouterInterface. Це робиться теж у FrontController, там є ф-ція match, яка робить всі роути у списку RouterList, залежними від цього інтерфейсу. Але це не точно що саме ця ф-ція робить його типом RouterInterface. Мабуть RouterList чомусь вже має тип RouterInterface і тому ф-ція match працює з роутами. В конфігах роутів є строчка що указує тип RouterList  <type name="Magento\Framework\App\RouterList">. Мабуть із за цього всі роути у списку RouterList мають тип RouterList і і від цього ф-ція match не ерорить

3) Це що я описував більше стосується типів роутів. Так як якщо я додам в свій модуль в конфіг xml свій роутнейм (обовязкова процедура, щоб система обробляла запрос, інакше вона буде шукати модуль який є в адресній строці, а якщо не задам в конфігах, імя фронтнейма, то система не знайде модуль, який є в адресній строці (frontName="catalog"), як робив для модуля HelloWorld наприклад, щоб його бачити), то це не буде новим типом роута. Наприклад якщо це модуль HelloWorld і я вказав йому фронтнейм, то це ніби роут типа, який обробляє фронтові сторінки (не знаю його імя), А роут який обробляє фронтові екшни темплейтів знаходиться має сортордер 40 наприклад (із 100) і в перевірці головного фронтконтролера якщо HelloWorld не пройде перевірку на попередні, то буде оброблятись тим який йому підходить. Я можу створити свій Роут і вказати йому сортордер менший як у стандартного і тоді він буде виконуватись замість основного
4) переоприділяючи роути у di, треба щоб депенденсі файл був у потрібній арії, так як для фронта і для адмінки роути різні. Тобто у обох є роут з сорт ордером 100 ( в разі якщо жоден роут не знайшовся ) і їх обробляють зовсім різні класи


3) Кожен(контролер) роутер в системі має  реалізовувати RouterInterface (Цей інтерфейс переоприділений в системі di.xml на Magento\Framework\App\List, а у нього в свою чергу у контролеры додаюэться мій роут у систему (всі роути що є) )
	- Тобто Є адресна строка. Мадженда дивить на клас екшна, який за неї відповідає. Для кожного типу роута є свій роут, для цмс пейджі, для адмінки і тд (щоб перевірити типи роутів треба по проекту пошуати слово RouterList y di.xml. Там дефолтних буде штук 7 і може якісь кастомні). Кожен з цих типів має свій сорт ордер і скоріш за все якщо мій роут підпадає під декілька типів, то той у якого сорт ордер менший виконається точно а вже інші не будуть виконуватись.
	- У кожного з цих типів роутів є файл di.xml, який переоприділяє аргумент array $routerList у конструкторі Magento\Framework\App\List. Тобто і я можу створити свій тип, указавши в цьому файлі клас. Короче $routerList це масив, який має 3 значення - клас, disable(true/fale), SortOrder. Ці значення переоприділяються в xml файлі (розписувати не буду, краще глянути в прикладі). Тобто коли я передав клас через депенденсі, це буде фактично тип-екшн. Він як ніби і екшн але пустий, нівід чого не наслудуємий, єдине що треба, прописати йому щоб він реалізовував інтерфейс RouterInterface
	- Якщо цей роут ні під один не підходить - 404.


Подивити як звязаний frontRouter з головним. Чому він не вказаний як тип роутінга, якщо він виводить фронт. Якщо він не виводиться в типах, то мабуть не він виводить фронт

-------------------------

1) Всі phtml мають свій Block. Кожен Block має наслідується від Magento\Framework\View\AbstractBlock а він в свій час реалізовує інтерфейс Magento\Framework\View\BlockInterface
	- Блоки знаходяться в папці Module/Block
	- Базовий клас для фронтенда і бекенда у блоків відрізняються. У фронта це \Magento\Framework\Element\Template а у бека це \Magento\Backend\Block\Template


 Мабуть це все що Вова розказував за роути стосується кастомних юрлок, тому що коли при створенні модуля я вказую йому роут і всі юрлки які підпадають під цей роут обробляються моїм модулем, це теж роутінг по суті і наврядче маджента працює так, що роут для фронта пробігається по всії модулях при загрузці сторінки, шукаючи потрібний контролер
Хоча є ще варіант що всі роутнейми що я вказав у роутах модулів і відносяться до базового юрла в якості айтемів по яких він пробігається, хоча навряд


 ---------------------------

 1) Тег пейдж може сожержати 4 вузли. Один із них update - <update handle="catalog_product_view"/> - це я вказав, що повныстю наслідую файл - catalog_product_view.xml
 2) Раніше я писав шо можна визивати методи блока з xml через тег <action><argument name="lalala"></action>, але тепер це вде діпрікейтед. Замість <action> має бути <arguments>
 3) Класичний лейаут - це одноколоночний. Мабуть всі дефолтні лейаути знаходяться у Magento_Theme
 4) Роут выдправляє запрос на контролер і той в свою чергу вибирає лейаут у якому буде побудована сторінка. Але щоб контролер зробив маджентівську сторінку з лейаутом а не просто у пустий боді кинув, треба додати у конструктор конртолера(Екшна) фабрику класа сторінки - Magento\Framework\View\Result\PageFactory. І в ф-ції ексекют натисати $resultPage = $this->pageFactory->create(); return $resultPage;
	- Лейаут для цього контролера буде лежати у папці Training/Helloworld/view/frontend/layout з іменем rout-Id(etc/routes.xml)_ActionFolder_ActionClass.xml (helloworld_index_index.xml)
 5) Блок(php) це єдиний спосіб для темплейта витягнути інфу. Тож все що я хочу написати у phtml має бути в його пхп блоці
	- Щоб блок знав з яким продуктом він працює, використовують \Magento\Framework\Registry(у нього є метод get('current_product'))
	- Дивно, але у цьому блоці що тепер переписую(Block/Product) щоб взяти в phtml метод з блока, використовуэться не $block a $this



 Запитати у Вови за ці типи


 phpstorm виведе покаже значення змінної, якщо на неї навести
