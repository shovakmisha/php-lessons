
 ---------- 1 - The Magento Config - https://alanstorm.com/magento_config/ ----------

 1) У цій статті він нічого нового не написав, тільки була створена мінімальна конфігурація для модуля -  Alanstormdotcom_Configviewer

	- Також був створений обсервер який виводив всі глобальні конфіги на фронт - http://magento.on/?showConfig=true

	- Цікаво що обсервер запрацював без контроллера. Ніхто не наводив код на цей модуль. Я просто підписався на івент і метод обсервера запустився.

	- Але це також може бути проблемою. У мене були помилки в цьому коді і я не міг зрозуміти де помилка, поки не зрозумів що обсервери теж відпрацьовують

 ---------- 2 - Magento Controller Dispatch and Hello World - https://alanstorm.com/magento_controller_hello_world/ ---------

 1) Когда маршрутизатор анализирует URL, он разделяется следующим образом - http://example.com/frontName(<frontName> тег з файла конфіга config.xml)
												/actionControllerName(src/app/code/local/Alanstormdotcom/Helloworld/controllers/IndexController.php )
												  /actionMethod(src/app/code/local/Alanstormdotcom/Helloworld/controllers/IndexController.php - public function indexAction() {...)
		
		- Це я описав шлях до файлів, які маджента буде шукати при такому запросі - http://exmaple.com/helloworld/index/index

			- Тобто http://exmaple.com/checkout/cart/add - знайде в конфігах <frontName>checkout</frontName>, подивить в конфігах, який модуль до цього фронтнейма відноситься - Mage_Checkout і у цьому модулі у папці controllers знайде файл CartController.php і викличе метод addAction()
	
 2) Створюю новий роут для фронта 
	<frontend>
		<routers>
			<helloworld> - Этот тег должен быть строчной версией названия вашего модуля. Наш модуль называется Helloworld, этот тег - helloworld.
				<use>standard</use> - Я не впевнений, але мабуть це стандартний роутер - Mage_Core_Controller_Varien_Router_Standard - це тільки догадки
				<args>
					<module>Alanstormdotcom_Helloworld</module> - Этот тег модуля должен быть полным именем вашего модуля Кампанія/Модуль. Это будет использоваться системой для поиска файлов вашего контроллера.

					<frontName>helloworld</frontName> - це буде перше в адресній строці - http://example.com/frontName/ - Соглашение о том, что frontNames совпадает с именами модулей, не является обязательным. Фактически, один модуль может определять несколько <routers> и, следовательно, иметь несколько frontNames.
				</args>
			</helloworld>
		</routers>
	</frontend>

 3) В цій статті я створив декілька простих контролерів, щоб подивити як маджента розбарає юрл і на які контролери і екшни вона відправляє запрос. Але це не були поглиблені статті. Тут були тільки вершки. Тіпа ця юр-лка відправляє на цей метод, а ця на цей і тд...

 4) Всі фронтові контролери наслідуються від Mage_Core_Controller_Front_Action. Цей клас має метод getRequest(), який поверне обєкт реквесту. Тож всі котролери мають метод getRequest()



 ---------------- 3 Layouts, Blocks and Templates - https://alanstorm.com/layouts_blocks_and_templates/ ----------------

 1) Блоки рендеряться методом toHtml() тому що у цей метод указаний  атрибуті блока output -  <block type="page/html" name="root" output="toHtml" template="simple_page.phtml" />

 2) Атрибут type="page/html" вказує на то який клас буде $this у темплейта. Як воно оприділяє цей клас. Хоча система лейаутів і конфігів це 2 різні системи, всі класи лейаутів є у глобальниї конфігах. Тож коли я пишу атрибут type="page/html" це означає що я звертаюсь до глобальних кофігів шукати клас $_xml->global->blocks

	- page/html = $_xml->global->blocks->page - page це нода у конфігах, у якій храниться імя класа - http://joxi.ru/xAeg0WjfpwYzOm

	- page/html - html - це приставка до класу, який храниться в ноді <page> - Тож повне імя класу - Mage_Page_Block_Html

	- Але взагалі сам запис <block type="page/html" name="root" output="toHtml" template="simple_page.phtml" /> не правильний. По суті це я вставив блок "root" у блок "root". Це ставить мадженту в стан неопридільонності, так як всі блоки в мадженті мають бути з унікальними іменами, а в мене тепер 2 блоки з одинаковим іменем. Хоча маджента не викинула помилку, так не можна робити.

 3) <update> - апдейт не використовуються для перезаписування блоків. Вони використовуюються для оновлення або модифікації блока.

 4) Про лейаути можна думати як про конфіги. Типу всі лейаути що є в маджеті зєднуються в 1 файл local.xml і звідти вже будуть братись ті блоки, які потрібні сторінці

 5) getPackageLayout()->asXML() - цим методом Алан вивів всі глобальні конфігураціїї лейаутів (Типу як у конфінів, тільки для лейаутів). За звичай цей метод збере всі лейаути з цієї папки - app/design/frontend/base/default/layout/ . Хоча правильніше буде сказати що це виведуться всі лейаути текущої теми

	- Соотвецтвенно темплейти по дефолту він бере з app/design/frontend/base/default/template. Ну і понятне діло що якщо є якісь оверайди то вони теж будуть захвачені

	- Мабуть у 2-й мадженті будуть шукатись лейаути і у папці code, а не тільки у frontend

 6) <?php echo $this->getChildHtml('top.links'); ?> - Цей блок вивів заголовок сторінки чи її тайтл, кароче шось в такому роді


 ---------------------------------- Magento Models and ORM Basics (https://alanstorm.com/magento_models_orm/) ----------------------------------------

 1) Модели Magento не содержат кода для подключения к базе данных. Вместо этого каждая модель имеет два ModelResouces (одно чтение, одно запись), которые используются для связи с сервером базы данных (через объекты адаптера чтения и записи).

 2) В Magento есть система автоматического создания и изменения схем вашей базы данных (database schemas), но пока мы просто вручную создадим таблицу для нашей Модели.

	- Типу в цьому уроці Алан вручну створював - CREATE TABLE `blog_posts` (
							  `blogpost_id` int(11) NOT NULL auto_increment,
							  `title` text,
							  `post` text,
							  `date` datetime default NULL,
							  `timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
							  PRIMARY KEY  (`blogpost_id`)
							)

							- INSERT INTO `blog_posts` VALUES (1,'My New Title','This is a blog post','2009-07-01 00:00:00','2009-07-02 23:12:30');

	- Я так зрозумів що у цій статті Алан хотів показати як звязати звичайну sql таблицю з маджентівською оберткою. Головна суть мадженти при роботі з базою така сама як і в інших цмс-ок орм-ок - розділити бізнес логіку модельки з ресурсною. Вкінці цього уроку, я зможу достукатись до цієї таблиці маджентівським способом - $model = Mage::getModel('weblog/blogpost'); Алан розбив цю задачу на 5 етапів

		1) Включение модели в нашем модуле. Це звичайне добавленння моделі, щоб вкінці можна було її витягнути - Mage::getModel('weblog/blogpost');

			- Не буду ще раз описувати як маджента шукає клас на основі цього виразу Mage::getModel('cms/page'); так як я вже описував це коли розписував Цмс роутер

				- Хоча нагадаю що Mage::getModel('weblog ( weblog це назва групи. Тобто назва модуля ) /blogpost');

					- Всі інші модельки у модулі weblog будуть мати назву таку саму як і 'weblog', тільки закінчення інше 

		2) Включение Model Resources в нашем модуле. Ресурсна моделька якраз і общаєся з базою (<resourceModel>weblog_mysql4</resourceModel>)

			- Це типу як Mage::getResourceModel('weblog/blogpost'); але я не буду звертатись до бази цим синтаксисом. Звичайний getModel() буде работати. Мабуть у цьому й була задумка розробників, щоб getModel() міг звертатись і до звиайних модельок і до ресурсних. Алан казав шо це вже маджента на більш нижчому рівні буде звертатись цим методом - getResourceModel(). Типу Mage::getResourceModel('weblog/blogpost'); буде шукати в конфігах цю ноду - http://joxi.ru/DmB8DjGUwGjQwA а в ній вже вказана таблиця з якою я буду працювати

			- Коли я створюю модельку звичайну, яка не буде звертатись до бази, то у її конфігах мені не треба прописувати тег <resourceModel>. Але якщо мені треба працювати з базою, то треба і ресурсну модельку. Щоб її прописати, треба:

				-  <global>
					<models>
					    <weblog>
						<class>Alanstormdotcom_Weblog_Model</class>
						<resourceModel>weblog_mysql4</resourceModel> - у конфігах поки що звичайної модельки додати тег <resourceModel> 
					    </weblog>
					    <weblog_mysql4> - і додати ноду ресурсної модельки. Ця нода має таку саму назву як і значення ноди <resourceModel>
						<class>Alanstormdotcom_Weblog_Model_Mysql4</class> - Packagename_Modulename_Model_Mysql4. Це так само як і в звичайної модельки - базовий клас для всіх ресурсних модельок. У всіх ресурсних модельок у цьому модулі буде така сама назва, тільки закінчення різне
					    </weblog_mysql4>
					</models>
				    </global>

				- Ресурсна моделька сконфігурована

				- Якщо ресурсна моделька є у конфігах звичайної модельки, а файла з ресурсною моделькою не має, викине ексепшн

				- В загальному структура така, що в конфігах звичайної модельки я прописую ресурсну модельку <resourceModel>weblog_mysql4</resourceModel> це і буде шлях до ресурсної модельки - Weblog(modulename)/Model/Mysql4/ - І в цій папці храняться файли ресурсної модельки. Плюс імя файла ресурсної модельки таке саме як і імя звичайної модельки, до якої ресурсна привязана в конфігах - Blogpost.php - http://joxi.ru/D2PzQoZipO6oDr і теж мають мати метод _construct() { $this->_init('weblog/blogpost', 'blogpost_id'); }
				
					- Тут задається другий аргумент. Це майже завжди прімарі ключ таблиці з якою я працюю - http://joxi.ru/VrwElJwuO9kQg2

						- А перший аргумент по ходу для того щоб вказати що я привязуюсь до конкретної модельки 
		
				- Ресурсні модельки екстендяться від Mage_Core_Model_Mysql4_Abstract

		3) Добавьте «сущность» (entity) в наш модельный ресурс. Для простых моделей это имя таблиці

			- На даний момент я ще не сконфігурував підклюення до бази. Не вказав з якаю таблицею буду працювати, не вказав що я хочу робити з таблицею. Тепер цим і займусь

			- Що таке ентіті я писав вверху. Mage::getModel('weblog/blogpost'); У контексті ресурсної модельки (класи які наслідуються від Mage_Core_Model_Mysql4_Abstract), це ознаає що у конфігах групи модельок 'weblog', я буду шукати таблицю яка буде відноситись до цієї ресурсної модельки 'blogpost'

				<weblog>
					<class>Alanstormdotcom_Weblog_Model</class>
						<resourceModel>weblog_mysql4</resourceModel>
					</weblog>

				<weblog_mysql4>
					<class>Alanstormdotcom_Weblog_Model_Mysql4</class>
					<entities> - !!! ЦЕ ЕНТІТІ!!!! - http://joxi.ru/52agYDMf4jW15r
					    <blogpost>
						<table>blog_posts</table>
					    </blogpost>
					</entities>
				</weblog_mysql4>

		4) Указание адаптера чтения для нашего конкретного ресурса модели

			- Наприклад мої модельки знаходяться у модулі Weblog. Тож всі модельки в цьому модулі будуть відноситись до групи weblog. Щоб модельки групи weblog могли общатись з базою, їм треба вказати адаптер. Кожна група модельок може мати адаптер читання і запису. Для цього треьа прописати це в конфігах. Синтаксис такий, (група модельок)_ціль - <weblog_read>

				<resources>
					<weblog_read>
					    <connection>
						<use>core_read</use>
					    </connection>
					</weblog_read>        
				</resources>   

		5) Указание адаптера записи для нашего конкретного ресурса модели

			<resources>
				<weblog_write>
				    <connection>
					<use>core_write</use>
				    </connection>
				</weblog_write>      
			    </resources>

		- В цих 5 етапів я сконфігурував ресурсну модельку і взяв дані з бази

 ------------------------------------------------------------------------------------------------------------

	











 
