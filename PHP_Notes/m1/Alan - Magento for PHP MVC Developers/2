 ---------------------------------- Magento Models and ORM Basics (https://alanstorm.com/magento_models_orm/) ----------------------------------------

 1) Модели Magento не содержат кода для подключения к базе данных. Вместо этого каждая модель имеет два ModelResouces (одно чтение, одно запись), которые используются для связи с сервером базы данных (через объекты адаптера чтения и записи).

 2) В Magento есть система автоматического создания и изменения схем вашей базы данных (database schemas), но пока мы просто вручную создадим таблицу для нашей Модели.

	- Типу в цьому уроці Алан вручну створював - CREATE TABLE `blog_posts` (
							  `blogpost_id` int(11) NOT NULL auto_increment,
							  `title` text,
							  `post` text,
							  `date` datetime default NULL,
							  `timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
							  PRIMARY KEY  (`blogpost_id`)
							)

							- INSERT INTO `blog_posts` VALUES (1,'My New Title','This is a blog post','2009-07-01 00:00:00','2009-07-02 23:12:30');

	- Я так зрозумів що у цій статті Алан хотів показати як звязати звичайну sql таблицю з маджентівською оберткою. Головна суть мадженти при роботі з базою така сама як і в інших цмс-ок орм-ок - розділити бізнес логіку модельки з ресурсною. Вкінці цього уроку, я зможу достукатись до цієї таблиці маджентівським способом - $model = Mage::getModel('weblog/blogpost'); Алан розбив цю задачу на 5 етапів

		1) Включение модели в нашем модуле. Це звичайне добавленння моделі, щоб вкінці можна було її витягнути - Mage::getModel('weblog/blogpost');

			- Не буду ще раз описувати як маджента шукає клас на основі цього виразу Mage::getModel('cms/page'); так як я вже описував це коли розписував Цмс роутер

				- Хоча нагадаю що Mage::getModel('weblog ( weblog це назва групи. Тобто назва модуля ) /blogpost');

					- Всі інші модельки у модулі weblog будуть мати назву таку саму як і 'weblog', тільки закінчення інше 

		2) Включение Model Resources в нашем модуле. Ресурсна моделька якраз і общаєся з базою (<resourceModel>weblog_mysql4</resourceModel>)

			- Це типу як Mage::getResourceModel('weblog/blogpost'); але я не буду звертатись до бази цим синтаксисом. Звичайний getModel() буде работати. Мабуть у цьому й була задумка розробників, щоб getModel() міг звертатись і до звиайних модельок і до ресурсних. Алан казав шо це вже маджента на більш нижчому рівні буде звертатись цим методом - getResourceModel(). Типу Mage::getResourceModel('weblog/blogpost'); буде шукати в конфігах цю ноду - http://joxi.ru/DmB8DjGUwGjQwA а в ній вже вказана таблиця з якою я буду працювати

			- Коли я створюю модельку звичайну, яка не буде звертатись до бази, то у її конфігах мені не треба прописувати тег <resourceModel>. Але якщо мені треба працювати з базою, то треба і ресурсну модельку. Щоб її прописати, треба:

				-  <global>
					<models>
					    <weblog>
						<class>Alanstormdotcom_Weblog_Model</class>
						<resourceModel>weblog_mysql4</resourceModel> - у конфігах поки що звичайної модельки додати тег <resourceModel> 
					    </weblog>
					    <weblog_mysql4> - і додати ноду ресурсної модельки. Ця нода має таку саму назву як і значення ноди <resourceModel>
						<class>Alanstormdotcom_Weblog_Model_Mysql4</class> - Packagename_Modulename_Model_Mysql4. Це так само як і в звичайної модельки - базовий клас для всіх ресурсних модельок. У всіх ресурсних модельок у цьому модулі буде така сама назва, тільки закінчення різне
					    </weblog_mysql4>
					</models>
				    </global>

				- Ресурсна моделька сконфігурована

				- Якщо ресурсна моделька є у конфігах звичайної модельки, а файла з ресурсною моделькою не має, викине ексепшн

				- В загальному структура така, що в конфігах звичайної модельки я прописую ресурсну модельку <resourceModel>weblog_mysql4</resourceModel> це і буде шлях до ресурсної модельки - Weblog(modulename)/Model/Mysql4/ - І в цій папці храняться файли ресурсної модельки. Плюс імя файла ресурсної модельки таке саме як і імя звичайної модельки, до якої ресурсна привязана в конфігах - Blogpost.php - http://joxi.ru/D2PzQoZipO6oDr і теж мають мати метод _construct() { $this->_init('weblog/blogpost', 'blogpost_id'); }
				
					- Тут задається другий аргумент. Це майже завжди прімарі ключ таблиці з якою я працюю - http://joxi.ru/VrwElJwuO9kQg2

						- А перший аргумент по ходу для того щоб вказати що я привязуюсь до конкретної модельки 
		
				- Ресурсні модельки екстендяться від Mage_Core_Model_Mysql4_Abstract

		3) Добавьте «сущность» (entity) в наш модельный ресурс. Для простых моделей это имя таблиці

			- На даний момент я ще не сконфігурував підклюення до бази. Не вказав з якаю таблицею буду працювати, не вказав що я хочу робити з таблицею. Тепер цим і займусь

			- Що таке ентіті я писав вверху. Mage::getModel('weblog/blogpost'); У контексті ресурсної модельки (класи які наслідуються від Mage_Core_Model_Mysql4_Abstract), це ознаає що у конфігах групи модельок 'weblog', я буду шукати таблицю яка буде відноситись до цієї ресурсної модельки 'blogpost'

				<weblog>
					<class>Alanstormdotcom_Weblog_Model</class>
						<resourceModel>weblog_mysql4</resourceModel>
					</weblog>

				<weblog_mysql4>
					<class>Alanstormdotcom_Weblog_Model_Mysql4</class>
					<entities> - !!! ЦЕ ЕНТІТІ!!!! - http://joxi.ru/52agYDMf4jW15r
					    <blogpost>
						<table>blog_posts</table>
					    </blogpost>
					</entities>
				</weblog_mysql4>

		4) Указание адаптера чтения для нашего конкретного ресурса модели

			- Наприклад мої модельки знаходяться у модулі Weblog. Тож всі модельки в цьому модулі будуть відноситись до групи weblog. Щоб модельки групи weblog могли общатись з базою, їм треба вказати адаптер. Кожна група модельок може мати адаптер читання і запису. Для цього треьа прописати це в конфігах. Синтаксис такий, (група модельок)_ціль - <weblog_read>

				<resources>
					<weblog_read>
					    <connection>
						<use>core_read</use>
					    </connection>
					</weblog_read>        
				</resources>   

		5) Указание адаптера записи для нашего конкретного ресурса модели

			<resources>
				<weblog_write>
				    <connection>
					<use>core_write</use>
				    </connection>
				</weblog_write>      
			    </resources>

		- В цих 5 етапів я сконфігурував ресурсну модельку і взяв дані з бази

 ------------------------------------------------------------------------------------------------------------


 3) Все модели Magento наследуются от класса Varien_Object. Этот класс является частью системной библиотеки Magento и не является частью какого-либо модуля ядра Magento. Вы можете найти этот объект lib/Varien/Object.php

 4) Якщо це віднести до цієї модельки що я описував вверху, то клас модельки(Alanstormdotcom_Weblog_IndexController) до якої відноситься ресурсна моделька і якою можна обробляти базу, теж у предках має клас Varien_Object. Далі про нього і піде мова. 

	- Клас Varien_Object має свойство _data у якому він хранить свої дані (Типу ця система що коли є метод getData(), то шукається у обєкта свойство _data ). Якщо передивити код у якому я витягував дані з бази, то якраз цим методом я і витягував. 	$blogpost = Mage::getModel('weblog/blogpost');
							$blogpost->load('1');
							$data = $blogpost->getData();
							var_dump($data); - Виплюнуло масив (key=>value) у якому був рядок з бази, айдішка якого була - 1

								- Звиайно цей спосіб теж працює - getData('title');

	- На даний момент Алан ще не описував, як дані з бази потрапляють у свойство _data

		- getOrigData(); - хранить у собі дані бази, які вони були ще при ініціалізації обєкта Varien_Object. свойство _data вже теж має мати дані на цьому етапі

	- Varien_Object также реализует некоторые специальные методы с помощью магического метода __call в PHP (get, set, unset, or has - $model->getBlogpostId(); $model->setBlogpostId(25); $model->unsetBlogpostId(); if($model->hasBlogpostId()){...}). По цій причині, якщо ключі в базі по яких я буду витягувати свойства ключів будуть мати назву ловеркейс і андерскор, то з ними можна буде працювати через магічні ці методи ( hasBlogpostId - blogpost_id (це ключ в базі) )

		- Хоча у старіших версіях це може і не працювати через ArrayAccess.

	- еммм.... Алан описував що є якісь проблеми з магічними методами offsetSet, setData, але я не хочу описувати це. Ця проблема не у всіх версіях мадженти. Кароче якщо дан не будуть добавлятись в базу через ці магічні методи, можливо треба буде їх в ручну переписати. Так Алан пише. Кароче якшо шо, можна передивити статтю.

		- Кароче з магічними методами тут нє очень, і з ними треба бути уважним. Мабуть краще їх не використовувати 

--------------------------

	- Метод save придназначений для INSERT і UPDATE. Ось як Алан додавав нові поля в базу (в яку базу я описував вище).

		public function createNewPostAction() { - Це метод екшна. Тобто це отдільна сторінка. По структурі це більш нагадує відсилання форми. Типу на одній сторінці є форма і через кнопку сабміт мене перекидує на іншу сторінку де вона і обробиться. Ну і по ідеї після того як дані в базі збережуться, вкінці екшна треб буде писати код перенаправлення на потрібну мені сторінку. Кожен раз коли я буду переходити на сторынку, яку буду обробляти цей екшн, дані будуть зберігатись
		    $blogpost = Mage::getModel('weblog/blogpost'); - про таблицю, яку обробляє ця моделька я вже писав вище
		    $blogpost->setTitle('Code Post!');  - Це і є магічні методи, про які я писав. Цей метод означає що в базу добавиться ключ(якщо його ще не має) з іменем - 'title' - http://joxi.ru/l2Z46oyTwJZENr і значенням Code Post!
		    $blogpost->setPost('This post was created from code!');
		    $blogpost->save(); - Типу логіка така що спочатку задаю імя для полів (підготовча робота), а потім зберігаю
		}

		public function editFirstPostAction() { - Це апдейт таблиці. Описувати нічого не буду і так все понятно. Тут майже те саме що і з додаванням нового поля
			$blogpost = Mage::getModel('weblog/blogpost');
			$blogpost->load(3);
			$blogpost->setTitle("The First post!");
			$blogpost->save();
		}

		public function deleteFirstPostAction() { - Видалення поля з таблиці
		    $blogpost = Mage::getModel('weblog/blogpost');
		    $blogpost->load(1);
		    $blogpost->delete();
		    echo 'post removed';
		}

 ----------------------------- Model Collections ------------------

	- Щоб не загружати кожен рядок бази по одному ( load() ), можна загрузити цілу таблицю (колекцію) - Mage::getModel('weblog/blogpost')->getCollection();

		- Алан каже що колекція обширніша, як база, але про це потім

		- Щоб працювати з колекцією, треба створювати отдільний файл для неї. Це по ходу буде одна колекція на всю групу (папка Model у модулі).

			class Alanstormdotcom_Weblog_Model_Mysql4_Blogpost_Collection extends Mage_Core_Model_Mysql4_Collection_Abstract { - по ходу всі колекції мають екстендитись від цього класу
			    protected function _construct() {
				    $this->_init('weblog/blogpost');
			    }
			}

			- Кожен клас будь-якої моделі що у мене є має свойство _resourceCollectionName, по якому можна буде звертатись до колекції, яку у собі хранить ця моделька (  protected '_resourceCollectionName' => string 'weblog/blogpost_collection'). Типу як до цього я звертався до моделі - Mage::getModel('weblog/blogpost'); це те саме тільки вкінці добавлений _collection

			- Так як Маджента вважає що колекція це частина ресурсної модельки, то і шлях у неї буде ніби як під ресурсною моделькою, ну і клас звісно теж - Alanstorm_Weblog_Model_Mysql4_Blogpost_Collection. Це так по замовчуванню. Мабуть у конфігах це можна змінити. 

				- Трохи дивно що папку у якій буде хранитись ресурсна моделька треба називати так само як і ноду у якій храниться імя таблиці для ресурсної модельки (Blogpost) - http://joxi.ru/D2PzQoZipOX3pr. Дивно в тому сенсі що все дуже тісно повязано. Ну і від цієї ноди залежить цей вираз - Mage::getModel('weblog/blogpost');

					- Кароче суть у тому що щоб метод Mage::getModel('weblog/blogpost') створює обєкт, який буде працювати з базою. Це буде клас Alanstormdotcom_Weblog_Model_Blogpost (чому, я описував више). Суть метода getCollection() в тому що він переробляє клас з якого робиться метод який буде взаємодіяти з базою. Так як у модельки є свойство _resourceCollectionName (імя для класа колекції цієї модельки), яке дорівнює 'weblog/blogpost_collection', то по цьому виразу обєкт колекції і буде створюватись - Mage::getModel('weblog/blogpost_collection'); - Alanstorm_Weblog_Model_Mysql4_Blogpost_Collection . _Mysql4_ сюди втіснувся скоріш за все із за того що колекція залежить від ресурсної модельки і тепер буде понятно від якої 


 ------------------------- Magento Setup Resources - https://alanstorm.com/magento_setup_resources/ -------------------------------

 1) мы создадим установочный ресурс для нашего модуля, который создаст таблицу для нас. Мы также создадим скрипт обновления для нашего модуля, который обновит уже установленный модуль. Шаги, которые нам нужно сделать, это

	1) Добавьте Setup Resource в наш конфиг ( Add the Setup Resource to our config ) - Це створення інстал скріпта. Тут я вказую у конфігах який код буде виконуватись при загрузках сторінок. Кажу при загрузках сторінок, так як я не запускав сетап апгрейд для того щоб він запустився і Алан казав що після загрузки будяь якої сторінки код виконається. Це не обовязково звязане з базою. Виконуватись може будь який код, хоча цей функціонал призначений для роботи з базою

		<weblog_setup> - Алан каже що не обовязково щоб ця нода так назвивалась. Ні вона нідочого не привязується, ні до неї не привязуються. Головне щоб назва була унікальна
			<setup>
			    <module>Alanstormdotcom_Weblog</module>
			    <class>Alanstormdotcom_Weblog_Model_Resource_Mysql4_Setup</class> - це вже не арія - це вже клас. Саме з цього класу маджента створить обєкт. Скоріш за все цей клас і буде виступати в ролі $this для інстал скріпт файлів. Наскільки я зрозумів не обовязково вказувати цей клас. Якщо не вкажу маджента візьме дефолтний. Скоріш за все це той від якого екстендиться цей що я вказав в ноді <class>Alanstormdotcom_Weblog_Model_Resource_Mysql4_Setup extends Mage_Core_Model_Resource_Setup 
			</setup>
			<connection>
			    <use>core_setup</use>
			</connection>
		</weblog_setup>

		- у файлі config.xml модуля є строчки де я ініціалізую модуль. Там є трочка <version> - Це версія модуля. Це треба враховувати при створенні інстал скріпта. 

			- Наприклад тепер у мене версія <version>0.1.0</version> тож і закінчення мого інстал скріпта має бути -0.1.0.php

			- У конфігах інстал скріпта де я вказував його конфіги я прописав що його імя буде <weblog_setup> отже і папка у якій він буде знаходитись буде називатись weblog_setup

			- Кароче файл буде називатись mysql4-install-0.1.0.php - Мабуть mysql4 це обовязкове, так як так називається моя ресурсна модель, а install це якесь загальноприйняте. Але це тільки мої догадки, Алан про це нічого не писав

			- І знаходяться інстал скріпти у папці модуля sql (Modulenamme/sql/weblog_setup/mysql4-install-0.1.0.php )

		- Алан пише що якшо не має класа що в ноді <class> то цей ексепшн покажеться на всіх сторінках
------------------
		- Кароче тут досить все понятно. Наприклад мені треба створити таблицю в базі через інстал скріпт. Я новий інстал скріпт файл, роблячи все то що описував вверху. Після того як я очищу кеші, у мене зявиться ця база -     $installer = $this; - це не обовязково робити змінну $installer, але це рекомендації
				    $installer->startSetup(); - це не просто обява, цей метод виконує декілька підготовчих ф-цій - $this->getConnection()->startSetup();

					- $this->getConnection() - установлює зєднання з базою і потім ->startSetup() - це $this->raw_query("SET SQL_MODE=''");
														$this->raw_query("SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0");
														$this->raw_query("SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO'");
		
														- Алан каже що це якісь базові настройки sql
		
				    $installer->run("
					CREATE TABLE `{$installer->getTable('weblog/blogpost')}` (
					  `blogpost_id` int(11) NOT NULL auto_increment,
					  `title` text,
					  `post` text,
					  `date` datetime default NULL,
					  `timestamp` timestamp NOT NULL default CURRENT_TIMESTAMP,
					  PRIMARY KEY  (`blogpost_id`)
					) ENGINE=InnoDB DEFAULT CHARSET=utf8;
				    
					INSERT INTO `{$installer->getTable('weblog/blogpost')}` VALUES (1,'My New Title','This is a blog post','2009-07-01 00:00:00','2009-07-02 23:12:30');        
				    ");
				    $installer->endSetup(); - Те саме що і startSetup() - базові налаштування sql

					- http://joxi.ru/YmEzDoji0QYOO2 - це та база, яку я створював на попереднії уроках, Тільки на цей раз я створив її в інстал скріпті а не в ручну

		- core_resource - ця таблиця хранить у собі список установлених модулів і їхню версію - http://joxi.ru/Q2Kz7o6i4KQBQm . Якщо при загрузці, маджента побачить що у мене є установлений модуль і його не має у цій таблиці, маджента запуститьінстал скріпти і добавить модуль у цю таблицю. Типу схоже на просте добавлення нового модуля але при цьому іще і інстал скріпти спрацьовують

			- Коли я робив цей урок, то у мене був модуль з великою версією. Я видалив його з бази DELETE from core_resource where code = 'weblog_setup'; поставив 0 1 0 і не було помилки

	2) Создайте наш файл класса ресурсов ( Create our resource class file )

	3) Создайте наш установочный скрипт ( Create our installer script )

	4) Создайте наш скрипт обновления ( Create our upgrade script ) - Все так само як і створення інстал скріпта тільки трохи відрізняється. 

		- Назвою - mysql4-upgrade-0.1.0-0.2.0.php // 0.1.0 - вказує що я це роблю для модуля з версією 0.1.0 / 0.2.0 - вказує до якої версії я його обновляю
		
		- Щоб запустити апдейт скріпт, не достатньо просто додати новий файл mysql4-upgrade-0.1.0-0.2.0.php, треба і змінити версію модуля у файлі config.xml на 0.2.0		
		
			- Після того як я очистив кеші скріпт запрацював. дивно. У файлі апдейт скріпта був просто echo 'Testing'; die(); і він запрацював зразу після того як я нажав на кнопку очищення кешів. Запрацював у тому сенсі, що вивівся текст 'Testing' на білій сторінці і виконання коду стопанулось. Коли я робив інстал скріпт, то він відпрацьовував, але тільки в базі. текст не виводився

			- !ВАЖЛИВО - Наприклад я створив апдейт скріпт. mysql4-upgrade-0.1.0-0.2.0.php, який буде оновлювати модуль до версії 0 2 0. Але вкінці цього скріпта поставив die() І не чистячи кеші і не оновляючи сторінку, створив ще один інстал скріпт mysql4-upgrade-0.1.0-0.1.5.php - В мене в базі у таблиці core_resource у мого модуля графа - version = 0 1 5 а графа data_version = 1 0 1 - http://joxi.ru/EA4LvxOiw7lwqA

				- Чому так?  Якщо розбити це на кроки, то 

					1) ресурс weblog_setup был версии 0.1.0

					2) Мы обновили наш модуль до версии 0.2.0

					3) Magento увидел обновленный модуль и увидел, что нужно запустить два сценария обновления; От 0,1,0 до 0,1,5 и от 0,1,0 до 0,2,0

					4) Magento поставил в очередь оба сценария для запуска

					5) Magento запустил скрипт от 0.1.0 до 0.1.5

					6) Ресурс weblog_setup теперь имеет версию 0.1.5.

					7) Magento запустил скрипт от 0.1.0 до 0.2.0, выполнение было остановлено - die()

					8) На следующей странице загрузки Magento увидел weblog_setup в версии 0.1.5 и не видел ни одного скрипта обновления для запуска, так как оба скрипта указали, что они должны быть запущены с 0.1.0 (Це вже від себе. При насткпній загрузці сторінок, сам код у апдейт скріптах не відпрацьовував, але версія у модулі змінились на 0 2 0)

					- Правильный способ достичь того, чего мы хотели, - это назвать наши сценарии следующим образом

						mysql4-upgrade-0.1.0-0.1.5.php #This goes from 0.1.0 to 0.1.5
						mysql4-upgrade-0.1.5-0.2.0.php #This goes 0.1.5 to 0.2.0 - У цьому випадку скільки б разів я не перезагружав сторінку, код у цьому файлі завжди буде спрацьовувати так як у ньому є строчка die() яка зупиняє виконання коду, а отже версія модуля так і залишиться 0.1.5 (Маю на увазі що наді у базі міняються вже після виконання апдейт скріпта



 - 









