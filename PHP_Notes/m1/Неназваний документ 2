
 - Mage::getStoreConfig('foo/baz/bar'); - метод щоб витягти дані з таблиці core_config_data. Є ще методи щоб працювати з цією таблицею, наприклад метод щоб змінити дані core_config_data

	- Але вроді він і так буде тягнути дані не з таблиці бази а з глобальних конфігів

	- Це поки не выдноситься до глобальних конфігів. Алан каже що теж отдільна система конфігів. Є можливісь змінити дані в таблиці core_config_data з адмінки (лого, бейз юрл), не тільки в з коду, тому це отдільна система. Про цю систему, Алан розказував тут - https://alanstorm.com/magento_system_configuration_in_depth_tutorial/

	- Після змін в цій таблиці треба почистити кеш









				

					



				

			

			- 



						




	- Зберігаються дані в кеш - $this->_config->saveCache();
	- $this->loadAreaPart() - Загрузка івентів.... і тд. У даному випадку глобальних івентів - $this->loadAreaPart('global', 'events');
	- $this->_initCurrentStore() - Загрузка текущого стору стору. При ініцілізації маджента вже витягнула всі стори вроді стори які є в адмінці. Тут по ходу вона назначає його в залежності від країни або таймзони, короче не знаю по чому, але після цієї ф-ції зявилась змінна стору ('fr_fr'). Наскільки я зрозумів. Ці стори є в базі (якщо є в адмінці, є і в базі)
	- $this->_initRequest() - Загрузка реквесту ( По ходу тут получаю адресну строку )
	- Mage_Core_Model_Resource_Setup::applyAllDataUpdates(); - накочуються data аптейти. Ввверху я писав про це. У першій маджеті дані модуля в базі храняться в папці sql i data. sql накочуються раніше, а тепер накочуються з папка data. Рызницы в цих папках як такої не має, але зазвичай у папці sql створюється таблиця або структура таблиці а в папці data дані, які заповнюють таблицю
	5) $this->getFrontController()->dispatch(); - src/app/code/core/Mage/Core/Controller/Varien/Front.php init();
 13) init() - Ініціліалізація Фронт контролера. Фронт контролер проходиться по роутах. Наскільки я зрозумів, Фронт контроллер віддає запит кожному роуту, типу цей запрос тобі підходить? 
	- Але судячи з того що за 1 раз може загрузитись не тыльки 1 роут (бачив у Вови на відео), то можна сказати що після того як роут приймає запрос, фронт контроллер не перестає перебирати роути. Хоча не факт, так як Вова сказав що якщо я хочу добавити свій роут (а цей адресу для цього роуту може прийняти стандартний роут мадженти), то мій роут треба додавати перед нативним, інакше нативний роут його обробить. Щоб маджента обробила мій роут першим можна підписатись на івент, який виконується до роутінга - "controller_front_init_before"
	- Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH); XML_STORE_ROUTERS_PATH(web/routers) - це кусок коду в головній хмл конфігів у якій знаходяться стандартні роути <web><routers>
Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH) - ця ф-ція робить з кусків коду xml, многовимірний масив. Тож скоріш за все можна будь який кусок xml перетворити в масив по аналогії 

	- До речі у роуті я подивив як з класа що знахотиться в xml робиться обэкт - просто через new. Цілком можливо що всюди так, а не тыльки в роутах
	- Мабуть я зрозумів. Всі роути які є у мадженті задіюються і перебираються. Маджента заходить в їх код і якщо вони оброблять реквест що в адресній строці, то ок, якщо ні, то ні (типу якщо у роуті буде кондішн і адресна строка його відповідає цьому кондішну, то код піде туди, куди направляє цей роут. Принаймні стандартиний роут повертає фолс при матчінгу, якщо адресна строка не його )
 14) По ходу у першій мадженті роути створюються попроще як у 2-й. Вова показував 2 стандартні роути для фронта і адмінки, які знаходяться в Mage/Core/etc.xml і виглядають вони дуже просто 
<stores>
	<default>
		<web>
			<routers>
				<admin>
				    <area>admin</area>
				    <class>Mage_Core_Controller_Varien_Router_Admin</class>
				</admin>
				<standard>
				    <area>frontend</area>
				    <class>Mage_Core_Controller_Varien_Router_Standard</class>
				</standard>
			</routers>
		<stores>
	<default>
<web>
Мабуть треба ще щось, але наскільки я зрозумів, щоб створити свій власний роут, треба скопіювати цей кусок коду у свій модуль/etc.config.xml, підставити туди свої назви, класи і написати в класі код, який буде обробляти цей роут
 15) Вкінці метода init() добавляється дефолтний роутер (Якщо жоден роут не підійшов, вибереться цей) 
	- $default = new Mage_Core_Controller_Varien_Router_Default();
        - $this->addRouter('default', $default);
	- типу буде 404 або index/index (кароче шось стандартне)
 15) Далі виконується метод dispatch() у файлі фронтконтролера
	- Він проганяє роути, які будуть приймати запрос через метод match()
16) Матчінг - $router->match($request) - проганяє роути. 
	- Я не знаю чи це є у всіх роутів чи кожному треба добавляти. Це приклад зі стандартного фронтового роута - Mage_Core_Controller_Varien_Front; Є можливість назначати модуль, контролер, екшн дефолтні(index) public function fetchDefault() { $this->getFront()->setDefault(array(
17) В своэму роуті я можу додавати свої івенти
18) Вова розбирав роут CMS - Mage_Cms_Controller_Router. Стандартний фаронтовий і адмінський роути йому не підійшли (по формату юрл), а роут cms підійшов. Він добавлений з коробки і Він і буде обробляти запрос  
	- Вичислив ідентифікатор - і поставив у змінну $identifier
	- Задиспатчив якиїсь свій івент
	ЦЕЙ КОД ПРОДУБЛЬОВАНИЙ З ПЕРШОГО ФАЙЛУ 
	- Береться моделька cms - $page   = Mage::getModel('cms/page');

		- return self::getConfig()->getModelInstance()

		- getModelInstance() - розбираю першу строчку - $this->getModelClassName($modelClass); - $modelClass виглядає як cms/page, тому перший кондышн не працює, а йду далі

			- return $this->getGroupedClassName('model', $modelClass); - Далі мова буде йти про getGroupedClassName(). Я памятаю, що при Mage::getModel('cms/page'); я не запускаю зразу автолоадер класів, а йду шукати цей клас в файлі конфігів xml, який збирає всі конфіги і збивається в 1 - 

				1) Перевіряє арію, якщо немає, вказує глобал - $groupRootNode = 'global/'.$groupType.'s'; Тут вкінці додається 's'; Ось чому тег називається <models> а не <model>

				- Перевіряє чи клас Mage::getModel('cms/page'); не зареврайчений у моїй Кампінії. Якщо так, візьметься зареврайчений клас

				- І ще там є строчка де назва модуля Mage пыдставляэться автоматом. Тобто якщо не має конфігів для модельки у зареврайченосу класі, підcтавиться mage. Наприклад із цього Mage::getModel('cms/page') попробує скласти клас Modyf_Cms_Model_Page, але якщо конфігів у моєму модулі не буде, побудується Mage_Cms_Model_Page. Це означає що у app/code/core/Mage/Module/etc/config.xml вказувати шлях до класа у конфігах не треба, головне щоб він фізично лежав по правильному шляху і він мав би знайтись.
			
				- В ітозі getGroupedClassName() поверне Modyf_Cms_Model_Page. З цього класу створиться обєкт $obj = new $className($constructArguments); Це був розжований курс про те що вираз  Mage::getModel('cms/page'); поверне обєкт з класа Modyf_Cms_Model_Page

	- Після того як він розібрався з моделькою для класу, назначається контролер
$request->setModuleName('cms') - модуль
            ->setControllerName('page') - Контролер для цієї цмс пейджі
            ->setActionName('view') - екшн для цієї цмс пейджі
            ->setParam('page_id', $pageId); - Тут по ходу будуть медіа квері з адресної строки або скоріш за все - це ідентифікатор цмс сторінки
        $request->setAlias(
            Mage_Core_Model_Url_Rewrite::REWRITE_REQUEST_PATH_ALIAS,
            $identifier
        );
	- Потім роут повернув тру. Це означає що він розпізнав юрл-ку




У стандартного роута (app/code/core/Mage/Core/Controller/Varien/Router/Standard.php) для фроонта э метод $request->getModuleName() - вын буде запрашувати імя модуля для цього роута. Хоча з адресної строки зрозуміло який модуль буде це робити, але може бути таке, що ще до виклику станддартного роута був викликаний обсервер, який змінив модуль. То тут по ходу вже візьметься цей змінений модуль
	- Вова розказував що строчка // get module name if ($request->getModuleName()) {.... getModuleName - візьме роут який підійшовю ТОбто вверху я розбирав роут цмс пейджі, і там вкінці назначався моду, класс, ... а потім повертався тру. Тру це означає що роутер підходить і він сюди підставиться 
 - У стандартному роуті(Mage_Core_Controller_Varien_Router_Standard) є - Метод collectRoutes будет проходить через объединенное дерево config.xml и искать узлы <router />. Где он ищет узлы маршрутизатора, зависит от параметра $ configArea, который передается, когда объект маршрутизатора добавляется к объекту Фронт-контроллера.
https://alanstorm.com/magento_dispatch_standard_router/
 - Потім йдуть всякі перевірки щоб подивити чи саме цей модуль буде оброблятись (Шторм їх розписував)

 --------- Потім йде вктановка контролера ------------

 - Коли вже точно вирішилось що це саме цей модуль ( Наприклад Catalog ) йде перевірка чи цей роутер існує (цикл під строчкою - Going through modules to find appropriate controller). Тобто вже всі <роутери> з файлів config.xml загрузились. Клас Mage_Core_Controller_Varien_Router_Standard має змінну $_routers у якій він хранить всі роутери що він бачить. Тепер йде перевірка чи мій роут є у цьому списку. Якщо є, йдем далі метод getRouteByFrontName() поверне мій роутер. Буде щось таке - $request->setRouteName('My_Route') реквесту присвоъвся мій роут
 - $request->setRouteName - $this->_route = $route('My_Route'); Метод setRouteName знаходиться у файлі Mage/Core/Controller/Request/Http.php
 - Потім повертаюсь у фонтконтроллер - $router = Mage::app()->getFrontController()->getRouterByRoute($route); щоб знайти <frontName> (<frontName>my_module</frontName> у файлі config.xml) для мого модуля.
	- Нагадую що я ще в циклі, який проходиться по всіх роутах що записані (навіть у модулях) у файлі config.xml. getRouterByRoute() Перевірить чи це не стандартний роут для фронта або адмінки, і назначить роутер по фронтнейму(<frontName>) - $router = $this->getRouter($routeName); return $router; Нагадую це четод getRouterByRoute у файлі /lxc/modyf/home/smile/modyf/src/app/code/core/Mage/Core/Controller/Varien/Front.php
 // Повертаюсь до метода setRouteName(); поки не знаю що тут доповнити

 - $this->_checkShouldBeSecure($request, '/'.$module.'/'.$controller.'/'.$action); - Цей кусок робить з http https
 - $controllerClassName = $this->_validateControllerClassName($realModule, $controller); - Провіряє чи є файл контролера (типу цього $this->_validateControllerClassName('Mage_Catalog', 'category');)
 - Потым йде перевірка чи є файл контролера і якщо є виконується його інклюд в код
 - Потім цей контролер ініціалізується і йде провіка чи він наслідується від instanceof Mage_Core_Controller_Front_Action;
 - Потім Контролер назначає Екшн
 - Запускається dispatch()
	-  У методі dispatch назначається арія(фронтенд, adminHtml) у методі preDispatch(). Також у методі preDispatch я вперше побачив щоб встановлювались якісь сесії і кукі
	- $this->$actionMethodName(); - тут викликається екшн контролера
 - Поотім ретурниться true; Вроді на цьому з екшнами і контролерами все закінчується.  
 

 - Якщо у мене буде пустий контролер з пустим екшном, загрузиться біла сторінку
 - Для того щобвідмалювати сторінку, використовується метод loadLayout() - Він викликається в контролері в екшні !!!!! Подивити детальніше
	- У процеcі встановлення хендлів, загружаються лейаути для блоків (xml-ки)
 - Далі лейаути рендеряться - метод renderLayout();
	- Тут вже встановлюються заголовки на сторінку в тег <head>


 getRouteByFrontName






















1) У мадженті є функціонал, де у адмінці можна задати режим і на сторінці виведуться усі phtml-ки у тих мысцях де вони розположены на сторінці. Але це не стосується cms-блоків
	- Також э функціонал де показується клас, для цього блока (Company/Modul/Block/Folder/File)
	- Обовязково треба щоб при цьому був конкретний стор вакзаний
2) ->getсCildHtml(імя_блока_якого_мені_треба); - виведе контент дочернього блока
3) Mage_Core_Block_Abstract - базовий блок від якого наслідуються всі блоки
	- toHtml(); - метод щоб відобразити блок любого типу
4) Mage_Core_Model_Abstract - наслідуються від нього всі моделі. Вова казав що модель має наслідуватись від Mage_Core_Model_Abstract якщо вона працює з базою і в конфігах модуля має присуцтвувати ресурсна модель - <resourceModel>modyf_catalog_resource</resourceModel> - цей запис має бути в файлі конфіга наскільки я зрозумів. modyf_catalog_resource - це шлях до фізичної папки
	- Вова трохи розказував про те як работає моделька, ресурсна моделька. Нічого конкретного, але можна передивити додаток до першого уроку, там це є (метод save(), afterSave() (запис в базу) ...). Це треба передивити коли буду краще розуміти. Там медод сейв викликається у різних модельок (спочакту абстрактна потім ресурсна) 
5) Mage_Core_Controller_Front_Action Контролер для фронта від якого всі наслідуються
	Mage_Adminhtml_Controller_Action Контролер для адмінки від якого всі наслідуються
6) Mage_Core_Helper_Abstract - цей клас наслідують хелпери
7) toHtml() - ф-ція яка рендерить html. Вона викликається з phtml файла і вона існує, так як $this phtml це Block, а класи у папці Block наслідуються від Mage_Core_Block_Abstract у якому є ця ф-ція
	- Mage_Core_Block_Abstract викликає івент mage_block_abstract_to_thml_before до выдрисорки блока, тож перед вірисовкою, блока його можна редагувати. mage_block_abstract_to_thml_before викликається до взятьття даних з кеша
	- Також він кидає івент mage_block_abstract_to_thml_after, який викликаэться після відрисовки
8) І перед toHtml() виконужться метод beforeToHtml(), який за замовчуванням пустий ы його можна редагувати. Але зазвичай редагують сам toHtml()
	- У методі toHtml() йде перевірки чи можна загрузити блок з кеша, якщо можна загрузить з кеша. 
8) В мадженті є декілька типыв блоків з якими я буду працювати. вони знаходяться в папці core в папці Block і їх можна буде використовувати або від них наслідуватись. 
	- Наприклад text/list мав би виводити всі дочірні блоки лейаута, хоча у Вови не виводилось. Виводилось тільки тоді, коли він з батьківського у phtml визвав ф-цію getChildHtml(імя блока у лейауті)
	- Суть цих класів блоків одна- інклюд phtml. Тобто вони кидають phtml в браузер. Тільки кожен по різному
	- $this->getChildHtml('name') - це писати у phtml ТОбто у класі блока є метод getChildHtml, який виведе хтмл phtml-ки, яка вказана у лейауті
	- <block type="page/template_links" name="top.links"/> - Добавив для разнобразія. Якщо добавлю цей блок собі на сторінку, відобразяться всі лінки сторінки у цьому блоці. Маю на увазы що типыв блоків є не 1, їх декілька і вони по різному виводять інформацію. Наприлад може виводитись тільки текст блоків
	- Назви блоків старатись давати логічні, щоб був зрозумілий контекст. Вова давав як у верстці БЕМ
9) Та і в загальному шляхи в xml-ках у m1 вказауються скорыш за все так, що сточатку імя модуля, слеш, а потім папки вказуються не через слеш а через андерскор catalog/product_compare_sidebar
10) Коли я в папці layout створюю файл local.xml, то він буде доступний по всій темі (у другій мадженті мабуть тільки в модулі). Тобто я референснув якиїсь блок, добавив афтером щось і це буде всюди на всіх сторінках, де є блок який я переписав
11) З коробки є декілька типів блоків, і можна екстендити який мені зручно
	- Навіть не обовязково екстендити. Можна викликати його методи з хмл-ки. Наприклад Mage_Core_Block_Text має метод setText, який виводить всі свої дочірні блоки
		 <block type="core/text" name="catalog.test_name">
	            <action method="setText">
	                <text>Redd</text> виведе цей текст. Це буде як аргумент, оскільки у метода setText метод приймає аргумент $text, хоча Вова казав, що тег може мати любе імя. Але якщо блоку присвоїний темплейт, то method="setText" може не спрацювати
	            </action>
		  </block>
	- У класа блока є метод який видаляє блок. Тож у хмл можна змінити блок видаливши його і поставити новий
		<reference name="content">
			<action method="removeChild"><name>customer_form_login</name></action>
			<block type="yourmodule/form_login" name="customer_form_login" template="customer/form/login.phtml"/>
		</reference>
12) На блок без імені не дують атрибути remove, before, after
12) before="-", after="-" кидає блок в самий верх, або в самий низ. Вова казав що вони працюють тыльки внутрі типа "text/list" так як в цьому виді темплейта блоки блоки сортуються 
13) Перезапис содержимого блока дуже простий, просто тег <reference name="імя блока"> 
	- Але - reference не заменяют блоки. Вместо этого они используются для добавления или изменения существующих блоков. Фактически они вставляют новый блок с именем блока в существующий блок, который создает неопределенное состояние для блока який я переписую (блоки должны быть однозначно названы). Тобто створюється новий блок з таким самим іменен, а оскільки 2 блоки з одинаковим іменем не можна, береться останній. Короче краще загуглити як правильно оверайдити лейаути
14) У контролері я загружаю лейаути. У m1 - це методи
	$this->loadLayout(); - Загрузка лейаутів. В середині цього метода назначаються хендли для сторінки
        $this->renderLayout();
	- Кожен з цих методів посилає якісь івенти, тож якщо мені треба буде написати код на різних етапах формування сторінки, можна буде привязатись до цих івентів



 - Є ще ода арія install, вона використовується при установці мадженти один раз
 - Итак, определив значение «helloworld» в тегах <frontName>, мы сообщим Magento, что мы хотим, чтобы система отвечала на URL-адреса в виде http://example.com/helloworld/*
 - frontName соответствует имени нашего модуля. Это условное соглашение о том, что frontNames соответствуют именам модулей, но это не является обязательным требованием. Фактически, один модуль может определять несколько <routers> и, следовательно, иметь несколько frontNames.
 - Контролери будуть знаходитись в папці controllers. У цій папці маджента буде шукати контролери. 
	- Шторм каже що до шлях до контролера будується так що береться шлях з файла config.xml Company_ModuleName Потім імя контролера Index - Company_ModuleName_Index і вкінці добавляється слово Controller - Company_ModuleName_IndexController - Це фізичний файл контролера. Суть у тому що і для котролера і до екшна перша маджента додає слова Controller і Action 
	- Екшн же це метод наскільки я зрозумів. Тому що у файлі Company_ModuleName_IndexController.php є клас з іменем Alanstormdotcom_Helloworld_IndexController і методом indexAction(), який викликається автоматом
		- Для того щоб запрацював інший метод екшна, треба його написати в адресній строці https://modyf.lxc/helloworld/index/goodbye і назвати так метод public function goodbyeAction(){...}
 - коли Маджента шукає клас(вона шукає у файлі конфігів), то спочатку дивить у глобальну арію, а потім якщо існує фронт або адмін, то вони беруться перекриваючи глобальну
 - Всі xml-ки лейаутів( їх можна назвати хендлами) вкінці обєднуються у файл local.xml, тому той код що я писав у файлі local.xml може зареврайтити будь який блок. Шторм казав що файл local.xml вкінці кінців стає файлом конфігів, але Фесько казав що local.xml накатується на файл конфігів. Тобто загрудаэться сторінка і для цієї сторінки назначаються хендли. Маджента загружає повний список усіх хендлів і при загрузці сторінки вибирає з цього списка ті, які їй потрібні

---------- Handles ------------
 - Каждый запрос страницы (при кодній загрузці сторінки) в Magento генерирует несколько уникальных Handles. Для прикладу - 
	- default - це хендл <default>. У скомбінованому файлі всіх лейаутв є штук 20 хендлів з неймом <default і зазвичай там загальні блоки (хедер, футер, загрузка скріптів, ...). Але можуть бути і сторонні блоки. Тобто якщо у модуля є хендл з <default>, то скоріш за все цей блок буде на всіх сторінках, так як хендл <default> майже завжди загружається на сторінку. Або може бути ще таке що у хендлі <default> розміщені всі блоки сторінки
	- STORE_fr_fr - стор. Саме цей запис я не побачив у скомбінованому файлі лейаутів. Мабуть у цьому й причина, що Алан Шторм скомбінував хендли лейаутів і хендл стора туди не попав
	- THEME_frontend_default_default - тема. Цей хендл теж існує, але у скомбінованому файлі лейаутів його теж не було 
	- helloworld_index_index - модуль, контролер, екшн. По ходу після того як маджента оприділила який екшн буде обробляти сторінку, вона назначає цей хендл. 
		- По ходу назва лейаута - це хендл (Ну вроді у другій мадженті так було, що якщо є назва лейаута така сама як хендл, то він брався в оборот). Але в м1 мабуть назва файлу лейаута не важлива, головне щоб у ньому був написаний хендл моєї сторінки (якщо я хочу щоб у моєї сторінки були унікальні блоки)  
		- Цей хендл огортає мою сторінку. Значить в ньому я можу писати/переназначати блоки, які я маю на сорінці (<helloworld_index_index><reference name="root">...<helloworld_index_index>)
		- Xендл можна переоприділити. Типу в мене є 2 екшни в index контролері - indexAction i goodbyeAction. Їм назначились хендли helloworld_index_index і helloworld_index_goodbye 				<helloworld_index_goodbye>
				<update handle="helloworld_index_index" /> Це я заоверайдив хендл helloworld_index_index у helloworld_index_goodbye. helloworld_index_goodbye унаслідує блоки
		        </helloworld_index_goodbye> 
		- Можна навіть написати хендл <helloworld_index_goodbye> у будь якому модулі теми і він загрузить свої блоки. і там заоверайдити його чайлди якщо треба. Маджента і так загружає всі лейаути
	- customer_logged_out - Цей хендл можна знайти у стиску скомбінованих лейаутів і він підгружає декілька блоків на сторінку. Тобто саму назву customer_logged_out не можна знайти у списоку лейаутів загружених на сторінку, можна тільки знайти блок, який відповідає цьому хендлу. Якщо користувач зареєстрований, то прийде хендл customer_logged_out. Тож у лейауті можна створити 2 хендли для зареєстрованого і незареєстрованого користувача і в них писати різні блоки і вони будуть показуватись в залежності чи користувач зареєстрований чи ні
		- Але треба памятати що і helloworld_index_goodbye і customer_logged_out це хендли. І наскільки я бачу код, то ніде не бачив щоб у хендлі був хендл. У хендлі тільки блоки. Навіть Вова коли робив функціонал у лейауті щоб для незареєстрованих користувачів (customer_logged_out) не показувався якиїсь блок, то він вставив блоки у хендл <helloworld_index_index><block ...></helloworld_index_index> а після (не в) з <helloworld_index_index> написав хендл customer_logged_out і в ньому видалив цей блок, щоб для нерареєстрованих він не показувався <customer_logged_out>
																			<remove name="block"/>
   																		  </customer_logged_in>
		- Наскільки я зрозумів, хендл у xml це якиїсь логічний участок xml у якому обєднані блоки(<block>) - <customer_logged_out></block></block></block></customer_logged_out>. Наприклад є хендл <catalog_product_view> у якому по ходу взагалы вся сторінка продукту. І мабуть при загрузці сторінки https://modyf.lxc/catalog/product/view, маджента буде шукати цей хендл і загрузить блоки з нього
	- Повторюсь. Блоки в лейауті дуже гнучкі, їх можна писати в будь якому порядку. І викликати їх можна будь якими методами. Або зробити щоб батьківський блок виводив всі дочірні, або в темплейті можна вивести дочірній блок

Контролер і блок можуть звертатись до модельки. Вюшка колизвертається - це не правильно 
	- контроллер не передает данные ни в какие блоки или макет
 - output="toHtml" - Якщо лейаут не викликав метод toHtml, то дані лейаута не виведуться
 - Кожен екшн відповідає за загрузку лейаута ( loadLayout ) і потім рендерить його
 - шТОРМ КАЖЕ що - Если совпадение найдено, производятся Action Controller и Action. Тобто фронт контролер не проходиться по всі роутах. Якщо знайде схоження ініціалізує кантролер і екшн
 - Не знаю чим це допоможе, але екшн контролер створює обєкт з лейаута, а лейаут в свою чергу створює обєкт з класа блока. Тобто то що я з phtml-ки можу витягувати дані як з обєкта, це тому що лейаут створив з нього обєкт і $this в phtml це обєкт


 catalog(handle)_product(handle)_view(handle)





 - Щоб створити лейаут файл для модуля мадженти, треба прописати його в etc/config.xml цього модуля <frontend> - не обовязково фронтенд, можна і для адмінки поміняти лейаут
													<layout>
													    <updates> 
														<shovak_customerinfo> - це не назва модуля, скорыш для зручності, головне щоб унікальне
														    <file>shovak_customerinfo.xml</file> - фізичний файл лейаута. Якщо це системний леяут то назви компанії там не має (mage(без mage)_customerinfo.xml)
														</shovak_customerinfo>
													    </updates>
													</layout>
												    </frontend>


14) Імена у блоків не можуть бути одинакові взагалі (навіть якщо я видалю блок з іменем vasya, я не можу створити новий блок з іменем vasya), а от аліаси - можуть (as="name"). тож у одомому або й тому ж файлі (або у різних файлах) можуть бути блоки з одинаковим аліасом. Перезаписаний блок має мати інше імя.
	- Якщо у темплейті є видалений(remove='true') блок name="customer_new" з аліасом new, а я створив інший блок name="customer_new2" і дав йому аліас news, то $this->getChildHtml('news') покаже содержиме блока customer_new2
	- До речі якщо видалити блок а потім його перезаписувати, то вже не треба у перезаписаному вказувати клас і темплейт його, маджента памятає
15) У m1 кожен клас який додається в модуль, треба прописувати в конфіги. Наприклад я додав у папку Block свій блок. Тож у кожфігах (etc/config), треба прописати <global(можна ы конкретно вказати арію)><block><Company_Module(не обовязково але головне щоб унікальний)><class>Company_Module_Folder_ClassNameOfBlock
16) До речі шляхи у луйауті теж не так як у другій shovak_customerinfo/customer_name (Company_Module/Folder_ClassNameOfBlock)


17) Запрос іде в контролер, це передається в лейаут, а алейаут створює блок, який в свою чергу створює модельки
	- $this->getLayout()->getUpdate()->getHandle() - це б мало вивести хендли сторінки (default, STORE_fr_fr, THEME_frontend_default_default, helloworld_index_index) 
18) Видалення блока в лейауті я писав так, що написав батьківський тег, а вже в ньому написав тег <remove name="блок який хочу видалити">
19) в папці skin пишуться скріпти які будуть привязані до мобулів, а общі скріпти будуть писатись в папці js
20) Далі в уроці Вова розказував як додавати скріпти, стилі.. в тег head, але я не записував, так як в другій мадженті це проісходить по ншому вроді
	- Наприклад скріпти пишуться в тезі <block> з імям head - <block type="page/html_head" name="head" as="head">
                							<action method="addJs"><script>prototype/prototype.js</script></action> - ТОбто стандарно все. Функціонал тягнеться з /lxc/modyf/app/code/core/Mage/Page/Block/Html/Head.php в якому є метод addJs, який підключить скріпт prototype/prototype.js. Це у головному файлі лейаута app/design/frontend/base/default/layout/page.xml
	- Щоб у себе у лейауті підключити скріпти, треба апдейтнути головний (або батьківський хмл) <reference name="head"><action method="adJs">
21) Також Вова розказував про цікавий функціонал лейаутів, але не пояснив толком і треба самому розбиратись. Тож у майбутньому треба передивити 
22) До речі якщо тпри виводі тексту я звертаюсь до хелпера, щоб він був коректно написаний в сенсі перекладів, то коли у самому хелпері я повертаю текст, тут все дуже круто. 
	- Так як я звже знахожусь в хелпері (при умові що він екстендиться від головного у якого є метод перекладів), то для перекладів буде досить написати return $this->__('Welcome back'); - це у файлі хелпера
23) У лейауті є функціонал, який викликає методи блока. ТАКОЖ є функціонал, який дозволяє передати метотодам блоків аргументи, які беруться взагалі з інший ф-цій. Наприклад, Вова передавав методу аргументи з хелпера, але я думаю, що можна передати будь звідки. 
	- Ситаксис був такий <block type="core/text"><action helper(думаю тут може бути не тыльки хелпер)="methodName(то що повернеться з цього метода, буде аргументом метода блока)"
24) Вова казав щоб розібратись краще в лейауах, треба хоча б подивити головний лейаут page.xml і базовий catalog.xml, розібрати що там до чого і як
25) Теги в лейауті називаються хендлами (це типу участків блоків, у які можуть загружатись темплейти або декілька темплейтів. Їх можна розширювати, це трохи схоже на екстенд в пхп). Робиться це через апдейт - <catalog_seo_sitemap translate="label"> <update handle="catalog_seo_sitemap" /> І тепер в хендлі <update handle="catalog_seo_sitemap" /> можна прописувати свої блоки і при цьому в нього буде блоки парента. Можна навіть в одному файлі даписати хендл і блоки в ньому, а під ним апдейтнути цей хендл. Помилки не буде а будуть 2 одинакові блоки. Описувати детальніше я це поки не буду, так як треба подивити урок по цьому у м2.
	- Також я помітив шо імена хендлів називаються так само як шлях до класів блоків <update handle="catalog_seo_sitemap" /> Мабуть він буде брати з нього функціонал


 ------------------------








