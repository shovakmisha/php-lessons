
1) У мадженті є функціонал, де у адмінці можна задати режим і на сторінці виведуться усі phtml-ки у тих мысцях де вони розположены на сторінці. Але це не стосується cms-блоків
	- Також э функціонал де показується клас, для цього блока (Company/Modul/Block/Folder/File)
	- Обовязково треба щоб при цьому був конкретний стор вакзаний
2) ->getсCildHtml(імя_блока_якого_мені_треба); - виведе контент дочернього блока
3) Mage_Core_Block_Abstract - базовий блок від якого наслідуються всі блоки
	- toHtml(); - метод щоб відобразити блок любого типу
4) Mage_Core_Model_Abstract - наслідуються від нього всі моделі. Вова казав що модель має наслідуватись від Mage_Core_Model_Abstract якщо вона працює з базою
5) Mage_Core_Controller_Front_Action Контролер для фронта від якого всі наслідуються
	Mage_Adminhtml_Controller_Action Контролер для адмінки від якого всі наслідуються
6) Mage_Core_Helper_Abstract - цей клас наслідують хелпери
7) toHtml() - ф-ція яка рендерить html. Вона викликається з phtml файла і вона існує, так як $this phtml це Block, а класи у папці Block наслідуються від Mage_Core_Block_Abstract у якому є ця ф-ція
	- Mage_Core_Block_Abstract викликає івент mage_block_abstract_to_thml_before до выдрисорки блока, тож перед вірисовкою, блока його можна редагувати. mage_block_abstract_to_thml_before викликається до взятьття даних з кеша
	- Також він кидає івент mage_block_abstract_to_thml_after, який викликаэться після відрисовки
8) І перед toHtml() виконужться метод beforeToHtml(), який за замовчуванням пустий ы його можна редагувати. Але зазвичай редагують сам toHtml()
8) В мадженті є декілька типыв блоків з якими я буду працювати. вони знаходяться в папці core в папці Block і їх можна буде використовувати або від них наслідуватись. Наприклад text/list мав би виводити всі дочірні блоки лейаута, а у дочірніх і не обовязково має бути вказаний клас, просто темплейт, хоча у Вови не виводилось. Виводилось тільки тоді, коли він з батьківського у phtml визвав ф-цію getChildHtml(імя блока у лейауті)
	- $this->getChildHtml('name') - це писати у phtml ТОбто у класі блока є метод getChildHtml, який виведе хтмл phtml-ки, яка вказана у лейауті
9) Та і в загальному шляхи в xml-ках у m1 вказауються скорыш за все так, що сточатку імя модуля, слеш, а потім папки вказуються не через слеш а через андерскор catalog/product_compare_sidebar
10) Коли я в папці layout створюю файл local.xml, то він буде доступний по всій темі (у другій мадженті мабуть тільки в модулі). Тобто я референснув якиїсь блок, добавив афтером щось і це буде всюди на всіх сторінках, де є блок який я переписав
11) З коробки є декілька типів блоків, і можна екстендити який мені зручно
	- Навіть не обовязково екстендити. Можна викликати його методи з хмл-ки. Наприклад Mage_Core_Block_Text має метод setText, який виводить всі свої дочірні блоки
		 <block type="core/text" name="catalog.test_name">
	            <action method="setText">
	                <text>Redd</text> виведе цей текст. Це буде як аргумент, оскільки у метода метод приймає аргумент $text, хоча Вова казав, що тег може мати любе імя
	            </action>
		  </block>
12) before="-", after="-" кидає блок в самий верх, або в самий низ
13) Перезапис содержимого блока дуже простий, просто тег <reference name="імя блока">
14) Імена у блоків не можуть бути одинакові взагалі, а от аліаси - можуть (as="name"). тож у одомому або й тому ж файлі (або у різних файлах) можуть бути блоки з одинаковим аліасом, але коли я буду викликати ф-цію getChildHtml('alias'), то блок зявиться, навіть якщо він десь у лейауті видалений, але під видаленим блоком, я написав його знов і це що я написав - покажеться. Перезаписаний блок має мати інше імя. До речі мабуть не обовязково під видаленим писати, можливо можна всюди, просто вова видаляв по нейму а не по аліасу
	- До речі якщо видалити блок а потім його перезаписувати, то вже не треба у перезаписаному вказувати клас і темплейт його, маджента памятає 
15) У m1 кожен клас який додається в модуль, треба прописувати в конфіги. Наприклад я додав у папку Block свій блок. Тож у кожфігах (etc/config), треба прописати <global(можна ы конкретно вказати арію)><block><Company_Module(не обовязково але головне щоб унікальний)><class>Company_Module_Folder_ClassNameOfBlock
16) До речі шляхи у луйауті теж не так як у другій shovak_customerinfo/customer_name (Company_Module/Folder_ClassNameOfBlock)
17) Запрос іде в контролер, це передається в лейаут, а алейаут створює блок, який в свою чергу створює модельки
	- Це в принципі і Вова підтвертив, тому що коли він хотів показати які лейаути викликаються для сторінки і вони не вивелись, від сказав, що вони не вивілись так як контролер не визвав ф-цію loadLayoyt() (це було у корневому контролері, тож якшо мій контролер не визиває цю ф-цію, її мабуть викликає батьківський контролер). У контролері папки Core, не спрацьовували ф-цїї для каталока а от у контролері каталога вже спрацьовували
18) Видалення блока в лейауті я писав так, що написав батьківський тег, а вже в ньому написав тег <remove name="блок який хочу видалити">
19) в папці skin пишуться скріпти які будуть привязані до мобулів, а общі скріпти будуть писатись в папці js
20) Далі в уроці Вова розказував як додавати скріпти, стилі.. в тег head, але я не записував, так як в другій мадженті це проісходить по ншому вроді
	- Наприклад скріпти пишуться в тезі <block> з імям head - <block type="page/html_head" name="head" as="head">
                							<action method="addJs"><script>prototype/prototype.js</script></action> - ТОбто стандарно все. Функціонал тягнеться з /lxc/modyf/app/code/core/Mage/Page/Block/Html/Head.php в якому є метод addJs, який підключить скріпт prototype/prototype.js. Це у головному файлі лейаута app/design/frontend/base/default/layout/page.xml
	- Щоб у себе у лейауті підключити скріпти, треба апдейтнути головний (або батьківський хмл) <reference name="head"><action method="adJs">
21) Також Вова розказував про цікавий функціонал лейаутів, але не пояснив толком і треба самому розбиратись. Тож у майбутньому треба передивити 
22) До речі якщо тпри виводі тексту я звертаюсь до хелпера, щоб він був коректно написаний в сенсі перекладів, то коли у самому хелпері я повертаю текст, тут все дуже круто. Так як я звже знахожусь в хелпері (при умові що він екстендиться від головного у якого є метод перекладів), то для перекладів буде досить написати return $this->__('Welcome back'); - це у файлі хелпера
23) У лейауті є функціонал, який викликає методи блока. ТАКОЖ є функціонал, який дозволяє передати метотодам блоків аргументи, які беруться взагалі з інший ф-цій. Наприклад, Вова передавав методу аргументи з хелпера, але я думаю, що можна передати будь звідки. 
	- Ситаксис був такий <block type="core/text"><action helper(думаю тут може бути не тыльки хелпер)="methodName(то що повернеться з цього метода, буде аргументом метода блока)"
24) Вова казав щоб розібратись краще в лейауах, треба хоча б подивити головний лейаут page.xml і базовий catalog.xml, розібрати що там до чого і як
25) Теги в лейауті називаються хендлами (це типу участків блоків, у які можуть загружатись темплейти або декілька темплейтів. Їх можна розширювати, це трохи схоже на екстенд в пхп). Робиться це через апдейт - <catalog_seo_sitemap translate="label"> <update handle="catalog_seo_sitemap" /> І тепер в хендлі <update handle="catalog_seo_sitemap" /> можна прописувати свої блоки і при цьому в нього буде блоки парента. Описувати детальніше я це поки не буду, так як треба подивити урок по цьому у м2.
	- Також я помітив шо імена хендлів називаються так само як шлях до класів блоків <update handle="catalog_seo_sitemap" /> Мабуть він буде брати з нього функціонал


 ------------------------
 1) У мадженты э нативний функціонал, який пропускає всі запроси через index.php Це робиться в адмінці (Вова показував), але тоді в адресній строці висвічується index.php. Це трохи не красиво, тому він відключений і на проектах міняють налаштування в htaccsess (Вова показував). Ну це я так зрозумів
	- А Ваова казав що в адмінці можна налаштувати реврайти. Якщо реврайти виключені, то index.php буде висвічуватись в адресній строці і ф-ція getUrl() буде повертати разом з адресою сайту і index.php

 1) Вова розбирав index.php
	- Якщо не має файла '/app/Mage.php', маджента перенаправить користувача на папку у якій з якої йде установка мадженти - header("Location: downloader");

 2) В index.php є провірка чи існує файл maintenance.flag Вова казав що цей на ті випадки коли сайт знаходиться у стані розробки. Типу користувач заходить на сайт, а я ставлю перевірку, якщо файл maintenance.flag існує, користувача перекине на сторінку помилки 503. Сторінки помилок знаходяться в папці errors, а цей файлик треба буде удалити після того як захочу щоб сайт работав
 
 3) Developer mode маэ проблеми з перекладами. Якщо на проді тект не добре перекладається, перше що треба перевірити чи сайт не в девелоп моді, можливо забули перевести в продакшн мод
 
 4) Одна Маджента соже крутити декілька доменів. В index.php є код /* Store or website code */ Вова точно не сказав, але мабуть зінній $mageRunCode треба буде присвоїти домени, а $mageRunCode присвоїти стори
 
 5) В файлі index.php в ф-ції run в першому блоці try можна сказати що прохотись весь цикл. В кінці і на початку цього блоку є профайлери
	- А якщо звести до мінімуму, то це строчка - self::$_app->run(... у файлі app/Mage.php $_app - Це клас Mage_Core_Model_App. Цей клас описує повне прилеженіє мадженти, через нього йде вся робота
 
 6) Автолоадер класів. Я не розумію як це так, що у мажденті загружаються xml-ки, і є автолоадер класів одночасно. Я думав маджента грузить xml і в залежності що в них, грузить класи. Але якщо тут є автолоадер, мабуть це якось комбінується. 
	- Після того як  файлі Mage.php маджента оприділилась з приорітетами кодпулів, інклюдтиться файл "Varien/Autoload.php"; запускається ф-ція register, яка назначає ф-цію autoload() - автолоадером класів. Всі загружені класи, маджента хранить у змінній(масиві) _arrLoadedClasses
	- Ну або якщо у файлі includes/config.php, розкоментовані нижні строчки, то замість стандартного автолоадера, підключиться цей, сторонній. І в ф-ції autoload() загружені класи будуть складуватись у змінну(масив) у першому кондішні - if ($this->_isIncludePathDefined) { $classFile =  COMPILER_INCLUDE_PATH . DIRECTORY_SEPARATOR . $class; }. Вова казав що ці строчки розкоментуються якщо включити в мадженті якиїсь її компілятор в адмінці. Якщо його включити, то в папці includes? зявиться папка src, в яку будуть складуватись всі файли класів. Ну не прям всі. Вова казав що можна знайти цей файл компілятор і подивити які класи він загружає
	- В автолоадері і є ця ф-ція що заміняє такі класи Module_Folder_File на шлях до цього файлу

 7) Першою строчкою у методі run(), йде виконання метода start() - Varien_Profiler::start('mage'); У цій строчці автолоадер і почне свою роботу. Varien_Profiler - це буде перший клас який він загрузить і покладе в масив свій.

 8) Далі в ф-ції run() йде код self::$_app    = new Mage_Core_Model_App(); Автоладер загружає цей клас, потім створюється обєкт з цього класу і потім присвоюється змінній $_app

 9) Далі йде виконання виконання строчки коду $_app->run(...
	- baseInit ()
		- $this->_initEnvironment() - йде базова ініціалізація ( встановлення часу, дістаються/задаються конфіги з Mage.php самі базові(вебсайт, стор, кеш))
		- $this->_config = Mage::getConfig(); - встановлюються базові конфіги з файлу Mage_Core_Model_App
		- $this->_initBaseConfig(); - Завантажуються тільки прямі чайлди xml з app/etc/.  app/etc/local.xml ( базові конфігурації наскільки я зрозумів з коду ) i app/etc/config.xml (наскільки я зрозумів з коду тут підключення до бази, редіс, шляхи до папок, мова, таймзона... Також по коду я побачив що завантажується модуль Mage_Core). Помім ці xml-ки зливаються в 1 файл. Тобто теж базова кофігурація
		- $this->_initCache($cacheInitOptions); - потім йде ініціалізація кеша. На цьому базова ініціалізація мадженти завершена!

 11) Там є строчка if ($this->_cache->processRequest()) { $this->getResponse()->sendResponse(); } - Якщо ця сторінка закешована, витягнути її з кеша. Вова сказав що можна подивити цей метод processRequest(), щоб взнати в яких випадках запрос сторінки повністю може бути витягнутий з кеша. Наскільки памятаю якщо кеш спрацьовує, то кешується вся сторінка, хоча це не точно. Я навіть не впевнений що повна сторінка кешується так як модулі і кеші повної сторінки храняться у var/cache

 12) Далі йде загрузка модулів. Якщо Сторінку не можна витягнути з кеша, йде загрузка модулів - loadModulesCache(). Потім йде перевірка чи є модулі для цієї сторінки в папці var/cache/ Якщо немає:
	- $this->_config->loadModules(); - Загружає зареєстровані модулі з папки app/etc/modules/ і теж домержуються в файл конфігів
		- $this->_loadDeclaredModules(); - саме цей метод загружає зареєстровані модулі з app/etc/modules/
	- Потім накочуються на них апдейти, інстал скріпти ( метод _initModules() ) ... Загружаються конфіги з БД. Тобто дані модулів які храняться в базі накочуються пізніше, тому вони перекриють дані з xml. Даны в базі найприорітетніші. У першій маджеті дані модуля в базі храняться в папці sql i data. sql накочуються раніше, тому дані з папки data будуть в приорітеті. На даний момент накочується sql
	- Зберігаються дані в кеш
	- $this->loadAreaPart() - Загрузка івентів.... і тд
	- $this->loadAreaPart - Загрузка стору
	- $this->loadAreaPart - Загрузка реквесту ( По хоту тут получаю адресну строку )
	- Mage_Core_Model_Resource_Setup::applyAllDataUpdates(); - накочуються data аптейти. Ввверху я писав про це. У першій маджеті дані модуля в базі храняться в папці sql i data. sql накочуються раніше, а тепер накочуються з папка data. Рызницы в цих папках як такої не має, але зазвичай у папці sql створюється таблиця або структура таблиці а в папці data дані, які заповнюють таблицю
	5) $this->getFrontController()->dispatch(); - src/app/code/core/Mage/Core/Controller/Varien/Front.php init();
 7) Фронт контролер проходиться по роутах. Наскільки я зрозумів, Фронт контроллер віддає запит кожному роуту, типу цей запрос тобі підходить? 
	- Але судячи з того що за 1 раз може загрузитись не тыльки 1 роут (бачив у Вови на відео), то можна сказати що після того як роут приймає запрос, фронт контроллер не перестає перебирати роути. Хоча не факт, так як Вова сказав що якщо я хочу добавити свій роут (а цей адресу для цього роуту може прийняти стандартний роут мадженти), то мій роут треба додавати перед нативним, інакше нативний роут його обробить. Щоб маджента обробила мій роут першим можна підписатись на івент, який виконується до роутінга - "controller_front_init_before"
	- Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH); XML_STORE_ROUTERS_PATH(web/routers) - це кусок коду в головній хмл конфігів у якій знаходяться стандартні роути <web><routers>
Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH) - ця ф-ція робить з кусків коду xml, многовимірний масив. Тож скоріш за все можна будь який кусок xml перетворити в масив по аналогії 
	- До речі у роуті я подивив як з класа що знахотиться в xml робиться обэкт - просто через new. Цілком можливо що всюди так, а не тыльки в роутах
	- Мабуть я зрозумів. Всі роути які є у мадженті задіюються і перебираються. Маджента заходить в їх код і якщо вони оброблять реквест що в адресній строці, то ок, якщо ні, то ні (типу якщо у роуті буде кондішн і адресна строка його відповідає цьому кондішну, то код піде туди, куди направляє цей роут )
8) По ходу у першій мадженті роути створюються попроще як у 2-й. Вова показував 2 стандартні роути для фронта і адмінки, які знаходяться в Mage/Core/etc.xml і виглядають вони дуже просто 
<stores>
	<default>
		<web>
			<routers>
				<admin>
				    <area>admin</area>
				    <class>Mage_Core_Controller_Varien_Router_Admin</class>
				</admin>
				<standard>
				    <area>frontend</area>
				    <class>Mage_Core_Controller_Varien_Router_Standard</class>
				</standard>
			</routers>
		<stores>
	<default>
<web>
Мабуть треба ще щось, але наскільки я зрозумів, щоб створити свій власний роут, треба скопіювати цей кусок коду у свій модуль/etc.config.xml, підставити туди свої назви, класи і написати в класі код, який буде обробляти цей роут
6) Далі виконується метод dispatch() у файлі фронтконтролера
	- Він проганяє роути, які будуть приймати запрос через метод match(). Запишу декілька ф-цій, що він робить
		- Ставить дефолтний контролер - Index. Тобто функціонал - якщо я вказав тільки назву модуля і не вказав назву котролера(або екшна), а маджента буде шукати файл Index.php тут робиться






