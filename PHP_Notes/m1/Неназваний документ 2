
1) У мадженті є функціонал, де у адмінці можна задати режим і на сторінці виведуться усі phtml-ки у тих мысцях де вони розположены на сторінці. Але це не стосується cms-блоків
	- Також э функціонал де показується клас, для цього блока (Company/Modul/Block/Folder/File)
	- Обовязково треба щоб при цьому був конкретний стор вакзаний
2) ->getсCildHtml(імя_блока_якого_мені_треба); - виведе контент дочернього блока
3) Mage_Core_Block_Abstract - базовий блок від якого наслідуються всі блоки
	- toHtml(); - метод щоб відобразити блок любого типу
4) Mage_Core_Model_Abstract - наслідуються від нього всі моделі. Вова казав що модель має наслідуватись від Mage_Core_Model_Abstract якщо вона працює з базою
5) Mage_Core_Controller_Front_Action Контролер для фронта від якого всі наслідуються
	Mage_Adminhtml_Controller_Action Контролер для адмінки від якого всі наслідуються
6) Mage_Core_Helper_Abstract - цей клас наслідують хелпери
7) toHtml() - ф-ція яка рендерить html. Вона викликається з phtml файла і вона існує, так як $this phtml це Block, а класи у папці Block наслідуються від Mage_Core_Block_Abstract у якому є ця ф-ція
	- Mage_Core_Block_Abstract викликає івент mage_block_abstract_to_thml_before до выдрисорки блока, тож перед вірисовкою, блока його можна редагувати. mage_block_abstract_to_thml_before викликається до взятьття даних з кеша
	- Також він кидає івент mage_block_abstract_to_thml_after, який викликаэться після відрисовки
8) І перед toHtml() виконужться метод beforeToHtml(), який за замовчуванням пустий ы його можна редагувати. Але зазвичай редагують сам toHtml()
8) В мадженті є декілька типыв блоків з якими я буду працювати. вони знаходяться в папці core в папці Block і їх можна буде використовувати або від них наслідуватись. 
	- Наприклад text/list мав би виводити всі дочірні блоки лейаута, хоча у Вови не виводилось. Виводилось тільки тоді, коли він з батьківського у phtml визвав ф-цію getChildHtml(імя блока у лейауті)
	- Суть цих класів блоків одна- інклюд phtml. Тобто вони кидають phtml в браузер. Тільки кожен по різному
	- $this->getChildHtml('name') - це писати у phtml ТОбто у класі блока є метод getChildHtml, який виведе хтмл phtml-ки, яка вказана у лейауті
	- <block type="page/template_links" name="top.links"/> - Добавив для разнобразія. Якщо добавлю цей блок собі на сторінку, відобразяться всі лінки сторінки у цьому блоці. Маю на увазы що типыв блоків є не 1, їх декілька і вони по різному виводять інформацію. Наприлад може виводитись тільки текст блоків
	- Назви блоків старатись давати логічні, щоб був зрозумілий контекст. Вова давав як у верстці БЕМ
9) Та і в загальному шляхи в xml-ках у m1 вказауються скорыш за все так, що сточатку імя модуля, слеш, а потім папки вказуються не через слеш а через андерскор catalog/product_compare_sidebar
10) Коли я в папці layout створюю файл local.xml, то він буде доступний по всій темі (у другій мадженті мабуть тільки в модулі). Тобто я референснув якиїсь блок, добавив афтером щось і це буде всюди на всіх сторінках, де є блок який я переписав
11) З коробки є декілька типів блоків, і можна екстендити який мені зручно
	- Навіть не обовязково екстендити. Можна викликати його методи з хмл-ки. Наприклад Mage_Core_Block_Text має метод setText, який виводить всі свої дочірні блоки
		 <block type="core/text" name="catalog.test_name">
	            <action method="setText">
	                <text>Redd</text> виведе цей текст. Це буде як аргумент, оскільки у метода метод приймає аргумент $text, хоча Вова казав, що тег може мати любе імя. Але якщо блоку присвоїний темплейт, то method="setText" може не спрацювати
	            </action>
		  </block>
12) На блок без імені не дують атрибути remove, before, after
12) before="-", after="-" кидає блок в самий верх, або в самий низ. Вова казав що вони працюють тыльки внутрі типа "text/list" так як в цьому виді темплейта блоки блоки сортуються 
13) Перезапис содержимого блока дуже простий, просто тег <reference name="імя блока"> 
	- Але - reference не заменяют блоки. Вместо этого они используются для добавления или изменения существующих блоков. Фактически они вставляют новый блок с именем блока в существующий блок, который создает неопределенное состояние для блока який я переписую (блоки должны быть однозначно названы). Тобто створюється новий блок з таким самим іменен, а оскільки 2 блоки з одинаковим іменем не можна, береться останній. Короче краще загуглити як правильно оверайдити лейаути
14) У контролері я загружаю лейаути. У m1 - це методи
	$this->loadLayout(); - Загрузка лейаутів. В середині цього метода назначаються хендли для сторінки
        $this->renderLayout();
	- Кожен з цих методів посилає якісь івенти, тож якщо мені треба буде написати код на різних етапах формування сторінки, можна буде привязатись до цих івентів



 - Є ще ода арія install, вона використовується при установці мадженти один раз
 - Итак, определив значение «helloworld» в тегах <frontName>, мы сообщим Magento, что мы хотим, чтобы система отвечала на URL-адреса в виде http://example.com/helloworld/*
 - frontName соответствует имени нашего модуля. Это условное соглашение о том, что frontNames соответствуют именам модулей, но это не является обязательным требованием. Фактически, один модуль может определять несколько <routers> и, следовательно, иметь несколько frontNames.
 - Контролери будуть знаходитись в папці controllers. У цій папці маджента буде шукати контролери. 
	- Шторм каже що до шлях до контролера будується так що береться шлях з файла config.xml Company_ModuleName Потім імя контролера Index - Company_ModuleName_Index і вкінці добавляється слово Controller - Company_ModuleName_IndexController - Це фізичний файл контролера. Суть у тому що і для котролера і до екшна перша маджента додає слова Controller і Action 
	- Екшн же це метод наскільки я зрозумів. Тому що у файлі Company_ModuleName_IndexController.php є клас з іменем Alanstormdotcom_Helloworld_IndexController і методом indexAction(), який викликається автоматом
		- Для того щоб запрацював інший метод екшна, треба його написати в адресній строці https://modyf.lxc/helloworld/index/goodbye і назвати так метод public function goodbyeAction(){...}
 - коли Маджента шукає клас(вона шукає у файлі конфігів), то спочатку дивить у глобальну арію, а потім якщо існує фронт або адмін, то вони беруться перекриваючи глобальну
 - Всі xml-ки лейаутів( їх можна назвати хендлами) вкінці обєднуються у файл local.xml, тому той код що я писав у файлі local.xml може зареврайтити будь який блок. Шторм казав що файл local.xml вкінці кінців стає файлом конфігів, але Фесько казав що local.xml накатується на файл конфігів. Тобто загрудаэться сторінка і для цієї сторінки назначаються хендли. Маджента загружає повний список усіх хендлів і при загрузці сторінки вибирає з цього списка ті, які їй потрібні

---------- Handles ------------
 - Каждый запрос страницы (при кодній загрузці сторінки) в Magento генерирует несколько уникальных Handles. Для прикладу - 
	- default - це хендл <default>. У скомбінованому файлі всіх лейаутв є штук 20 хендлів з неймом <default і зазвичай там загальні блоки (хедер, футер, загрузка скріптів, ...). Але можуть бути і сторонні блоки. Тобто якщо у модуля є хендл з <default>, то скоріш за все цей блок буде на всіх сторінках, так як хендл <default> майже завжди загружається на сторінку. Або може бути ще таке що у хендлі <default> розміщені всі блоки сторінки
	- STORE_fr_fr - стор. Саме цей запис я не побачив у скомбінованому файлі лейаутів. Мабуть у цьому й причина, що Алан Шторм скомбінував хендли лейаутів і хендл стора туди не попав
	- THEME_frontend_default_default - тема. Цей хендл теж існує, але у скомбінованому файлі лейаутів його теж не було 
	- helloworld_index_index - модуль, контролер, екшн. По ходу після того як маджента оприділила який екшн буде обробляти сторінку, вона назначає цей хендл. 
		- По ходу назва лейаута - це хендл (Ну вроді у другій мадженті так було, що якщо є назва лейаута така сама як хендл, то він брався в оборот). Але в м1 мабуть назва файлу лейаута не важлива, головне щоб у ньому був написаний хендл моєї сторінки (якщо я хочу щоб у моєї сторінки були унікальні блоки)  
		- Цей хендл огортає мою сторінку. Значить в ньому я можу писати/переназначати блоки, які я маю на сорінці (<helloworld_index_index><reference name="root">...<helloworld_index_index>)
		- Xендл можна переоприділити. Типу в мене є 2 екшни в index контролері - indexAction i goodbyeAction. Їм назначились хендли helloworld_index_index і helloworld_index_goodbye 				<helloworld_index_goodbye>
				<update handle="helloworld_index_index" /> Це я заоверайдив хендл helloworld_index_index у helloworld_index_goodbye. helloworld_index_goodbye унаслідує блоки
		        </helloworld_index_goodbye> 
		- Можна навіть написати хендл <helloworld_index_goodbye> у будь якому модулі теми і він загрузить свої блоки. і там заоверайдити його чайлди якщо треба. Маджента і так загружає всі лейаути
	- customer_logged_out - Цей хендл можна знайти у стиску скомбінованих лейаутів і він підгружає декілька блоків на сторінку. Тобто саму назву customer_logged_out не можна знайти у списоку лейаутів загружених на сторінку, можна тільки знайти блок, який відповідає цьому хендлу. Якщо користувач зареєстрований, то прийде хендл customer_logged_out. Тож у лейауті можна створити 2 хендли для зареєстрованого і незареєстрованого користувача і в них писати різні блоки і вони будуть показуватись в залежності чи користувач зареєстрований чи ні
		- Але треба памятати що і helloworld_index_goodbye і customer_logged_out це хендли. І наскільки я бачу код, то ніде не бачив щоб у хендлі був хендл. У хендлі тільки блоки. Навіть Вова коли робив функціонал у лейауті щоб для незареєстрованих користувачів (customer_logged_out) не показувався якиїсь блок, то він вставив блоки у хендл <helloworld_index_index><block ...></helloworld_index_index> а після (не в) з <helloworld_index_index> написав хендл customer_logged_out і в ньому видалив цей блок, щоб для нерареєстрованих він не показувався <customer_logged_out>
																			<remove name="block"/>
   																		  </customer_logged_in>
		- Наскільки я зрозумів, хендл у xml це якиїсь логічний участок xml у якому обєднані блоки(<block>) - <customer_logged_out></block></block></block></customer_logged_out>. Наприклад є хендл <catalog_product_view> у якому по ходу взагалы вся сторінка продукту. І мабуть при загрузці сторінки https://modyf.lxc/catalog/product/view, маджента буде шукати цей хендл і загрузить блоки з нього
	- Повторюсь. Блоки в лейауті дуже гнучкі, їх можна писати в будь якому порядку. І викликати їх можна будь якими методами. Або зробити щоб батьківський блок виводив всі дочірні, або в темплейті можна вивести дочірній блок

Контролер і блок можуть звертатись до модельки. Вюшка колизвертається - це не правильно 
	- контроллер не передает данные ни в какие блоки или макет
 - output="toHtml" - Якщо лейаут не викликав метод toHtml, то дані лейаута не виведуться
 - Кожен екшн відповідає за загрузку лейаута ( loadLayout ) і потім рендерить його
 - шТОРМ КАЖЕ що - Если совпадение найдено, производятся Action Controller и Action. Тобто фронт контролер не проходиться по всі роутах. Якщо знайде схоження ініціалізує кантролер і екшн
 - Не знаю чим це допоможе, але екшн контролер створює обєкт з лейаута, а лейаут в свою чергу створює обєкт з класа блока. Тобто то що я з phtml-ки можу витягувати дані як з обєкта, це тому що лейаут створив з нього обєкт і $this в phtml це обєкт


 catalog(handle)_product(handle)_view(handle)





 - Щоб створити лейаут файл для модуля мадженти, треба прописати його в etc/config.xml цього модуля <frontend> - не обовязково фронтенд, можна і для адмінки поміняти лейаут
													<layout>
													    <updates> 
														<shovak_customerinfo> - це не назва модуля, скорыш для зручності, головне щоб унікальне
														    <file>shovak_customerinfo.xml</file> - фізичний файл лейаута. Якщо це системний леяут то назви компанії там не має (mage(без mage)_customerinfo.xml)
														</shovak_customerinfo>
													    </updates>
													</layout>
												    </frontend>


14) Імена у блоків не можуть бути одинакові взагалі (навіть якщо я видалю блок з іменем vasya, я не можу створити новий блок з іменем vasya), а от аліаси - можуть (as="name"). тож у одомому або й тому ж файлі (або у різних файлах) можуть бути блоки з одинаковим аліасом. Перезаписаний блок має мати інше імя.
	- Якщо у темплейті є видалений(remove='true') блок name="customer_new" з аліасом new, а я створив інший блок name="customer_new2" і дав йому аліас news, то $this->getChildHtml('news') покаже содержиме блока customer_new2
	- До речі якщо видалити блок а потім його перезаписувати, то вже не треба у перезаписаному вказувати клас і темплейт його, маджента памятає
15) У m1 кожен клас який додається в модуль, треба прописувати в конфіги. Наприклад я додав у папку Block свій блок. Тож у кожфігах (etc/config), треба прописати <global(можна ы конкретно вказати арію)><block><Company_Module(не обовязково але головне щоб унікальний)><class>Company_Module_Folder_ClassNameOfBlock
16) До речі шляхи у луйауті теж не так як у другій shovak_customerinfo/customer_name (Company_Module/Folder_ClassNameOfBlock)


17) Запрос іде в контролер, це передається в лейаут, а алейаут створює блок, який в свою чергу створює модельки
	- $this->getLayout()->getUpdate()->getHandle() - це б мало вивести хендли сторінки (default, STORE_fr_fr, THEME_frontend_default_default, helloworld_index_index) 
18) Видалення блока в лейауті я писав так, що написав батьківський тег, а вже в ньому написав тег <remove name="блок який хочу видалити">
19) в папці skin пишуться скріпти які будуть привязані до мобулів, а общі скріпти будуть писатись в папці js
20) Далі в уроці Вова розказував як додавати скріпти, стилі.. в тег head, але я не записував, так як в другій мадженті це проісходить по ншому вроді
	- Наприклад скріпти пишуться в тезі <block> з імям head - <block type="page/html_head" name="head" as="head">
                							<action method="addJs"><script>prototype/prototype.js</script></action> - ТОбто стандарно все. Функціонал тягнеться з /lxc/modyf/app/code/core/Mage/Page/Block/Html/Head.php в якому є метод addJs, який підключить скріпт prototype/prototype.js. Це у головному файлі лейаута app/design/frontend/base/default/layout/page.xml
	- Щоб у себе у лейауті підключити скріпти, треба апдейтнути головний (або батьківський хмл) <reference name="head"><action method="adJs">
21) Також Вова розказував про цікавий функціонал лейаутів, але не пояснив толком і треба самому розбиратись. Тож у майбутньому треба передивити 
22) До речі якщо тпри виводі тексту я звертаюсь до хелпера, щоб він був коректно написаний в сенсі перекладів, то коли у самому хелпері я повертаю текст, тут все дуже круто. 
	- Так як я звже знахожусь в хелпері (при умові що він екстендиться від головного у якого є метод перекладів), то для перекладів буде досить написати return $this->__('Welcome back'); - це у файлі хелпера
23) У лейауті є функціонал, який викликає методи блока. ТАКОЖ є функціонал, який дозволяє передати метотодам блоків аргументи, які беруться взагалі з інший ф-цій. Наприклад, Вова передавав методу аргументи з хелпера, але я думаю, що можна передати будь звідки. 
	- Ситаксис був такий <block type="core/text"><action helper(думаю тут може бути не тыльки хелпер)="methodName(то що повернеться з цього метода, буде аргументом метода блока)"
24) Вова казав щоб розібратись краще в лейауах, треба хоча б подивити головний лейаут page.xml і базовий catalog.xml, розібрати що там до чого і як
25) Теги в лейауті називаються хендлами (це типу участків блоків, у які можуть загружатись темплейти або декілька темплейтів. Їх можна розширювати, це трохи схоже на екстенд в пхп). Робиться це через апдейт - <catalog_seo_sitemap translate="label"> <update handle="catalog_seo_sitemap" /> І тепер в хендлі <update handle="catalog_seo_sitemap" /> можна прописувати свої блоки і при цьому в нього буде блоки парента. Можна навіть в одному файлі даписати хендл і блоки в ньому, а під ним апдейтнути цей хендл. Помилки не буде а будуть 2 одинакові блоки. Описувати детальніше я це поки не буду, так як треба подивити урок по цьому у м2.
	- Також я помітив шо імена хендлів називаються так само як шлях до класів блоків <update handle="catalog_seo_sitemap" /> Мабуть він буде брати з нього функціонал


 ------------------------









 1) У мадженті є нативний функціонал, який пропускає всі запроси через index.php Це робиться в адмінці (Вова показував), але тоді в адресній строці висвічується index.php. Це трохи не красиво, тому він відключений і на проектах міняють налаштування в htaccsess (Вова показував). Ну це я так зрозумів
	- А Ваова казав що в адмінці можна налаштувати реврайти. Якщо реврайти виключені, то index.php буде висвічуватись в адресній строці і ф-ція getUrl() буде повертати разом з адресою сайту і index.php

 1) Вова розбирав index.php
	- Якщо не має файла '/app/Mage.php', маджента перенаправить користувача на папку у якій з якої йде установка мадженти - header("Location: downloader"); А якщо є то маджента інклюдить цей файл
		- У файлі /app/Mage.php у перших строчках априділяється як буде працювати автолоадер
		- Автолоадер класів. Я не розумію як це так, що у мажденті загружаються xml-ки, і є автолоадер класів одночасно. Я думав маджента грузить xml і в залежності що в них, грузить класи. Але якщо тут є автолоадер, мабуть це якось комбінується. 
		- Після того як у файлі Mage.php маджента оприділилась з приорітетами кодпулів, інклюдтиться файл "Varien/Autoload.php"; запускається ф-ція register, яка назначає ф-цію autoload() - автолоадером класів. Всі загружені класи, маджента хранить у змінній(масиві) _arrLoadedClasses
		- Ну або якщо у файлі includes/config.php, розкоментовані нижні строчки, то замість стандартного автолоадера, підключиться цей, сторонній. І в ф-ції autoload() загружені класи будуть складуватись у змінну(масив) у першому кондішні - if ($this->_isIncludePathDefined) { $classFile =  COMPILER_INCLUDE_PATH . DIRECTORY_SEPARATOR . $class; }. Вова казав що ці строчки розкоментуються якщо включити в мадженті якиїсь її компілятор в адмінці. Якщо його включити, то в папці includes? зявиться папка src, в яку будуть складуватись всі файли класів. Ну не прям всі. Вова казав що можна знайти цей файл компілятор і подивити які класи він загружає
		- В автолоадері і є ця ф-ція що заміняє такі класи Module_Folder_File на шлях до цього файлу

 2) В index.php є провірка чи існує файл maintenance.flag Вова казав що цей на ті випадки коли сайт знаходиться у стані розробки. Типу користувач заходить на сайт, а я ставлю перевірку, якщо файл maintenance.flag існує, користувача перекине на сторінку помилки 503. Сторінки помилок знаходяться в папці errors, а цей файлик треба буде удалити після того як захочу щоб сайт работав
 
 3) Developer mode маэ проблеми з перекладами. Якщо на проді тект не добре перекладається, перше що треба перевірити чи сайт не в девелоп моді, можливо забули перевести в продакшн мод
 
 4) Одна Маджента може крутити декілька доменів. В index.php є код /* Store or website code */ Вова точно не сказав, але мабуть зінній $mageRunCode треба буде присвоїти домени, а $mageRunCode присвоїти стори
 
 5) В файлі index.php запускається ф-ція run в першому блоці try цієї ф-ції можна сказати що прохотидь весь цикл Мадженти. В кінці і на початку цього блоку є профайлери
	- А якщо звести до мінімуму, то це строчка - self::$_app->run(... у файлі app/Mage.php $_app - Це клас Mage_Core_Model_App. Цей клас описує повне прилеженіє мадженти, через нього йде вся робота
 
 7) Першою строчкою у методі run(), йде виконання метода start() - Varien_Profiler::start('mage'); У цій строчці автолоадер і почне свою роботу. Varien_Profiler - це буде перший клас який він загрузить і покладе в масив свій.

 8) Далі в ф-ції run() йде код self::$_app    = new Mage_Core_Model_App(); Автоладер загружає цей клас, потім створюється обєкт з цього класу і потім присвоюється змінній $_app

 9) Далі йде виконання виконання строчки коду $_app->run(...
	- baseInit ()
		- $this->_initEnvironment() - йде базова ініціалізація ( встановлення часу, дістаються/задаються конфіги з Mage.php самі базові(вебсайт, стор, кеш))
		- $this->_config = Mage::getConfig(); - встановлюються базові конфіги з файлу Mage_Core_Model_App
			- self::$_config = new Mage_Core_Model_Config($options); - Здесь создается глобальная конфигурация Magento. и это объект, который будет использоваться для загрузки и взаимодействия с файлами конфигурации XML Magento. Тобто через цей обєкт Маджента працює з xml-ками
 			- Mage_Core_Model_App::$config i Mage::getConfig(); - будуть ссилатись на один і той же обєкт, який буде обробляти файли xml. Тобто зміни у одного повліяють на інший
		- $this->_initBaseConfig(); - Завантажуються тільки прямі чайлди xml з app/etc/.  app/etc/local.xml ( базові конфігурації наскільки я зрозумів з коду ) i app/etc/config.xml (наскільки я зрозумів з коду тут підключення до бази, редіс, шляхи до папок, мова, таймзона... Також по коду я побачив що завантажується модуль Mage_Core). Помім ці xml-ки зливаються в 1 файл. Тобто теж базова кофігурація
			- https://alanstorm.com/magento_config_tutorial/ - У цій статті Алан трохи розказував про те яким обєктом маджента обробляє хмл-ки (істоки короче). З того що я поняв у мадженті xml-ки обробляються зазвичай одним стандартним способом. Але є ще спосіб через simple xml і він трохи відрізняється. Хоча це не точно. 
			- Також Алан казав що у класі Mage_Core_Model_Config є змінна _xml у якій будуть хранитись всі хмл конфіги мадженти 
		- $this->_initCache($cacheInitOptions); - потім йде ініціалізація кеша. На цьому базова ініціалізація мадженти завершена!

 11) Там є строчка if ($this->_cache->processRequest()) { $this->getResponse()->sendResponse(); } - Якщо ця сторінка закешована, витягнути її з кеша. Вова сказав що можна подивити цей метод processRequest(), щоб взнати в яких випадках запрос сторінки повністю може бути витягнутий з кеша. Наскільки памятаю якщо кеш спрацьовує, то кешується вся сторінка, хоча це не точно. Я навіть не впевнений що повна сторінка кешується так як модулі і кеші повної сторінки храняться у var/cache. Та і наврядче це мається на увазі що саме сторінка кешується. Наскільки я бачу по коду на цьому етапі навіть не зрозуміло яку саме сторінку кешувати. Скоріш за все з кешів можна витягнути тільки базові модулі

 12) Далі йде загрузка модулів. Якщо Сторінку не можна витягнути з кеша, йде загрузка модулів - loadModulesCache(). Потім йде перевірка чи є модулі для цієї сторінки (Знову ж, наврядче що він шукає модулі саме цієї сторінки, яку я загружаю, скоріш за все маджента просто пробує витягнути всі модулі мадженти з кеша. На цьомуу єтапі не зрозуміло для якої сторінки треба модулі, так як фронтконтролер ще не був запущений) в папці var/cache/ Якщо немає:
	- $this->_config->loadModules(); - Загружає зареєстровані модулі з папки app/etc/modules/ і теж домержуються в файл конфігів
		1 $this->_loadDeclaredModules(); -производится обработка только двух типов файлов из папки etc в директории модуля: 1. config.xml 2. config.{resource_name}.xml (типу config.mysql4.xml) Масив з шляхами до цих модулів виглядає приблизно так array
			    0 => string '/path/to/magento/app/etc/modules/Mage_All.xml' (length=80)
			    1 => string '/path/to/magento/app/etc/modules/Mage_Api.xml' (length=80)
			    2 => string '/path/to/magento/app/etc/modules/Mage_Authorizenet.xml' (length=89)
		- Шторм казав що приорітети такі - Mage_All.xml найнижчий, модулі з префіксом Mage - їх вищий і найвижчий приорітет у тих у яких не має префікса Mage (тобто кастомні). Вроді з цим звязано то що коли перезаписую модуль, то вказую від якого модуля наслідуюсь - В м1 це тег <depends> (в м2 там якиїсь інший). Але в коді я просто бачив що ці для цих загружених модулів створюється багатовимірний масив з ключами 'base' 'mage' 'custom' і вони туди розприділяються
		- Потім цей асоціативний масив перебирається в циклі і збирається в 1 файл методом extend() з класу Mage_Core_Model_Config. Цим самим методом екстендились і файли config.xml local.xml у методі базової ініціалізації. На цьому етапі в мене э всі активні модулі мадженти у змінній $unsortedConfig
		- Потім Десь у цьому методі йде кондішн що якщо модуль не ативний, то з ним не будуть проводитись операції - цикл візьме інший модуль ( <active>false</active> )
		- Потім створюється багатовимірний масив залежностей для всіх модулів. 
											$moduleDepends[$moduleName] = array(
													'module'    => $moduleName,
													'depends'   => $depends,
													'active'    => ('true' === (string)$moduleNode->active ? true : false),
												    );
			- Цей масив сортується щоб накатування локальних модулів в подальшому йшов правильно. Алан в статті показував як буде виглядати масив з модулями після сортування
		- Кароче там ще э 2 цикли після яких у мене буде відсортований обєкт з модулями і залежностями модулів. Ці цикли відсортують модулі. І вже ці відсортовані модулі попадуть в головний клас конфігів (у змінну $_xml); 
		2) $this->loadModulesConfiguration(array('config.xml',$resourceConfig), $this); - загружає всі конфіги модулів з файлу config.xml. Взагалі метод loadModulesConfiguration() можна використовувати і в побутових цілях. Алан писав шо він його використав шоб подивити які роути є на сторінці. По ходу це гнучкий метод і можна вибрати які конфіги приходяти для конкретної сторінки. Але для цього йому не треба передавати 2-1 аргумент в якості обєкта конфіга. А інакше (тут я передав $this - це він і є) цей конфіг заекстендиться в головний обєкт конфігів ( у змінну $this )
			- У цьому методі перевіряється чи локальні модулі не відключені. І конфіги модулів загружаються в Mage_Core_Model_Config. Тут так само як і з etc/modules/config.xml s etc/modules/local.xml клонується змінна _prototype обєкта Mage_Core_Model_Config. Не знаю чому у різних місцях по різному зроблено. Можливо розробники були різні
			- Потім загружаються модулі(тільки модулі без залежностей) файла конфігів. Провірка чи вони активні - цікава. Якщо тег <active/> відсутній або у ньому установлено false або of - тоді модуль неактивний, інакше активний. Якщо кодпул не буде вказани в xml, модуль теж не загрузиться
			- Потім з файлом у модулі config.xml йде робота як з масивом  


				// але там у цього метода другим параметром йшов аргумент true(або фолс) і коли він був указаний то при знаходженні одинакових вузлів, новий не перетирав старий, а тут буде 					// перетирати. Так як в масиві з усіма модулями, локальні в масиві добавились останні, то і в циклі вони будуть останні і при одинакових нодах, вони перетруть старі






	- Потім накочуються на них апдейти, інстал скріпти ( метод _initModules() ) ... Загружаються конфіги з БД. Тобто дані модулів які храняться в базі накочуються пізніше, тому вони перекриють дані з xml. Даны в базі найприорітетніші. У першій маджеті дані модуля в базі храняться в папці sql i data. sql накочуються раніше, тому дані з папки data будуть в приорітеті. На даний момент накочується sql
		- $dbConf = $this->getResourceModel(); - Звертається до ресурсної модельки, Яка по ходу хранить всі дані бази про модулі 
        	- $dbConf->loadToXml($this); і загружає їх конфіги Mage_Core_Model_Config (core_config_data ця таблиця в базі)
			- $read = $this->_getReadAdapter(); - цей метод буде брати дані з бази $read->select()->from($this->getTable('core/website'), array('website_id', 'code', 'name'));
												$rowset = $read->fetchAssoc($select);
		- core_website - у цій таблиці маджента хранить стори - System -> Manage Stores
		- Потім дані з бази загружаються і файл конфігів $xmlConfig->setNode('stores/'.$s['code'].'/system/store/id', $s['store_id']); - там це є, цей кусок я для прикладу написав
							<websites>
								<admin>
								    <system>
									<website>
									    <id>0</id>
		- Потім те саме для таблиці core_store
		- Потім те саме для таблиці core_config_data (SELECT scope, scope_id, path, value FROM core_config_data;)
	- Зберігаються дані в кеш
	- $this->loadAreaPart() - Загрузка івентів.... і тд
	- $this->_initCurrentStore() - Загрузка текущого стору стору. При ініцілізації маджента вже витягнула всі стори вроді стори які є в адмінці. Тут по ходу вона назначає його в залежності від країни або таймзони, короче не знаю по чому, але після цієї ф-ції зявилась змінна стору ('fr_fr'). Наскільки я зрозумів. Ці стори є в базі (якщо є в адмінці, є і в базі)
	- $this->_initRequest() - Загрузка реквесту ( По ходу тут получаю адресну строку )
	- Mage_Core_Model_Resource_Setup::applyAllDataUpdates(); - накочуються data аптейти. Ввверху я писав про це. У першій маджеті дані модуля в базі храняться в папці sql i data. sql накочуються раніше, а тепер накочуються з папка data. Рызницы в цих папках як такої не має, але зазвичай у папці sql створюється таблиця або структура таблиці а в папці data дані, які заповнюють таблицю
	5) $this->getFrontController()->dispatch(); - src/app/code/core/Mage/Core/Controller/Varien/Front.php init();
 13) init() - Ініціліалізація Фронт контролера. Фронт контролер проходиться по роутах. Наскільки я зрозумів, Фронт контроллер віддає запит кожному роуту, типу цей запрос тобі підходить? 
	- Але судячи з того що за 1 раз може загрузитись не тыльки 1 роут (бачив у Вови на відео), то можна сказати що після того як роут приймає запрос, фронт контроллер не перестає перебирати роути. Хоча не факт, так як Вова сказав що якщо я хочу добавити свій роут (а цей адресу для цього роуту може прийняти стандартний роут мадженти), то мій роут треба додавати перед нативним, інакше нативний роут його обробить. Щоб маджента обробила мій роут першим можна підписатись на івент, який виконується до роутінга - "controller_front_init_before"
	- Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH); XML_STORE_ROUTERS_PATH(web/routers) - це кусок коду в головній хмл конфігів у якій знаходяться стандартні роути <web><routers>
Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH) - ця ф-ція робить з кусків коду xml, многовимірний масив. Тож скоріш за все можна будь який кусок xml перетворити в масив по аналогії 
	- До речі у роуті я подивив як з класа що знахотиться в xml робиться обэкт - просто через new. Цілком можливо що всюди так, а не тыльки в роутах
	- Мабуть я зрозумів. Всі роути які є у мадженті задіюються і перебираються. Маджента заходить в їх код і якщо вони оброблять реквест що в адресній строці, то ок, якщо ні, то ні (типу якщо у роуті буде кондішн і адресна строка його відповідає цьому кондішну, то код піде туди, куди направляє цей роут. Принаймні стандартиний роут повертає фолс при матчінгу, якщо адресна строка не його )
 14) По ходу у першій мадженті роути створюються попроще як у 2-й. Вова показував 2 стандартні роути для фронта і адмінки, які знаходяться в Mage/Core/etc.xml і виглядають вони дуже просто 
<stores>
	<default>
		<web>
			<routers>
				<admin>
				    <area>admin</area>
				    <class>Mage_Core_Controller_Varien_Router_Admin</class>
				</admin>
				<standard>
				    <area>frontend</area>
				    <class>Mage_Core_Controller_Varien_Router_Standard</class>
				</standard>
			</routers>
		<stores>
	<default>
<web>
Мабуть треба ще щось, але наскільки я зрозумів, щоб створити свій власний роут, треба скопіювати цей кусок коду у свій модуль/etc.config.xml, підставити туди свої назви, класи і написати в класі код, який буде обробляти цей роут
 15) Далі виконується метод dispatch() у файлі фронтконтролера
	- Він проганяє роути, які будуть приймати запрос через метод match(). Запишу декілька ф-цій, що він робить
		- Ставить дефолтний контролер - Index. Тобто функціонал - якщо я вказав тільки назву модуля і не вказав назву котролера(або екшна), а маджента буде шукати файл Index.php тут робиться
16) Матчінг - $router->match($request) - проганяє роути. 
	- Я не знаю чи це є у всіх роутів чи кожному треба добавляти, аде можливість назначати модуль, контролер, екшн дефолтні(index) public function fetchDefault() { $this->getFront()->setDefault(array(
17) В своэму роуті я можу додавати свої івенти
18) Вова розбирав роут CMS
	- Вичислив ідентифікатор - і поставив у змінну $identifier
	- Задиспатчив якиїсь свій івент
	ЦЕЙ КОД ПРОДУБЛЬОВАНИЙ З ПЕРШОГО ФАЙЛУ 
	- Береться моделька cms - $page   = Mage::getModel('cms/page'); - пробуэ загрузити сторінку через модельку (Вова казав що пробує загрузити сторінку)
		- return self::getConfig()->getModelInstance()
		- getModelInstance() - розбираю першу строчку - $this->getModelClassName($modelClass); - $modelClass виглядає як cms/page, тому перший кондышн не працює, а йду далі
			- return $this->getGroupedClassName('model', $modelClass); - Далі мова буде йти про getGroupedClassName(). Я памятаю, що при Mage::getModel('cms/page'); я не запускаю зразу автолоадер класів, а йду шукати цей клас в файлі конфігів xml, який збирає всі конфіги і збивається в 1 - 
				1) Перевіряє арію, якщо немає, вказує глобал - $groupRootNode = 'global/'.$groupType.'s'; Тут вкінці додається 's'; Ось чому тег називається <models> а не <model>
				- І ще там є строчка де назва модуля Mage пыдставляэться автоматом. Можна пройтись дебагером по цьому методу, але і я так зрозумів і Вова казав що якщо назва класу не склалась у цьому методі, то йде перевірка чи змінна класу не пуста і якшо пуста, то сформовується інший дефолтний клас. Наприклад із цього Mage::getModel('cms/page') - сформується клас mage_cms_model_page.
Короче треба подивити код з дебагером щоб ьуло понятно коли клас буде братись з модуля Mage, а коли щось інше (там просто декілька кондішнів)
			- В ітозі getGroupedClassName() поверне Modyf_Cms_Model_Page. З цього класу створиться обєкт Varien_Profiler::start('CORE::create_object_of::'.$className); Це був розжований курс про те що вираз  Mage::getModel('cms/page'); поверне обєкт з класа Modyf_Cms_Model_Page
	- Після того як він розібрався з моделькою для класу, назначається контролер
$request->setModuleName('cms') - модуль
            ->setControllerName('page') - Контролер для цієї цмс пейджі
            ->setActionName('view') - екшн для цієї цмс пейджі
            ->setParam('page_id', $pageId); - Тут по ходу будуть медіа квері з адресної строки або скоріш за все - це ідентифікатор цмс сторінки
        $request->setAlias(
            Mage_Core_Model_Url_Rewrite::REWRITE_REQUEST_PATH_ALIAS,
            $identifier
        );
	- Потім роут повернув тру. Це означає що він розпізнав юрл-ку




У стандартного роута (app/code/core/Mage/Core/Controller/Varien/Router/Standard.php) для фроонта э метод $request->getModuleName() - вын буде запрашувати імя модуля для цього роута. Хоча з адресної строки зрозуміло який модуль буде це робити, але може бути таке, що ще до виклику станддартного роута був викликаний обсервер, який змінив модуль. То тут по ходу вже візьметься цей змінений модуль
	- Вова розказував що строчка // get module name if ($request->getModuleName()) {.... getModuleName - візьме роут який підійшовю ТОбто вверху я розбирав роут цмс пейджі, і там вкінці назначався моду, класс, ... а потім повертався тру. Тру це означає що роутер підходить і він сюди підставиться 
 - У стандартному роуті(Mage_Core_Controller_Varien_Router_Standard) є - Метод collectRoutes будет проходить через объединенное дерево config.xml и искать узлы <router />. Где он ищет узлы маршрутизатора, зависит от параметра $ configArea, который передается, когда объект маршрутизатора добавляется к объекту Фронт-контроллера.
https://alanstorm.com/magento_dispatch_standard_router/
 - Потім йдуть всякі перевірки щоб подивити чи саме цей модуль буде оброблятись (Шторм їх розписував)
 --------- Потім йде вктановка контролера ------------
 - Коли вже точно вирішилось що це саме цей модуль ( Наприклад Catalog ) йде перевірка чи цей роутер існує (цикл під строчкою - Going through modules to find appropriate controller). Тобто вже всі <роутери> з файлів config.xml загрузились. Клас Mage_Core_Controller_Varien_Router_Standard має змінну $_routers у якій він хранить всі роутери що він бачить. Тепер йде перевірка чи мій роут є у цьому списку. Якщо є, йдем далі метод getRouteByFrontName() поверне мій роутер. Буде щось таке - $request->setRouteName('My_Route') реквесту присвоъвся мій роут
 - $request->setRouteName - $this->_route = $route('My_Route'); Метод setRouteName знаходиться у файлі Mage/Core/Controller/Request/Http.php
 - Потім повертаюсь у фонтконтроллер - $router = Mage::app()->getFrontController()->getRouterByRoute($route); щоб знайти <frontName> (<frontName>my_module</frontName> у файлі config.xml) для мого модуля.
	- Нагадую що я ще в циклі, який проходиться по всіх роутах що записані (навіть у модулях) у файлі config.xml. getRouterByRoute() Перевірить чи це не стандартний роут для фронта або адмінки, і назначить роутер по фронтнейму(<frontName>) - $router = $this->getRouter($routeName); return $router; Нагадую це четод getRouterByRoute у файлі /lxc/modyf/home/smile/modyf/src/app/code/core/Mage/Core/Controller/Varien/Front.php
 // Повертаюсь до метода setRouteName(); поки не знаю що тут доповнити

 - $this->_checkShouldBeSecure($request, '/'.$module.'/'.$controller.'/'.$action); - Цей кусок робить з http https
 - $controllerClassName = $this->_validateControllerClassName($realModule, $controller); - Провіряє чи є файл контролера (типу цього $this->_validateControllerClassName('Mage_Catalog', 'category');)
 - Потым йде перевірка чи є файл контролера і якщо є виконується його інклюд в код
 - Потім цей контролер ініціалізується і йде провіка чи він наслідується від instanceof Mage_Core_Controller_Front_Action;
 - Потім Контролер назначає Екшн
 - Запускається dispatch()
	-  У методі dispatch назначається арія(фронтенд, adminHtml) у методі preDispatch(). Також у методі preDispatch я вперше побачив щоб встановлювались якісь сесії і кукі
	- $this->$actionMethodName(); - тут викликається екшн контролера
 - Поотім ретурниться true; Вроді на цьому з екшнами і контролерами все закінчується.  
 

 - Якщо у мене буде пустий контролер з пустим екшном, загрузиться біла сторінку
 - Для того щобвідмалювати сторінку, використовується метод loadLayout() - Він викликається в контролері в екшні !!!!! Подивити детальніше
	- У процеcі встановлення хендлів, загружаються лейаути для блоків (xml-ки)
 - Далі лейаути рендеряться - метод renderLayout();
	- Тут вже встановлюються заголовки на сторінку в тег <head>


 getRouteByFrontName





 По цьому принципу хмл конфігів зєднується в 1 файл -
	$first = new Mage_Core_Model_Config_Base; - це стандартний  клас для обробки xml. Скоріш за все цим класом обробляються всі xml-ки, але не факт
	$first->loadString('<config>
	    <one></one>
	    <two></two>
	    <three></three>
	</config>');

	$second = new Mage_Core_Model_Config_Base;
	$second->loadString('<config>
	    <four></four>
	    <five></five>
	</config>');

	$first->extend($second); - тут будуть всі 5
echo $first->getNode()->asNiceXml() we’d get output something like this. Якщо треба детальніше подивити як вони мержаться, тут алан вкінці статті розписав - https://alanstorm.com/magento_config_tutorial/ 
	<config>
	   <one/>
	   <two/>
	   <three/>
	   <four/>
	   <five/>
	</config>

 getStoreConfig - метод щоб витягти хмл глобальних конфігурацій










