
 -------------- Алан - https://alanstorm.com/magento_config_a_critique_and_caching/ -------------

 1) Кожен новий вебсайт створює 50KB – 75KB xml в конфігах глобальної інформації (в залежності від к-сті модулів)

	- Але чим більше користувачів, тим більше зжерає памяті. Якщо 1 користувач зжирає 50KB – 75KB, то 100 користувачів , які є на сайті одночасно, зразу візьмуть 5МB – 7.5МB (Алан так писав)

 2) Кэширование глобальной конфигурации экономит не менее 60 операций чтения с диска за запрос. Кэширование - это хорошо.

 3) asXml(); - Метод який серіалізує глобальне дерево конфігів. Тобто в кешах по ходу буде строка з усіма конфігами

	- Якщо відключити кеші і написати ці 2 строчки в якомусь контролері модуля - $xml = Mage::getConfig()->getNode()->asXml();  file_put_contents('/tmp/no-cache.xml', $xml); - 'no-cache.xml' - Цей файл з строкою у якій були всі глобальні конфіги, локально важить 12MB. А якщо уявити що на сайті одночасно буде 100 користувачів, то це вже 1.2 гб памяті займе

	- Тепер з включеними кешами ціж самі 2 строчки - $xml = Mage::getConfig()->getNode()->asXml(); file_put_contents('/tmp/with-cache.xml', $xml); - файл with-cache.xml вже важить 600kb

	- Кэширование в Magento (как и в большинстве веб-фреймворков) работает как массив. То есть каждый раз, когда вы хотите кэшировать немного данных, вы (как минимум)

		- Придумайте идентификатор для части данных

		- Скажите системе кэширования сохранить этот фрагмент данных с вашим идентификатором

		- Затем, когда вы хотите загрузить что-то из кеша, вы говорите - Эй, система кеширования, дай мне часть данных, сохраненных с этим ID

 4) Розберу метод saveCache() - #File: app/code/core/Mage/Core/Model/App.php

	public function saveCache($data(масив з кешами), $id(ключ кеша, по якому можна буде дістати кеш), $tags=array()(це буде на подобу типів. Щоб обєднати кеші в по категоріям. Щоб потім проще було наприклад видалити кеші якогось типу. Наприклад стилів), $lifeTime=false (скільки часу буде хранитись кеш. Є інфа яка рідко міняється на сайті, а є інфа яка часто міняється))
	{
	    $this->_cache->save($data, $id, $tags, $lifeTime);
	    return $this;
	}

 5) Загрузка значения из кэша так же проста, как передача значения - #File: app/code/core/Mage/Core/Model/App.php - public function loadCache($id (це буде айдішка(ключ) кеша у масиві, який я хочу взяти) )


 ---------- Продовжую розбирати код, який я закінчив на минулій статті (Метод LoadDb()) -------------------
	- Нагадую що На даний момент у мене у глобальних конфігах у ноді <default> конфіги з таблиці core_config_data у яких 'scope' => 'default', у ноді <websites> у кожного вебсайта теж є конфіги з таблиці core_config_data у яких 'scope' => 'default' і також є конфіги з таблиці core_config_data у яких 'scope' => 'website' які перекривають дефолтні. І також є конфіги з таблиці core_config_data у яких 'scope' => 'stores' які перекривають дефолтні і вебсайтовські. 


 6) $this->_config->saveCache();
	
	- З того що я описав вверху, якщо я хочу записати в кеш дерево глобальних конфігів, було б логічно записати приблизно так - Mage::app()->saveCache($xml->getNode()->asXml(), 'global_config');

		- Але записуються вони не так, навіть не цим методом. Так як цей метод($this->_config->saveCache();) знаходиться у файлі src/app/code/local/Mage/Core/Model/Config.php, а не в - src/app/code/core/Mage/Core/Model/App.php

	- public function saveCache($tags=array()) ( #File: app/code/core/Mage/Core/Model/Config.php )

		- Вместо того чтобы сохранять все дерево XML под одним идентификатором кэша, Magento разбивает все глобальное дерево конфигурации на разделы. Ці розділи будуть хранитись у свойстві класа Mage_Core_Model_Config - protected $_cacheSections = array( - 
							'admin'     => 0,
							'adminhtml' => 0,
							'crontab'   => 0,
							'install'   => 0,
							'stores'    => 1,
							'websites'  => 0
						    )

		- Якщо подивити на глобальне дерево конфігів - http://joxi.ru/p27a7yxIo47Zdr, то з нього видно що майже вся основна частина, яка багато важить, храниться у нодах, які хранить змінна - $_cacheSections. Я пройшовся по всіх нодах. Єдині ноди у яких храниться нормально так інфи і вони не в змінній $_cacheSections - це <global> i <default>

	- І так починаю розбирати метод - if (!in_array(self::CACHE_TAG, $tags)) { $tags[] = self::CACHE_TAG; } - чи є self::CACHE_TAG в масиві $tags
		
		- $tags - це поки пустий масив. В ньому по ідеї мають хранитись карегорії конфігів, щось таке, по чому їх можна обєднати.

		- self::CACHE_TAG - це константа класа Mage_Core_Model_Config. const CACHE_TAG = 'CONFIG'; Тож після цього виразу буде $tags[ '0' => 'CONFIG' ];

	- $cacheLockId = $this->_getCacheLockId();

		- return $this->getCacheId().'.lock';

			- return $this->_cacheId; - На момент виконання цього коду, змінній _cacheId вже хтось присвоїв значення - 'config_global'

	- Тож тепер у змінній $cacheLockId - 'config_global.lock'

	- if ($this->_loadCache($cacheLockId) || $this->_hadCacheLock) { return $this; } - Цей кондішн тепер не спрацює, так як змінним $cacheLockId і _hadCacheLock на даний момент нічого не присвоїно, код іде далі

	- if (!empty($this->_cacheSections)) { - $_cacheSections - це масив з секціями для кеша.

		- $xml = clone $this->_xml; - клонується свойство класа Mage_Core_Model_Config _xml у якому храниться всі базові конфіги

			- foreach ($this->_cacheSections as $sectionName => $level) { - проходжусь по всіх секціях(ключах) $_cacheSections

				-  $this->_saveSectionCache($this->getCacheId(), $sectionName, $xml, $level, $tags); - цей метод робить всю роботу - зберігає конфіги в кеш










