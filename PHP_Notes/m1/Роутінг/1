
----------------------------------- Дублікат з іншого документу. Щоб було більш ясно який код виконувався в методі run -----------------------------------

- $this->_initCurrentStore() - Загрузка текущого стору стору. При ініцілізації маджента вже витягнула всі стори вроді стори які є в адмінці. Тут по ходу вона назначає його в залежності від країни або таймзони, короче не знаю по чому, але після цієї ф-ції зявилась змінна стору ('fr_fr'). Наскільки я зрозумів. Ці стори є в базі (якщо є в адмінці, є і в базі)

	- $this->_initRequest() - Загрузка реквесту ( По ходу тут получаю адресну строку )

---------------------------------------------------------------------------------------------------------------------------------------------------------
 

------------- In Depth Magento Dispatch: Top Level Routers - https://alanstorm.com/magento_dispatch_routers/ --------------

	- У минулій статті - https://alanstorm.com/magento_dispatch_routers/ - Алан розказував що є роути 2-х рівнів. нижчого рівня і вищого рівня. Роути вищого рівня будуть залежати від роутів нижчого тегом <use>. Умовно роут хелоуворд, який я створював це роут вищого рівня, який буде залежати від роути нижчого рівня Mage_Core_Controller_Varien_Router_Standard, так як у нтого в конфігах була прописана ця залежність <use>standart</use> Внизу це буде описано детальніше

 1) У базовому методі run, остання строчка йде - $this->getFrontController()->dispatch(); - тут все починається

	- Якщо йти через дебагер, то код виконується у цьому порядку. Виконується ця частина коду - $this->getFrontController()

		- if (!$this->_frontController) { $this->_initFrontController(); } - $this->_frontController ще не ініціалізована, тож виконується строчка _initFrontController();

			-  метод _initFrontController(); виконує метод init(); - $this->_frontController->init(); - І це ще до того як метод dispatch() запустився. Тобто ініціалізація стандартних роутів (Mage_Core_Controller_Varien_Router_Standard, Mage_Core_Controller_Varien_Router_Admin, ...), виконується ще до метода match(). Це важливо розуміти, так як Алан почав розбирати диспетчирезацію з метода match(), але на той момент коли метод матч запускається, метод init() вже виконався у якому виконались також методи collectRoutes() і addRouter()

				
 ---------------------
 
	- Метод init() - ініціалізує роути.

		- Mage::dispatchEvent('controller_front_init_before', array('front'=>$this)); - якщо я хочу добавити свій роут нижчого рівня, то мій роут треба додавати перед нативними, інакше нативний роут обробить запрос. Щоб маджента обробила мій роут першим можна підписатись на івент 'controller_front_init_before', добавити свій роут і дати йому значення. Але я трохи забігаю наперед. Я опишу нижче чому роут у якого сортордер менший як у дефолтних роутів виконається першим. Кароче це простий івент на який можна підписатись і поки все.

		- $routersInfo = Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH (web/routers) ) - <web><routers>  Це буде багатовимірний масив з конфігами нативних роутів мадженти - http://joxi.ru/a2XzQoki1Bb1jr . Ці нативні роути маджента взяла з глобальних конфігів

			- Це роути нижчого рівня. Від них залежать роути вищого рівня (ті шо в модулях у фалах config.xml). Роути вищого рівня будуть залежати від цих роутів нижчого рівня за допомогою тега <use>. Для прикладу у змінній  $routersInfo буде стандартний роут Mage_Core_Controller_Varien_Router_Standard який буде обробляти фронтові роути і коли я створив модуль helloworld, я прописав йому в залежностях стандартний роут - <use>standard</use> - http://joxi.ru/YmEzDoji0ywMY2

		- foreach ($routersInfo as $routerCode => $routerInfo) { - проходжусь по нативних роутах мадженти. На наний момент їх 2 (Mage_Core_Controller_Varien_Router_Standard, Mage_Core_Controller_Varien_Router_Admin), якщо якиїсь обсервер не додав якиїсь кастомний роут перед цим.

			- if (isset($routerInfo['disabled']) && $routerInfo['disabled']) { continue; } - Якщо у текущого нативного роута є тег <disabled> і якщо він true, то цикл не візьме цей нативний роут. Перейде до іншого нативного роуту

				- if (isset($routerInfo['class'])) { - Якщо у текущого роуту в циклі є тег class

					- $router = new $routerInfo['class']; - Створи з цього класу обєкт

						- if (isset($routerInfo['area'])) { $router->collectRoutes($routerInfo['area'], $routerCode); } - метод collectRoutes() я описував нижче. Щоб краще зрозуміти цей воркфлоу, краще перейти зразу до описання цього методу. Я не писав зразу тут описання цього методу, так цей файл коротка копія статті Алана і тут опис стандартного роута йде в тому самому порядку що і в Алана

						- Після того як collectRouters() відпрацював, у текущого обєкта роута у циклі свойства $this->routers i $this->modules будуть заповнені всіма роутами і всіма модулями текущої арії(фронт або бек) - http://joxi.ru/E2pEgxwu9NwX4A

						- Потім йде код $this->addRouter($routerCode, $router); - він заповнить свойство обєкта фронтконтролера $_routers - http://joxi.ru/DrlgV3efvgeZjA

							- $this->addRouter($routerCode (нода текущого роута у циклі. це роут нижчого рівня ), $router (обєкт який був створений з класу, який був у ноді <class> у ноді текущого роута у циклі. це роут нижчого рівня - $router = new $routerInfo['class']; ));

								- $router->setFront($this); - після цього у обєкті роута нижчого рівня, буде свойство _front, якому буде присвоїний обєкт фронтконтролера
        	
								- $this->_routers[$name] = $router; - У свойство _routers фронтконтролер буде складувати обєкти роутів нижчого рівня - http://joxi.ru/52agYDMf4zNe8r


	--------------------------

		- Псля того як я пройшовся циклом по стандартний роутах нижчого рівня у мене у є додані 2 роути з якими я можу працювати

			- Mage_Core_Controller_Varien_Router_Standard - стандартний (для фронта). Він знаходиться в конфігах - $routersInfo = Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH);

			- Mage_Core_Controller_Varien_Router_Admin - адмінський (для адмінки). Він знаходиться в конфігах - $routersInfo = Mage::app()->getStore()->getConfig(self::XML_STORE_ROUTERS_PATH);


		- Потім йде код який кидеє івент "controller_front_init_routers". На цей івент підписується код, який створює цмс роут нижчого рівня Mage_Cms_Controller_Router

		- І вкінці додається дефолтний роут нижчого рівня - $default = new Mage_Core_Controller_Varien_Router_Default(); $this->addRouter('default', $default);

			- З коду понятно, що дефолтний роут так як і інші роути додається. Єдине що у нього не запускається метод collectRouters() так як це йому ні до чого, і перевірок на те чи в цього роута є арія, клас, .... не має

 ------------------------------------- Метод init() завершився --------------------------------------------

  2) Алан почав з цього. #File: app/code/core/Mage/Core/Controller/Varien/Front.php - while (!$request->isDispatched() && $i++<100) { - цей код знаходиться у методі dispatch() який виконується після метода init() 

	- foreach ($this->_routers as $router) { - На цьому етапі, обєкт фронт контроллера (Mage_Core_Controller_Varien_Front) має 4 (на модіфі 6) обєкти(роутери) які можуть зайнятись роутінгом. Ці 4 обєкти знаходяться у його свойстві _routers - http://joxi.ru/l2Z46oyTwPJ5yr . Цикл буде передавати цим 4-рьом обєктам адресну строку, чи вона їм підходить. Він передає не адресну строку, а обєкт $request, але наскільки я зрозумів маджента працює з адресними строками через цей обєкт

		- Поки я більш менш зрозумів 2 рівні. Найвижчий, який вже у файлі конфіга модуля, як я створював на уроках першого модуля хелоу ворлд і нижчий рівень, це роути Mage_Core_Controller_Varien_Router_Standard (головний роут для фронта), Mage_Core_Controller_Varien_Router_Admin  (головний роут для адмінки. Роут для адмінки екстендиться від фронтового роута). Стандартний роут направляє на роути вищого рівня на форонтенді і Адмін роут відправляє на роути вищого рівня на бекенді.

		- if ($router->match($request)) { break; } - Якщо якиїсь з роутерів підходить (match() повертає тру), я виходжу з циклу foreach. З цього коду можна сказати що роутер може бути тільки 1


 ---------- In Depth Magento Dispatch: Standard Router - https://alanstorm.com/magento_dispatch_standard_router/ Опис стандартного роута --------------------------------------

 3) Запускається метод match() у стандартного роута Mage_Core_Controller_Varien_Router_Standard

	- if (!$this->_beforeModuleMatch()) { return false; } - Як я вже казав адмінський роут наслідуэться від стандартного роута. Тож у стандартному роуті можуть зустрічатись перевірки чи це точно запрос фронта. Це якраз такий випадок. На це модна поки не зважати, код піде далі. До речі у адмінського роута взагалі не має метода match(). А оскільки адмінський роун наслідується від стандартного, то і викличеться метод match() стандартного роута 

		- Але сам цей метод як вын оприділяє чи це не адмінський роут, можна передивити буде

	- $this->fetchDefault(); - установлюються дефолтні модуль контролер екшн -  'module' => 'core',
										    'controller' => 'index',
										    'action' => 'index'
										));

	- $front = $this->getFront(); - у змінній $front буде обєкт фронт контролера

	- $path = trim($request->getPathInfo(), '/'); - у змінній $path буде інфа що йде після домена - http://magento1point6rc2.dev/catalog/category/view/id/8 (catalog/category/view/id/8)

		- $request->getPathInfo() - catalog/category/view/id/8 . Тобто мені не треба діставати інфу з масивів $_GET, $_POST, маджента їх хранить у змінній $request

	-  if ($path) {
            	$p = explode('/', $path);
					$p = array (
					0 => 'catalog',
					1 => 'category',
					2 => 'view',
					3 => 'id',
					4 => '8',);
	   } else {
		$p = explode('/', $this->_getDefaultPath());

			- Але якщо після домена немає нічого (https://modyf.lxc/), маджента не буде розуміти якому контролеру направити інфу. Тому вона ставить якесь дефолтне значення  $this->_getDefaultPath()

				- protected function _getDefaultPath() {
				    return Mage::getStoreConfig('web/default/front'); - System -> Configuration -> Web -> Default Pages -> Default Web URL - http://joxi.ru/82QB5lacjoYloA
				}
	   }

		- $p = (array) 0 => string 'cms'

		- Дефолтна цмс сторінка у мадженті - це хомпейджа - CMS Index Controller

		- Але я не буду брати цмс сторінку. Візьму краще сторінку продукта - http://joxi.ru/DmB8DjGUwa0zxA


	if ($request (Mage_Core_Controller_Request_Http)->getModuleName()) { - На даний момент при нормальних умовах, я можу тільки здогадуватись який модуль буде обробляти адресну строку (якщо в адресній строці є модуль). Але це тільки здогадки. Поки ні я ні маджента цього не знає. Хоча може бути таке, що хтось через обсервер вже назначив цей модуль. Не знаю точно як це зробити але це можливо. Тут це і перевіряється. В мене ніхто нічого не переназначав, тому цей кондішн не пройде. Переходжу в else

            $module = $request->getModuleName();

        } else {

		-  if (!empty($p[0])) { $module = $p[0]; - $module = 'catalog'. http://joxi.ru/n2Yg5o1foPMK7r

		- Якщо у $p[0] пусто, візьметься дефолтне значення для модуля - System -> Configuration -> Web -> Default Pages -> Default Web URL - http://joxi.ru/82QB5lacjoYloA . Але таке дуже рідко буває
	
						    if (isset($this->_modules[$frontName])) { - більш цікаво що це за змінна _modules
							return $this->_modules[$frontName];
						    }
						    return false;}

	- if (!$module) { if (Mage::app()->getStore()->isAdmin()) {$module = 'admin'; - змінній $module не присвоїться тут admin, це можна проігнорувати

	- НА ДАНИЙ МОМЕНТ Я МАЮ ІМЯ МОДУЛЯ ЯКИЙ БУДЕ ОБРОБЛЯТИ ЗАПРОС. МОДУЛЬ Я ПОЛУЧИВ З АДРЕСНОЇ СТРОКИ

	- Тепрер я знаю імя модуля (наприклад catalog) і мені треба взнати імя кампінії для цього модуля (наприклад Mage_Catalog). це робиться тут - $modules = $this->getModuleByFrontName($module);

		- Взагалі цей метод дуже простий public function getModuleByFrontName($frontName) { ... він просто перевіряє чи у обєкта стандартного роута, у свойстві $_modules(це масив) є ключ який такий самий як аргумент $module що я передав у метод getModuleByFrontName($module) - if (isset($this->_modules[$frontName])) { return $this->_modules[$frontName]; } Якщо є, то getModuleByFrontName() поверне значення цього ключа.

		- Метод addModule() - заповнює свойство _modules у стандартному роуті

		- #File: app/code/core/Mage/Core/Controller/Varien/Router/Standard.php - public function addModule()

			- В цьому ж файлі він і викликається - $this->addModule($frontName, $modules, $routerName); У методі collectRoutes (Mage_Core_Controller_Varien_Router_Standard) .

				- $router->collectRoutes($routerInfo['area'], $routerCode); - викликається у фронтконтролері у методі init() - бере всі роути з глобальних конфігів ( collect так і переводиться з англійської як собиратель )

					- collectRoutes(<арія роута front/back>, <імя роута>) (http://joxi.ru/krDzDoEiEY1Oq2)

					- На момент виконання метода collectRoutes(), маджента загрузила 2 ноди нативних роутів (нижчого рівня) з глобальних конфігів (Mage_Core_Controller_Varien_Router_Admin Mage_Core_Controller_Varien_Router_Standard)

					- Метод collectRoutes будет проходить через объединенное дерево конфигураций и искать узлы <router />

					- Важливо памятати метод collectRoutes() викликається з фронтконтроллера, а фізично цей метод знаходиться у роутів нижчого рівня. (у обєктів класів Mage_Core_Controller_Varien_Router_Admin Mage_Core_Controller_Varien_Router_Standard)

				- Розпишу що він робить - public function collectRoutes($configArea ('frontend'), $useRouterName ('standart'))

					- Дивно що навіть коли у адресній строці сторінка каталога, і для запуску метода collectRoutes() (у фронт контролері) береться адмінський обєкт роута (у адмінському обєкті є метод collectRoutes(), фронт контролер його запускає) і коли маджента зайшла в його код , то адмінський роут в будь якому вирадку  запустить метод collectRoutes() у обєкті стандартного роута (Mage_Core_Controller_Varien_Router_Standard) . Метод collectRoutes() що знаходиться в адмінському роуті робить щось перед тим як запускати collectRoutes() у стандартному роуті, але Алан не розбирав ті строчки

						- Аргументи передасть адмінські - parent::collectRoutes($configArea (наприкдал admin), $useRouterName (наприкдал admin)); - Ця строчка є вкінці адмінського роута. Адмінський роут наслідується від Mage_Core_Controller_Varien_Router_Standard, тож парент це стандартний роут

						- У адмінському роуті у методі collectRoutes() є якісь строчки коду але я поки не знаю що вони роблять. Головне, що те що я описую як працює метод collectRoutes() у стандартному роуті, примінимий і до адмінсьгого, тільки з адмінськими аргументами.
 
 -- поїхали --
					- $routers = array();
        				- $routersConfigNode = Mage::getConfig()->getNode($configArea ('frontend/backend').'/routers'); - Тут будуть всі <routers> з файлу config.xml модулів - http://joxi.ru/KAggGLzf4WRPoA В даному випадку роути фронта (Це вже роути вищого рівня). Для прикладу так виглядає конфіг модуля Хелоуворлд - http://joxi.ru/krDzDoEiEY1jW2 який є в цьому списку 

					- if($routersConfigNode) { $routers = $routersConfigNode->children();} - візьми всіх дітей $routersConfigNode (дитячі ноди)

					- foreach ($routers as $routerName=>$routerConfig) { - цикл пробігається по всіх роутах <routers> що у файлах модулів config.xml . У даному випадку роути фронта

						- $use = (string)$routerConfig->use; - у кожного роута вищого рівня є тег use - <use>standard/admin</use> - він взазує на те який з роутів нижчого рівня буде обробляти цей роут (Mage_Core_Controller_Varien_Router_Standard  Mage_Core_Controller_Varien_Router_Standard) - http://joxi.ru/L216bOac8MRpeA

            					- if ($use == $useRouterName) { цей тег <use> у роуті вищого рівня має співпадати з іменем(<нодою>) роута нижчого рівня. Типу <use>standard/admin</use> - http://joxi.ru/5mdgM6Efkzkxar . Це типу залежності. Тобто, наприклад на даний момент у мене у змінній $routers тільки фронтові роути. цикл проходиться по них. У всіх у них в залежностях по хорошому має бути прописано - <use>standard</use>. Тоді буде понятно що це фронтовий роут вищого рівня. Тому що standart - це роут нищого рівня який обробляє фронтові роути вищого рівня. 

																	<standard>
																	    <area>frontend</area>
																	    <class>Mage_Core_Controller_Varien_Router_Standard</class>
																	</standard>

							- Якщо роутер вищого рівня буде знаходитись у арії <frontend> і в use у нього буде прописаний роут нижчого рівня не standard, то він не пройде цей кондішн ($use == $useRouterName) і не добавиться у $this->_modules. І так само з іншими роутами (admin install). Тобто все маэ співпадати

							- $modules = array((string)$routerConfig->args->module); - Сюди попаде імя модуля який написаний у тегах <module>Alanstormdotcom_Helloworld</module> у роуті вишого рівня - http://joxi.ru/EA4LvxOiwEoQwA

							- Далі йде цикл у якому розбираються про атрибути before after у текущого модуля в циклі. Для прикладу візьму роут Catalog. Серий казав що ці атрибути створюються зазвичай для політики безпеки. Типу перед тим як піти на якиїсь роут, створюється якиїсь роут, який перевіряє дані юзера і потім направляє вже на роут який треба. Дуже схоже на оверайд, але більш наближено до надстройки над роутом 

								- if ($routerConfig->args->modules) { Якщо нода роута має дитячу ноду <modules>

									- Наприклад на модіфі роут Catalog зареврайчений і має цей атрибут before. Ноду <modules> він теж має (не <module> а <modules>) у ноді <use>.  - так він виглядає (у глобальних конфігах і у зареврайченому роуті catalog - http://joxi.ru/V2VbKoXUxoWy82 . http://joxi.ru/Vm6Z71XiDpqBXm - дефолтний роут catalog).

										- foreach ($routerConfig->args->modules->children() as $customModule) { - Проходжусь циклом по всіх дітях ноди <modules> текущого роута

											- http://joxi.ru/GrqjgkwHQ5Jzem - у змінній $customModule буде текуща дитина ноди <modules> (у моєму випадку це - <modyf_catalog before="Mage_Catalog">Modyf_Catalog</modyf_catalog>). Хоча у дебагері показується тільки атрибут 'before'. А коли передавати змінну $customModule, то візьметься тільки те що в тегах. Типу з цого виразу <modyf_catalog before="Mage_Catalog">Modyf_Catalog</modyf_catalog> візьметься тільки Modyf_Catalog. Я навіть записував змінну $customModule у файл через file_put_content і у файл записалось тільки Modyf_Catalog. Не знаю як це работає

												- if ((string)$customModule) {

                           					 					- if ($before = $customModule->getAttribute('before')) - у змінній $before буде содержиме атрибута $before before="Mage_Catalog". Кароче у зареврайченому модулі Catalog, конфіги роутів виглядають так

									<routers>
									    <modyf_catalog> - Це що Серий казав. Цей роут буде надстройкою над роутом дефолтним роутом catalog. Після того як я його прописав у ноді <modules>
										<use>standard</use>
										<args>
										    <module>Modyf_Catalog</module>
										    <frontName>modyf_catalog</frontName>
										</args>
									    </modyf_catalog>
									    <catalog>
										<args>
										    <modules>
											<modyf_catalog before="Mage_Catalog">Modyf_Catalog</modyf_catalog> - цей before записався у змінну $before. На нормальну мову якшо перевести, це буде типу Modyf_Catalog before="Mage_Catalog"
										    </modules>
										</args>
									    </catalog>
									</routers>

														- $position = array_search($before, $modules); - далі йде ця строчка. Вона перевіряє чи значення змінної $before є у масиві $modules. Якщо іти по воркфлоу мадженти то це виглядає так. Маджентівські модулі ідуть у списку модулів рашіше як кастомні. Але конфіги для модулів з одинаковим іменем у глобальних конфігах одні на всіх і конфіги кастомних модулів переписали конфіги маджентівських.  Коли я додаю роут через атрибут before, то я не називаю ноду роута так само як і маджентівську ноду ( Якби назвав, то це був би оверайд і конфіги були б одинакові, але це не оверайд). Це новий роут з новою нодою <modyf_catalog>, яку я прописав в конфігах модуля Modyf_Catalog. Код, який я описував вверху поки не задіне роут <catalog>. У нього й досі у конфігах <args><module>Mage_Catalog</module><frontName>mage_catalog</frontName></args> І так як він маджентівський, то і в списку роутів він буде вище як кастомний роут, а отже і в циклі попадеться раніше. Я писав вверху що тепер розбираю маджентівський каталог. А враховучи те що я його не оверайдив, то можу сказати що тепер у циклі нативний маджентівський роут  <catalog> (маю на увазі що перший який попадеться в циклі)

														- А от ця нода вже внесе зміни в роут <catalog>. Тепер у ноді каталог буде нода <modules>. Цей кусок хмл є у конфігах модуля Modyf_Catalog
														 <catalog>
															<args>
															    <modules>
																<modyf_catalog before="Mage_Catalog">Modyf_Catalog</modyf_catalog>
															    </modules>
															</args>
														    </catalog>

														- if ($position === false) { $position = 0; } - Я розглядував код коли дебагер був на роуті <catalog>, а так як він першим попався, то $position буде 0. array_search - повертає ключ знайденого значення в масиві // ['key - 0' => 'value - Mage_Catalog']

														- array_splice($modules (['0' => 'Mage_Catalog']), 
																$position (0), 
																0, 
																(string)$customModule (це нода <modyf_catalog before="Mage_Catalog">Modyf_Catalog</modyf_catalog>, з неї візьметься значення Modyf_Catalog. Тобто $customModule == Modyf_Catalog)
																); 

														- array_splice - Удаляет часть массива и заменяет её чем-нибудь ещё. Тут я задав параметр третім аргументом 0, тож з масива $modules нічого не видалиться. 2-й аргумент вказує, у якому місці масива почнуть замінятись елементи масива . в мене він 0 ($position), тож самий перший елемент масива перемістится вправо настільки, скільки є елементів у масиві $customModule (у масиві $customModule 1 елемент, тож перший елемент масива $modules зміститься на 1 елемент вправо). Після того як ця строчка відпрацює у змінній $modules буде - ['0' => Modyf_Catalog, '1' => 'Mage_Catalog'] - http://joxi.ru/5mdgM6EfkzVqyr


$before == 'Modyf_Catalog' && $router == 'Mage_Core_Controller_Varien_Router_Standard'

------------------------

 - Поясню що це було. В ноді <modules> є нода <modyf_catalog before="Mage_Catalog">Modyf_Catalog</modyf_catalog>. Це означає роутері є нода <modules>, цикл 

-------------------------



							- $frontName = (string)$routerConfig->args->frontName; - змінній $frontName присвоюється frontName текущого модуля в циклі - http://joxi.ru/nAyv8gwUYzg7er . Правильніше було б сказати, що змінній $frontName присвоюється frontName текущого роута в циклі, але я трохи спростив щоб було понятніше. Тим паче я ще не зустрічав щоб у одного модуля було декілька фронтнеймів і навпаки. Зазвичай 1 модуль має 1 свій фронтнейм

							- $this->addModule($frontName, $modules, $routerName); (  $this->addModule('catalog', array('Mage_Catalog'), 'catalog');  )

								- $frontName - фронтнейм текущого роута (модуля) у циклі - http://joxi.ru/a2XzQoki1Y4Mer

								- $modules - я заповнював вверху. текущий модуль у циклі - $modules['0' => Mage_Core] http://joxi.ru/RmzEkMwu0eMJQr . Це я для прикладу взяв. Точніше сказати це модуль який привязаний до текущого роута який перебирається в циклі. Хоча якщо змінній $routers будуть фронтові роути , то першим скоріш і буде модуль Mage_Core, так як він іде першим у списку модулів у глобальних конфігах. Ну і якщо роут був розширений через before/after то у змінній $modules буде декілька модулів (наприклад ['0' => Modyf_Catalog, '1' => 'Mage_Catalog']. Про before/after я теж описував вверху )

								- $routerName - назва текущого роута в циклі. Це роут верхнього рівня. - <helloworld> - http://joxi.ru/L216bOac8M0oDA

								public function addModule($frontName, $moduleName, $routeName){ - http://joxi.ru/DrlgV3efvgGvjA
									$this->_modules[$frontName] = $moduleName; - Якщо роут розширений через before/after, то фронтнейму присвоїться масив з 2-ма модулями
									$this->_routes[$routeName] = $frontName; - роутернейм мабуть завжди має назву ідентичну фронтнейму.
									return $this;}

							- І ВСЕ. СВОЙСТВА КЛАСА STANDARD $this->_modules I $this->_routes ЗАПОВНИЛИСЬ МОДУЛЯМИ І РОУТЕРАМИ ВИЩОГО РІВНЯ. Важливо розуміти що метод collectRoutes() викликається ще на дуже ранньому етапі. У фронтконтроллері у методі init() 

		- $modules = $this->getModuleByFrontName($module); - Цю строчку я вже розібрав вверху. У змінній $modules будуть модулі, імя (без префікса кампанії (Mage_, Modyf_)) яких таке саме як у аргумента $module ($this->getModuleByFrontName($module);). Якщо по хорошому, то аргумент $module це не імя модуля - це фронтнейм. Я вже писав вверху, що визначаю імя модуля по адресній строці. Перше слово у адресній строці після домена (медіа квері) це і буде імя модуля. Він же фронтнейм - http://magento1point6rc2.dev/catalog(фронтнейм)/category/view/id/8

			- Метод getModuleByFrontName($module) шукає модуль(фронтнейм) у свойстві обєкта стандартного роута _modules, а як заповнюється свойство _modules я описував вище - $this->_modules[$frontName] = ['0' => Modyf_Catalog (імя модуля),]. Тобто до одного фротнейма привязаний масив модулем або модулями, які до нього належать (ці модулі і будуть обробляти запрос на цей роут) 

			- Саме імя модуля я взяв з адресної строки. А ця строчка $modules = $this->getModuleByFrontName($module (імя модуля з адресної строки)); потрібна щоб перевірити чи на цей модуль ссилається якиїсь роут вищого рівня.

		- Після того як ця строчка відработала $modules = $this->getModuleByFrontName($module); у змінній $modules буде масив з двома модулями ['0' => Modyf_Catalog, '1' => 'Mage_Catalog']

			- Далі йде ця строчка - if ($modules === false) { return false; } - Якщо у свойстві обєкта стандартного роута _modules не має фронтнейма, який тепер у адресній строці, метод match() поверне фолс

		-------------------------------------------------------------------------------------------

	
	- Далі йде строчка if (!$this->_afterModuleMatch()) { return false; } це теж звязано з тим що у стандартному обэкті перевіряються і адмінські роути. Алан каже що розпише що робить ця строчка, але потім. Поки що це можна проігнорити

	- $found = false;
        - foreach ($modules as $realModule) { - потім створюється цикл, у якому він проходиться по масиві у якому є імя модулів для текущого роута ( $modules['0' => Modyf_Catalog, '1' => 'Mage_Catalog'] )

		- $request->setRouteName($this->getRouteByFrontName($module (фронтнейм ('catalog', тому що адресна строка така - http://magento1point6rc2.dev/catalog(фронтнейм)/category/view/id/8)) ));

			- getRouteByFrontName($frontName ('catalog') )

				- return array_search($frontName, $this->_routes); - $frontName 'catalog' є у масиві з роутерами _routes. Тож метод getRouteByFrontName() поверне 'catalog'

					- $this - це обєкт стандартного роута, а заповнення його свойтва _routes я описував вверху - $this->_routes[$routeName] = $frontName; - роутернейм мабуть завжди має назву ідентичну фронтнейму. - http://joxi.ru/a2XzQoki1YWznr - У свойстві _routes, обєкт стандарт хранить всі імена роутів вищого рівня, які у глобальних конфігах знаходяться у ноді <frontend> (тобто імена всіх фронтових роутів. Імена роутів виступають як ключі масива _routes, а фронтнейми роута виступають їх значенням)

					- getRouteByFrontName() відпрацює першим

			- Потім йде виконанная setRouteName($route 'catalog'); - це метод обєкта Mage_Core_Controller_Request_Http. Там він і виконується
---------------------------------
				- у обкта $request Mage_Core_Controller_Request_Http свойству _route присвоїться імя текущого роута - 'catalog' (ну або фронтнейма точніше. Не важливо, вони і так одинакові)
---------------------------------
				- $router = Mage::app()->getFrontController()->getRouterByRoute($route); - виконується метод getRouterByRoute('catalog'); який знаходиться у обєкті фронтконтроллера

					- У методі getRouterByRoute($route) різні кондішни, у моєму випадку виконуватись буде цей - elseif ($this->getRouter('standard')->getFrontNameByRoute($routeName)) {

						- метод getRouter('standard') перевірить чи у фронтконтролера у свойстві _routers (масив з роутерами низького рівня) є роутер 'standard'. Якщо є (він є), метод поверне обєкт класа Mage_Core_Controller_Varien_Router_Standard

						- getFrontNameByRoute('catalog') - просто повертає то що я передав в аргументі ('catalog') - return $frontName;

							- кондінш пройшов, отже виконається код $router = $this->getRouter('standard'); - У змінній $router буде обєкт роутера Mage_Core_Controller_Varien_Router_Standard

					- return $router; - метод getRouterByRoute($routeName) поверне змінну $router у які знаходиться обєкт класа Mage_Core_Controller_Varien_Router_Standard

---------------------------------

	- Повертаюсь у метод setRouteName(), що знаходиться у обєкті класу Mage_Core_Controller_Request_Http

---------------------------------

				- Тож у змінній $router обєкт класа Mage_Core_Controller_Varien_Router_Standard

				- if (!$router) return $this; - ще одна перевірка, цей кондішн не пройде, код йде далі

				- $module = $router->getFrontNameByRoute($route); - Метод getFrontNameByRoute('catalog') просто повертає аргумент, який я йому передав. Тож змінній $module присвоїться 'catalog'

				- if ($module) {
	    				$this->setModuleName($module); - Це взагалі зендовський метод. Він назначить обєкту Mage_Core_Controller_Request_Http свойство _module якому буде присвоїно $module. Алан казав що це і не важливо. Внизу є метод setModuleName(), який я описав, який переназначить це свойство.

		- Тож получається що вся ця строчка $request->setRouteName($this->getRouteByFrontName($module)); і то що я описував була безполезна майже

   -------------------------

	- if ($request->getControllerName()) { - цей кондішн не пройде, йду зразу в  else . Тут так само як і з методом getModuleName() (я описував вище). Якщо є якийсь обсервер і він назначав вже якийсь контроллер, то цей кондішн пройде. Але за нормальних умов код піде виконуватись в else
                $controller = $request->getControllerName();
            } else {
		- if (!empty($p[1])) { 
			
			- $controller = $p[1]; - // У змінній $p ще й досі квері адресної строки (catalog/category/view/id/8)  $p = explode('/', $path); - Тож $controller буде 'category'

		- else { - $controller = $front->getDefault('controller'); - змінній $controller назначиться 'index' . Я вже писав вверху про метод fetchDefault(), то це він назначив ці дефолтні значення у фронтконтролера. Не буду розписувати. Там більш менш все ясно. Алан навіть казав що у фронтконтролера і до того ще могли бути дефолтні значення, хоча це не факт  

                    	 - $request->setAlias(... - була ще ця строчка, але я не знаю навіщо вона

	- далі то саме для екшна
	- if (empty($action)) { - за нормальних умов, $action пусти. цей кондішн має проходити 

               - if ($request->getActionName()) { -  - за нормальних умов, цей кондішн не мав би проходити . Йду в else

			- $action = $request->getActionName();

		- else { - $action = !empty($p[2]) ? $p[2] : $front->getDefault('action'); змінній $action присвоїться 'view' . Якщо адресній строці екшна не має, присвоїться 'index' - метод getDefault('action'); - поверне 'index'

--------------------------------------------------------------------------------------------------------------------------------------------------------------

	- $this->_checkShouldBeSecure($request, '/'.$module.'/'.$controller.'/'.$action); - Цей кусок робить з http https. Тож якщо у мене сайт по якихось причинах буде переходити на https а мав би бути на http, треба буде подивити, можливо в цьому причина

 	- $controllerClassName = $this->_validateControllerClassName($realModule, $controller);- Провіряє чи є файл контролера (типу цього $this->_validateControllerClassName('Modyf_Catalog', 'category');)

		- Зміннa $realModule - це імя текущого модуля в циклі. Нагадаю що я тепер в циклі -  foreach ($modules as $realModule) {

		- Я не буду тут розписувати кожну строчку, так як логіка навіщо цей код досить понятна. весь код нижчого рівня вже виконаний і тепер в мене вже є точні назви модуля контролера екшна. Все що тепер перевіряється іх валідація. Валідація тут дуже проста - складується шлях до цих файлів і перевіряється чи з ними можна працювати.

		- ЧЕРВОНОЮ ниткою через весь цей цикл foreach ($modules as $realModule) { йде код викидування з циклу якщо щось не так. Провірок тут куча і якщо щось не так, то зразу викидує з цього циклу і буде братись інше імя модуля.

		- модулі контролери екшни не загружаються автолоадером. Тобто немає такого що в адресній строці є catalog/category/view і маджента перетворить це атоматом у клас MyCompany_Сatalog_Category_View. Алан казав самому розбиратись чому так. Думаю це із за того, що це дуже важко реалізувати. Треба було б ставити дуже багато кондішнів і метод який би назначав адресну строку був би дуже запутаний.

			- Не було б якоїсь поступовості як тепер. А йшла б перевірка на все і зразу і була б каша. А так як тепер більш менш структуровано, елегантно і гнучко. 

			- Я і сам не розумію чому не використовується автолоадер, тому так розмито написав

		- І на Модіфі я не міг відкрити сторінку категорії, тож буду приводити в приклад сторінку продукта ($controller == 'product')

		- $controllerFileName = $this->getControllerFileName($realModule, $controller); - Тут все просто. Шукається файл контролера, який в змінній $controller. Нічого нового, єдине що можна відмітити це метод - Mage::getModuleDir('controllers' (фізична папка), 'Modyf_Catalog'); - він поверне повний шлях до папки  'controllers' в модулі 'Modyf_Catalog' - /home/smile/modyf/src/app/code/local/Modyf/Catalog/controllers

			- $controllerFileName = /home/smile/modyf/src/app/code/local/Modyf/Catalog/controllers/ProductController.php

			- if (!$this->validateControllerFileName($controllerFileName)) { return false; } - перевіряє чи до файла $controllerFileName можна достукатись

				- На модіфі не було файла $controllerFileName, тому у циклі - foreach ($modules as $realModule) { я беру інший маджентівський модуль Mage_Catalog

				- А в ядрі мадженти вже він є, тому беру його /home/smile/modyf/src/app/code/core/Mage/Catalog/controllers/ProductController.php і кладу його у змінну $controllerFileName

				---------------------------------
				- Тепер в циклі модуль з назвою Mage_Catalog
				---------------------------------

		- $controllerClassName = $this->getControllerClassName($realModule (Mage_Catalog), $controller ('product')); - складе з аргументів строку. Ця строка буде клас контролера

			- return Mage_Catalog_ProductController

		- if (!$this->_includeControllerClass($controllerFileName, $controllerClassName)) { - аргументами метода будуть клас контролера і файл у якому цей контролер. Якщо вони валідні, заінклюдиться файл контролера - include /home/smile/modyf/src/app/code/core/Mage/Catalog/controllers/ProductController.php

			- if (!class_exists($controllerClassName, false)) { - Тут перевіряється чи є цей клас . Другий аргумент false означає що не викликати цей клас (запуск __construct())

				-  if (!file_exists($controllerFileName)) { return false; } - ще раз перевіряє чи є файл у якому цей клас

				- include $controllerFileName; - інклюдиться файл з класом контролера

				- return true;

		- return $controllerClassName;

	- $controllerClassName = Mage_Catalog_ProductController

	- Єдине що я поняв з цього це треба зберігати правильний синтаксис класів, імен файлів, класів. Щоб була правильна структура і тд. Інакше у методі _validateControllerClassName() не пройде валідація контроллера. Іце обернеться або помилкою, або тим що маджента просто не помітить мій контролер і треба буде дебажити цей метод

	- if (!$controllerClassName) { continue; } - Якщо текущий контролер не пройде хоч одну з цих провірок, візьметься слідуючий модуль в циклі (якщо він є). Якщо модулі закінчились, я вийду з циклу. 

 ------------------------------------------------------------------------------------------------------------------------------------------------------------- 

	- $controllerInstance = Mage::getControllerInstance($controllerClassName, $request, $front->getResponse()); - якщо валідаіція контролера пройшла успішно, ініціалізую контроллер

		---------------------------------
		- Тепер я ще в циклі foreach ($modules as $realModule) - // $realModule == Mage_Catalog
		---------------------------------

		- $front->getResponse() - Алан не не описував. Я просто хотів показати що в getResponse() нічого сверхособливого немає. він просто відсилає якісь заголовки

			- return Mage::app()->getResponse();
				if (empty($this->_response)) {
				    $this->_response = new Mage_Core_Controller_Response_Http();
				    $this->_response->headersSentThrowsException = Mage::$headersSentThrowsException;
				    $this->_response->setHeader("Content-Type", "text/html; charset=UTF-8");
				}
				return $this->_response;

		- getControllerInstance($controllerClassName, $request, $front->getResponse()

			- return new Mage_Catalog_ProductController(обєкт Mage_Core_Controller_Request_Http, обєкт Mage_Core_Controller_Response_Http(), array()); - Тобто ініціалізація контролера це мається на увазі викликати у контролера метод __construct() і передати йому потрібні аргументи.

			- Так як у класа Mage_Catalog_ProductController немає конструктора, йду шукати у предків - Mage_Core_Controller_Varien_Action

				- public function __construct(Zend_Controller_Request_Abstract $request, Zend_Controller_Response_Abstract $response, array $invokeArgs = array())

					    {
						$this->_request = $request; - у мого контролера буде свойство _request - обєкт Mage_Core_Controller_Request_Http
						$this->_response= $response; - у мого контролера буде свойство _response - обєкт Mage_Core_Controller_Response_Http

						Mage::app()->getFrontController()->setAction($this); - Фронтконтроллер не має метод setAction(); цей код не виконується. Не розумію цю логіку. Навіщо тут викликати метод якого немає в нативній мадженті

						$this->_construct(); - це пустий метод (це не конструктор, у нього назва починається тільки з одного підчеркування _. Якщо шо то цей метод можна заестендити собі і по ідеї він буде викликатись кожен раз коли конструктор буде викликатись)
					    }

	- if (!$this->_validateControllerInstance($controllerInstance)) { continue; } - йде провіка чи він наслідується від instanceof Mage_Core_Controller_Front_Action;

		- return $controllerInstance instanceof Mage_Core_Controller_Front_Action;

	- if (!$controllerInstance->hasAction($action)) { continue; } - Перевірка якщо у мого обєкта контролера є метод екшена. Перевірка дуже проста, описувати не буду. Просто до змінної $action додається слово Action і перевіряється чи є цей метод - return $action . 'Action'; Якщо метода екшна не має, цикл візьме імя іншого модуля.

	- $found = true;

        - break; - Виходжу з цикла

----------------------------------------------------------------------------------

	- if (!$found) { - Змінна $found залишиться false, якщо жоден з модулів що пропускався по циклу вверху не дійшов до кінця. Якщо $found = true; це означає, що текущий модуль пройшов всі провірки і йому назначились контролер і екшн.

		- if ($this->_noRouteShouldBeApplied()) { - у станддарного роутера цей кондішн не пройде так як метод _noRouteShouldBeApplied() поверне фолс.

		- return false; - і в ітозі метод match() стандартного роута поверне фолс і фронтконтроллер візьме інший роутер

		- Алан каже що ці строчки коду більш для адмін роутера

	- // set values only after all the checks are done - Після того як модуль контроллер екшн пройшли всі провірки і я маю їх назви, тепер назначаю обєкту $request (Mage_Core_Controller_Request_Http) свойства у яких будуть хранитись ці дані. Нагадаю що у аресній строці в мене - catalog/product/view/id/127205

------------------------

		- Нагадаю що крім ініціалізації обєкта контроллера (описував вверху), з функціоналу код нічого не робив. Просто брались дані з адресної строки, і йшли перевірки чи модуль контроллер екшн підходять. Якщо контроллер екшн не підходять, то замість них ставились 'index'. Тобто нічого не назначалось, тільки примірялось чи підходить все.

-----------------------

	- $request->setModuleName($module); - Я вже описував вверху про то що зендівський метод setModuleName() установлював імя модуля модуля у обєкті $request, але цей код його перезапише. В принципі те дублікат того коду, так як метод setModuleName() який я тепер викликаю той же самий зендівський метод. 

		- public function setModuleName('catalog') { $this->_module = 'catalog'; ( Mage_Core_Controller_Request_Http->_module = 'catalog'; )

	- $request->setControllerName($controller); - зендівський метод

		- public function setControllerName('product') { $this->_controller = product; ( Mage_Core_Controller_Request_Http->_controller = 'product'; )

	- $request->setActionName($action); - зендівський метод

		- public function setActionName('view') { $this->_action = 'view'; ( Mage_Core_Controller_Request_Http->_action = 'view'; )

		- if (null === $value) { $this->setParam($this->getActionKey(), $value); } - я не знаю навіщо цей код і при яких умовах на цьому етапі екшн може бути пустий. Впевнений що дуже рідко

	- $request->setControllerModule($realModule); - $realModule - це імя модуля на якому завершився цикл. Це вже модуль який пройшов провірки і його контролер і екшн теж

		- public function setControllerModule('Mage_Catalog') { $this->_controllerModule = 'Mage_Catalog'; ( Mage_Core_Controller_Request_Http->_controllerModule = 'Mage_Catalog'; )

	- Розбираю оставшуся часть адресної строки - id/127205 == id = 127205 . Ці дані теж присвоюються обєкту $request ($request->setParam('id', 127205)

		for ($i = 3, $l = sizeof($p); $i < $l; $i += 2) {
		    $request->setParam($p[$i], isset($p[$i+1]) ? urldecode($p[$i+1]) : ''); urldecode - Декодирование URL-кодированной строки
		}

 ---------------------------------------- Dispatch Time! ----------------------------------

	- $request->setDispatched(true); - Просто установлює обєкту $request свойство _dispatched = true. І як я писавв вверху, у контроллера теж є свойство у якому храниться обєкт $request. А враховуючи що це обєкт, то якщо я поміняю з контролера свойство _dispatched, то воно поміняється і в обєкті $request

	- $controllerInstance->dispatch($action); - це вже загрузка сторінки, наскільки я зрозумів. Алан нічого про це не писав


 --------------- Все. задіспатчилось. Виходжу з циклу - while (!$request->isDispatched() && $i++ < 100) {













------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Метод match() завершений. Він повернув true. Змінна $found = true; 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	

			

		 	

	




- in_array("Mage_Catalog", $modules);




	

	
