 - Якщо існує ф-ція з словом 'set', мала б бути ф-ція з словом 'get'.
1. Switch робит так само, як і в java-script
2. post_max_size - задає максимальний розмір, який може передати форма (По ходу методом POST)
3. ini_get — Получает значение настройки конфигурации // string ini_get ( string $varname )
	- В случае успеха возвращает значение настройки конфигурации.
4. Ф-ція strtoupper(); Приводить строку у верхній регістр.
	- Ф-ція strtolower(); Приводить строку у нижній регістр.
--------------------- Масиви ---------------------------
5. array[] = something; - something стане в кінець масива. Так буде завжди, коли у квадратних дужках пусто 
6. Ф-ція count(); - Рахує к-сть елементів масива або к-сть свойств об’єкта
7. Ф-ція print_r(); - Виведе елементи масива у форматі [індекс] => елемент. Якщо взяти це у теги <pre>, кожен елемент буде починатись з нового рядка. Але є декілька недоліків
	- Тип boolean виводить як 1/0;
	- Незрозуміло який тип у елемента з цифер. Не каже чи це integer, чи string;
	- Не каже, скільки елементів у масиві.
8. Ф-ція var_dump(); - Схожа на ф-цію print_r();, але всі її недоліки виправлені. // array(5){ [0] => string(4) "John" [1] => string(4) "root"}
9. Індекси(ключі) не вліяють на к-сь елементів у масиві. Тобто якщо у масиві є 3 елементи, а я добавлю туди елемент з індексом 100, це не означає, що у масиві буде 100 елементів. У масиві буде 4 елементи і 4-й буде з індексом 100. Не буде як у java-script 96 underfinde між елементами.
	- Індекси(ключі) не вліяють на порядок елементів у масиві. // $arr = [7 => "petya", 2 => "5678]; - Першим у масиві буде елемент з ключом - 7
	- Якщо кинути ще 1 в кінець, то у нього буде індекс на 1 більший, за найбільший індекс у масиві // $arr[] = 'lalala';
	- масив може бути і асоціативний і індексований зразу.
10. Ф-ція unset(); - видалить елемент масива // unset($arr[2]); - видалить 2-й елемент
11. Якщо я присвоїв елементу свойство, то по індексу я вже не можу до нього звернутися, бо елемент може бути або асоціативний, або індексірований.
12. Починаючи з PHP 4 можна писати масиви і так 
	- $arr1 = ["vasya", "1234"];
	- $arr2 = ["login" => "petya", "pass" => "5678];
13. По масиву можна бродити. По умолчанию внутрішній счетчик масива указує на 1-й елемент.
	- Ф-ція current(); - поверне елемент, на який указує счетчик // current($array);
	- Ф-ція next(); - Передвигає внутрішній указатель масива на одну позицію вперед. Тепер ф-ція current() покаже слідуючий елемент.
	- Ф-ція prev(); - Передвигає внутрішній указатель масива на одну позицію назад
	- Ф-ція end(); - Устанавлеваєм внутренний указатель масива на его послений елемент.
	- Ф-ція reset(); - Устанавлеваєм внутренний указатель масива на его первый елемент.
	- Ф-ція key(); - Получаєм ключ(індекс) текущего елемента
 - По ходу до елемента масива мош обратитися без лапок $user[name]; Аж узяти name у лапки, буде помилка. Хіба взяти весь запис у фігурні дужки {$user['name']}; - Спеціаліст все це робив у строці - "echo {$user['name']};"
- У асоціативному масиві, ключ(не строку) бажано брати у лапки, бо PHP може подумати, що це константа, хоча зазвичай він переробляє запис в строку. у цьому записі $user[name] - не підставиться константа, бо константу можна тільки конкатиніровати.
14. ++(--) y PHP діє так само, як у java-script. $a = 1; echo 5 . $a++, спочатку виведеться 51, а потім вже $a збільшиться на 1.
15. Цикли такі самі, як у java-script.
	- Щоб вийти з текущого цикла, замість break можна написати break 1, з родительського break 2 і т.д. Так само з cintinue
	- У циклі for можна писати декілька записів у одному виразі // for(var i = 0, j = 3; i < 9, lalala; echo i++, 100--)
 - як би там не було strlen теж ф-ція і вона бере ресерси. Тож коли в циклі її писати, вона кожного разу викликається. І взагалі це стосується всякого такого подібного
