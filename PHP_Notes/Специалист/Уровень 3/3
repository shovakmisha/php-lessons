
 3) RPC (Remote Procedure Control) - Виклик якихось процедур (ф-цій, методів, ...) з іншого сервера. Це ідея, абстакція або задумка. А вже реалізація цього проходить через різні способи (XML-RPC, soap, ..)

	- Спеціаліст описував це, як - текстовий(або інший. Наприклад бінарний) протокол на базі HTTP (не обовязково HTTP)

 2) До прикладу запишу сервіси з якими я працюю 

	- XML-RPC - текстовий протокол на базі HTTP (RFC-3529) - він був раніше як SOAP

	- SOAP - текстовий протокол на базі HTTP (RFC-4227)

 3) SOAP - Запроси посилаютьчя через HTTP, методом POST. Обмін даними йде через xml строку.

	- Структура SOAP повідомлення

		- Envelop

		- Header - хедера може і не бути
		
		- Body - У боді я буду просити то що мені треба (ф-ції, методи, ...).

 4) Пример SOAP-запроса на сервер интернет-магазина:

	<?xml version="1.0" encoding="utf-8"?>
	<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" - Envelope (конверт). У ньому буде структура запроса.
			xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
			xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"> - xmlns:xsi, xmlns:xsd, xmlns:soap - це типу як давно в хтмл документі писалась лінка на стандарт W3C
	   <soap:Body>
	     <getProductDetails xmlns="http://warehouse.example.com/ws"> - це імя метода, який я буду просити (викликати) на іншому сервері (імя удальонної процедури). 
	       <productID>12345</productID> - ці параметри передадуться як аргументи метода getProductDetails. Тобто метод(процедура) getProductDetails, прийме аргументи productID
	     </getProductDetails>
	   </soap:Body>
	</soap:Envelope>

 5) Пример ответа:

	<?xml version="1.0" encoding="utf-8"?>
	<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
	   <soap:Body>
	     <getProductDetailsResponse xmlns="http://warehouse.example.com/ws">
	       <getProductDetailsResult>
		 <productID>12345</productID>
		 <productName>Стакан граненый</productName>
		 <description>Стакан граненый. 250 мл.</description>
		 <price>9.95</price>
		 <currency>
		     <code>840</code>
		     <alpha3>USD</alpha3>
		     <sign>$</sign>
		     <name>US dollar</name>
		     <accuracy>2</accuracy>
		 </currency>
		 <inStock>true</inStock>
	       </getProductDetailsResult>
	     </getProductDetailsResponse>
	   </soap:Body>
	</soap:Envelope>

 6) Для работы с SOAP треба підключити модуль пхп php_soap.dll. Це він якраз і переробляє мій синтаксис запроса php у xml строку

 7) Але ці приклади запроса ответа що я писав у пунктах 4 5, мені не треба буде писати. Це приклад того, як соап буде його розбирати і передадвати. Справа у тому що дані між клієнтом і сервером мають передаватись через xml. Мені буде писати набагато легший синтаксис

 8) Трохи опишу то, що відбувається на сервері у якого я буду просити дані. Спеціаліст там мав 2 файли - wsdl і php. 

	- wsdl((англ. Web Services Description Language) — язык описания веб-сервисов и доступа к ним, основанный на языке XML) - це обовязковий файл для soap. Це частина договоренності soap. У цьому файлі буде опис того, що в мене є в php файлі.

		- ТОбто я створив наприклад php файл з методами, якы будуть повертати якісь дані. То що буде в цьому php файлі і як звідти брати/передавати дані, буде описано в wsdl файлі

	- php файл - це не є обовязковим розширенням для файлу. Тут може бути все що хочу (java, java-script, pyton, ...). Тож получається SOAP, ну або інші RPC, це договоренності, як клієнт і сервер мають передавати або забирати дані з файла wsdl(ну або іншого, якщо це не SOAP. Думаю wsdl файл буде тільки в SOAP, у інших якиїсь інший)

		- Цей php файл це мій Веб-сервіс. Так як він працює з wsdl файлом, який універсальних для всіх мов, то тут теж треба бути уважним, як писати мій сервіс. Точно не буду описувати правила, але в принціипі розумію про що йде мова (повертання методами типів, помилки, ...)

 9) Важливо розуміти як воно працює. Наприклад я(клієнт), находжусь на своєму сервері і прошу дані у іншого сервера. Посилаю йому запрос і кажу яку процедуру(метод) виконати. Сервер посилає запрос на php s php виконує код. Якщо щось не вдалось, то php відправить помилку на сервер на якому він знаходиться, а не моєму. Щоб він відправив моєму серверу помилку, у SOAP є свої методи для роботи з помилками

 10) При передаванні хмл-ок, дані жостко кешуються. Тому під час розробки, треба відключити кеш, щоб соап не кешував дані - ini_set("soap.wsdl_cache_enabled", "0");

 11) // Создание SOAP-сервер - $server = new SoapServer("http://mysite.local/demo/soap/stock.wsdl"); тут я підключаюсь до сервера, який буде принімати/передавати дані у виді хмл строки. Хоча опис веб-сервіса(wsdl файл) знаходиться на тому ж сервері і можна б було написати відносний шлях до wsdl файлу, суть у тому, що вони можуть знаходитись на різних серверах

	- По великому рахунку, задача цього файлу http://mysite.local/demo/soap/stock.wsdl - це вказати серверу, який пхп скріпт запустити і прийняти дані, які віддасть метод скріпта. Потім повернути ці дані клієнту. Все! Йому навіть не треба знати на яких мовах методи написані. Методи запускає сервер, а не wsdl

		- Задача SOAP, щоб пхп файл міг працювати з файлом wsdl. Як бачу SOAP це обєкт і з даними я працюю через методи цього обєкта.

	- Потім я буду описувати як читати цей wsdl файл. У ньому я пропишу адресу до мого Веб-сервіса(php файл). Тобто клієнту, який буде простити дані, не треба знати, де знаходиться фізично мій веб-сервіс або на якій мові написаний веб-сервіс, йому досить вказати шлях до wsdl файлу і все.

 12) addFunction() - добавити ф-ції, з якими буде працювати SOAP-сервер. Якщо ф-цію не додати, клієнт не буде її бачити

	// Создание SOAP-сервер - $server = new SoapServer("http://mysite.local/demo/soap/stock.wsdl");
	// Добавить класс к серверу - $server->addFunction("getStock"); - getStock() - це назва метода.

		- Якщо треба додати декілька методів, то треба написати імя цих методів у масиві і передати цей масив, як аргумент метода addFunction($arr)

		- Якщо мій сервіс буде класом, у якому будкть методи, то по суті нічого міняти не треба. Просто замість $server->addFunction, треба буде написати $server->addClass. А методи цього класу будуть доступні

 13) $server->handle(); - Запуск сервера. Тобто з клієнта я передаю метод getStock, який має виконуватись на сервері у wsdl файл. У wsdl файлі я маю шлях до файлу, який має запуститись і метод, який має запуститись у цьому файлі. Щоб скріпт у цьому файлі почав працювати і є ця ф-ція $server->handle();


 14) wsdl - описую те, як працювати з моїм сервісом.

	- <?xml version ='1.0' encoding ='UTF-8' ?>  - перша строчка xml файлу

	- <definitions - це як !doctyte раніше був в хтмл. у цій ноді буде описано но яких стандартах писати у цьому файлі і лінки на ці стандарти.
		name='Stock' 
		targetNamespace='http://localhost/soap'  - Тут я вказував шлях до папки, у якій знходиться мій wsdl файл - http://stock.on/php3/demo/soap/stock.wsdl - http://joxi.ru/82QB5lacjexl6A
		xmlns:tns='http://localhost/soap' - Тут я вказував шлях до папки, у якій знходиться мій wsdl файл - http://stock.on/php3/demo/soap/stock.wsdl - http://joxi.ru/82QB5lacjexl6A
		xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/' 
		xmlns:xsd='http://www.w3.org/2001/XMLSchema' 
		xmlns:soapenc='http://schemas.xmlsoap.org/soap/encoding/' 
		xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/' 
		xmlns='http://schemas.xmlsoap.org/wsdl/'> 

	- Вивчати цей файл легше знизу вверх

		<message name='getStockRequest'> - До атрибуту namе, привязується нода input/output . Щоб було ясно який тип даних приймається/віддається.
			<part name='id' type='xsd:string'/>  - Атрибут name довільний. Не обовязково, щоб у методі getStock() був аргумент з іменем id, агрумент може мати імя будь-яке. атрибут type - це тип даних. Тип даних може бути будь-який, навіть бінарний
		</message> 
		<message name='getStockResponse'> 
			<part name='Result' type='xsd:integer'/> - Атрибут name довільний. Не обовязково, щоб у методі getStock() був аргумент з іменем id, агрумент може мати імя будь-яке. атрибут type - це тип даних. Тип даних може бути будь-який, навіть бінарний

			- Ліричний відступ. Мабуть поняття типів відновиться до всіх мов програмування. Інакше чому б інакше тут вказувався тип даних і при цьому сказано що дані можуть приходити з сервісів які написані на будь-яких мовах. А то що хмл може приймати будь які типи, це теж описано в його документації, як і в будь-якій іншій мові програмування.

			- Спеціаліст каже, що якщо мені треба описати якиїсь новий тип даних, то це треба вказати в xsd(у ньому є правила по яких написаний файл xml) файлі. Але як це зробити, він не казав. Бачив выдос на ютубі, скоріш новий тип добавляється так - http://joxi.ru/bmoEVXwuxBzdqA (нода types. Чувак казав що у ноді type знаходиться xsd)

		</message> 

		<portType - Опис моїх операції(методів). Тобто які типи даних будуть передаватись методам, які пити буде повертати мій метод
			name='StockPortType'> - до атрибута name привязується нода binding, атрибутом type
			<operation name='getStock'> 
				<input message='tns:getStockRequest'/> - що буде приймати метод. Опис типу даних буде у ноді <message> у ноді <part>. Нода <message> буде мати атрибут name"getStockRequest"
				<output message='tns:getStockResponse'/> - що буде віддавати метод. Опис типу даних буде у ноді <message> у ноді <part>. Нода <message> буде мати атрибут name"getStockResponse"
			</operation> 
		</portType> 

		<binding - Тут я вказую доступні операції(методи або процедури) на моєму Веб-сервісі
			name='StockBinding' - До цього імені привязується Веб-сервіс
			type='tns:StockPortType'> - Тут буде вказуватись тип моїх операцій (їх опис). Описуються вони у ноді portType, у неї є атрибут нейм StockPortType, до нього я і привязуюсь
			<soap:binding style='rpc' transport='http://schemas.xmlsoap.org/soap/http'/> - Це по ходу якась стандартна тема, яку реба копіпастити.
			<operation name='getStock' /> - Назва операції. Якщо у мого сервіса буде декілька доступних операцій, то їх треба буде добавити сюди
			<operation name='getNewStock' /> - Це я добавив для прикладу, щоб показати як додається нова операція, яка буде доступна клієнту 
		</binding> 

		<service name='StockService'>  Значення атрибута name може бути довільне. Це назва мого Веб-сервіса
			<port 
				name='StockPort' - Назва порта теж скоріш за все довільна, але скоріш за все має бути унікальна
				binding='StockBinding'> - Вказую, які процедури буде мати цей сервіс. Ввверху є нода <binding> з неймом StockBinding. То це я всказав що я до неъ привязався.

				<soap:address location='http://mysite.local/demo/soap/server.php'/> - Шлях до файлу Веб-сервіса
			</port> 
		</service> 
	</definitions>

 -----------------------------------------------------

 15) SOAP на стороні клієнта (SOAP-клієнт). 
	
	// Создание SOAP-клиента - $client = new SoapClient("http://stock.on/php3/demo/soap/stock.wsdl");

		- І всі методи що дає сервіс, до якого я підключений, будуть у обєкта $client

		- $client->__getFunctions() поверрне всі доступні процедури.

---------------------------------------------------------------------------- Сокети ------------------------------------------------------------------------------


 1) Коли я просто выдкриваю файл, я теж зєднують з ним по якомусь протоколу (http, ftp, ...)

	- Наприклад я пишу - fopen('text.txt'); Я можу і конкретно вказати по якому протоколу буде йти зєднання. fopen('http://text.txt'); fopen('ftp://text.txt');

		- Якщо я не вказую, то автоматом підставляється file - fopen('file://text.txt');

 // Сокетное соединение
	// Создаем сокет (host+порт)
	$socket = fsockopen("mysite.local", 80 (порт), $sock_errno (якщо буде помилка, тут буде її номер), $sock_errmsg (якщо буде помилка, тут буде її меседж), 30 (скільки часу максимум можу просити дані. Це щоб не просити дані вічно. ) );

		- Якщо запрос не пройде, у $socket буде false ( if(!$socket){ echo $sock_errmsg; } )

 1) // Создаем POST-строку - $str_query = "name=John&age=25";

	// Посылка HTTP-запроса у файл dummy.php методом POST
		$out = "POST /demo/socket/dummy.php HTTP/1.1\r\n";
		$out .= "Host: mysite.local\r\n"; 
		$out .= "Content-Type: application/x-www-form-urlencoded\r\n"; // Справа у тому, що масив пост заповнюється тільки тоді, коли дані приходять з форми. Цей заголовок якраз і вказує на те що дані йдуть з форми (<form method="POST">. Кароче треба подивити, який заголовок відсилає форма. Вроді крім application/x-www-form-urlencoded є ще якиїсь тип)
		$out .= "Content-length: " . strlen($str_query). "\r\n\r\n"; ("\r\n\r\n" - кінець запроса) // Якщо не має Content-length, то дані взагалі не пошлються. Але від цього залежить тільки посилання самих даних ($str_query), це для них. Заголовки на сервер, пошлються в будь-якому випадку.

		$out .= $str_query; // name=John&age=25 - ці дані передадуться методом пост

------------------------------------
 - Це що я досі написав, це так работає ф-ція fopen()

 	- Тобто, я записую дані у файл зазвичай так, відкриваю файл і потім записую туди дані - $fp = fopen('data.txt', 'w'); fwrite($fp, '1'); // содержимое 'data.txt' теперь 1! 

		- А тепер я можу записати дані у файл так - fwrite($socket, $out); - Тобто $socket те саме що $fp
------------------------------------

	// Получаем и выводим ответ
	while (!feof($socket)) {
		echo fgets($socket, 4096);	
	}

	// Закрытие соединения
	fclose($socket);

 - Спеціаліст посилав дані з одного файла у інший методом пост. Зазвичай методом пост можна посилати тільки через форму. Але якщо вказати правильні заголовки, то можна і вручну послати дані (вказавши ті заголовки, які посилає форма)

	- Файл у який я посилав дані, відпрацьовував (умовно виводив echo) і то що він відпрацював, я мав у файлі, з якого я посилав реквест методом пост. Маю на увазі, що можна не тільки брати готовий текст з файлу, можна, щоб у файлі відпрацював якиїсь скріп і поветртав дані, які будуть залежати від того що я відправив 

 - Ось це вже я не дуже зрозумів. Спеціаліст каже, що ф-ція fwrite($socket, $out); не запише дані у файл dummy.php, а просто створить поток між двома серверами. Типу нативна ф-ція fwrite просто запише дані у файл, а коли я передав їй аргументом цей $socket з заголовками, то він кастомізірував її, і фона вже не записує дані у файл, а просто дає запрос на файл і скріпт у тому файлі відпрацьовує

	- fwrite($socket, $out); - про заголовки. Після цього запису, дані про заголовки, які я посилаю будуть у змінній $socket навіть якщо я не напишу заголовки Content-Type і Content-length

	- У пхп э методи по яких можна витягнути порт, домен, імя сервера, ... Але треба знати до чого привязатись, типу grtHostByAddr("треба знати айпішку")

	- Подивити ще про сокети - https://www.youtube.com/watch?v=m14Mag7r0zk

	-------------------------------------------------------------------------------










 

 

