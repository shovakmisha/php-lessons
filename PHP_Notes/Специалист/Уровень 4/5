
 ------------------------------ cURL ------------------------------

 1) $curl = curl_init(); - ініціалізую зєднання з іншим сервером. Взагалі, можна у дужки прописати адресу. Але наскільки я зрозумів, тоді не буде так гнучко

 2) curl_setopt($curl, CURLOPT_URL, "http://stock.on/php4/demo/curl/test.php"); - взказую з яким сервером зєднуюсь і як. CURLOPT_URL - це константа. Від цього залежить як буде працювати ф-ція curl_exec

	- CURLOPT_URL - просто відпрацює скріпт з іншого сервера. Тобто якщо там буде echo "<h1>Hello, cURL!</h1>"; - то і на сторінці, на якій я пишу КУРЛ, виведеться "<h1>Hello, cURL!</h1>"

	- CURLOPT_RETURNTRANSFER - Поверне в змінну дані, які відпрацювали на іншому сервері. curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); Єдине що дивно, це то що спеціаліст не написав що можна просто повернути дані. у ного початку відпрацював ця строка curl_setopt($curl, CURLOPT_URL, "http://stock.on/php4/demo/curl/test.php"); а потім ця curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); і дані не вивелись, а збереглись у змінну $result = curl_exec($curl); 

		- Наскільки я зрозумів - $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, "http://stock.on/php4/demo/curl/test.php"); - це 2 головні строчки для зєднання файла з сервером, всі інші, що я далі буду писати, це вже накочування функціоналу на це зєднання, типу шо робити з цими даними

			- Хоча не факт. Треба провірити

		- curl_close($curl); - Потім я закрив зєднання. 

		- print $result; - і вивів дані з іншого сервера. Але у цьому випадку виводиться тільки тіло відповіді від сервера. Спеціаліст каже, що КУРЛ, це ті ж самі сокети, іншими словами спрощена обертка. Наскільки памятаю, сокети повертали і заголовки відповіді від сервера. Через КУРЛ теж можна подивити, які заголовки посилаються на інший сервер 

	- CURLOPT_HEADER - показати які заголоки я посилаю на інший сервер. Щоб зрозуміти про що я писав коли казав про основні 2 строчки зєднання з сервером і накочуванням функціоналу, ось код щоб подивити які заголовки я передаю. 

		  - $curl = curl_init();
		  - curl_setopt ($curl, CURLOPT_URL, "http://stock.on/php4/demo/curl/test.php");
		  - curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);
		  - curl_setopt($curl, CURLOPT_HEADER, 1);
		  - $a = curl_exec ($curl);
		  - curl_close ($curl);
		  - echo $a;

			- Тобто перші 3 строчки такі самі як і для того щоб поставити дані відпрацювання скріпта у іншому сервері у змінну. А вже якщо хочу подивити і заголовки, то добавляю 4-ту строчку

	- CURLOPT_NOBODY - якщо я добавлю цю строчку - curl_setopt($curl, CURLOPT_NOBODY, 1); то після відпрацювання $a = curl_exec ($curl); у змінній $a будуть тільки заголовки, які я посилаю на інший сервер. Знову ж, ця строчка не може працювати сама по собі, ця строчка додається до тих, які я вже написав.

 3) Записати файли з одного файлу в інший. Наприклад скопіювати файл з якосось сервера у файл який на моєму серваку

	  $curl = curl_init();
	  curl_setopt ($curl, CURLOPT_URL, "http://stock.on/php4/demo/curl/test.txt"); - Встановлюю звязок з цим файлом.
	  $fp = fopen("empty.txt", "w"); - Відкриваю файл для запису на моєму серваку. "w" - означає що у файлі все зітреться
	  curl_setopt($curl, CURLOPT_FILE, $fp); - записати дані з файлу test.txt у файл empty.txt. Але без заголовків. За це відповідає константа CURLOPT_FILE

		- Щоб записати зпголовки, треба написати трохи по іншому. Для прикладу запишу їх у інший файл (Тобто тіло буде у одному файлі, а заголовки у іншому)

			- $fh = fopen("headers.txt", "w");
			- curl_setopt($curl, CURLOPT_WRITEHEADER, $fh); - CURLOPT_WRITEHEADER - ця константа відповідає щоб записались заголовки

	  curl_exec ($curl);
	  curl_close ($curl);

 ----------------------------- Все що я досі описував, це було передавання даних методом Get -----------------------------------

 4) Звязуюсь з файлом через метод пост

	$curl = curl_init();
	curl_setopt($curl, CURLOPT_URL, "http://stock.on/php4/demo/curl/posttest.php");
	curl_setopt($curl, CURLOPT_POST, 1); - За це відповідає метод CURLOPT_POST
	curl_setopt($curl, CURLOPT_POSTFIELDS, "Hello=World&Foo=Bar&Name=Igor"); - Ця строчка, щоб передати дані методом ПОСТ
	curl_exec ($curl); - Знову ж таки, я ніде не вказував щоб ці дані повертались десь у змінну. Це просто виведуться дані скріпта, який відпрацює на іншому сервері. (У файлі скріпта на іншому сервері код var_dump($_POST); тож у файлі, де я написав метод КУРЛ, виведуться дані масива $_POST)
	curl_close ($curl);

	- Ці запити, які я писав до цього, це були запити методом GET, POST. Це означає, зайди у цей файл, що я вказав і відпрацюй скріпт який є у цьому файлі. Я можу навіть не знати що за мова у тому файлі, я просто звязуюсь з файлом по http, а сервер вже оприділяє що це пхп скріпт.

		- Але коли я пишу наприклад метод fwrite або fput, то це вже підрозуміває, що я знаю що я буду звязуватись з файлом методом PUT - if ($_SERVER['REQUEST_METHOD'] == "PUT"). Цей метод означає що стреба створити або обновити файл(ресурс), який я передаю

			- Не обовязково використовувати методи fwrite або fput. Це тільки один зі способів. Можна і напряму вказати, що я хочу використовувати метод PUT

			- У настройках сервера можна вказати, що робити коли я звертаюсь до файлів методом PUT. Наприклад за замовчуванням вказано, що коли я звертаюсь до хтмл файлів методом POST, то буде помилка, так як немає в цьому сенсу, Це просто створиться, або оновиться хтмл файл.

			- Метод PUT означає що я посилаю файл серверу

		- Обращаюсь до файла через КУРЛ методом PUT

			$curl = curl_init(); 
  			curl_setopt($curl, CURLOPT_URL, HOST_NAME . "upload/put.txt");

			curl_setopt($curl, CURLOPT_PUT, true); - CURLOPT_PUT - Вказує що обращатись до файлу put.txt я буду методом PUT. Тобто я або створю його, або оновлю


			$str = "Hello, world!"; 
			$fp = tmpfile(); - створитьсяв памяті якиїсь файл
			fwrite($fp, $str); - запишеться в нього "Hello, world!"; 
			fseek($fp, 0); 

			curl_setopt($curl, CURLOPT_INFILE, $fp); - запиши дані з файлу $str("Hello, world!")(в реальності це буде файл. Це я для тесту створив фай у памяті) у файл put.txt
			curl_setopt($curl, CURLOPT_INFILESIZE, strlen($str)); - Щоб записати дані у файл, треба вказати розмір даних, яких буду записувати. У даному випадку, розмір даних це strlen($str)

 5) ----- Це що я робив у пункті 4, це записував дані у файл put.txt методом КУРЛ, який знаходиться на іншому сервері. Тепер я буду описувати, як я це зробив. Як обробити запрос метода PUT --------

	- Взагалі метод PUT не дуже безпечний. Зазвичай у налаштуваннях сервера прописується доступ до різних файлів методом PUT. Наприклад якщо до хтмл файла звертатись методом POST, скорыш за все буде помилка - 

	- Спеціаліст створив ситуацію, де він перехвачував запроси методом PUT. Спочатку спеціаліст прописав файл .htaccsess у папці де лежав файл до якого я обращався методом PUT, що він перехвачував всі запроси у цій папці і перегаправляв їх у файл, який я вказав у .htaccsess RewriteEngine On     RewriteRule ^(.*)$ put.php?url=$1 [L]

		-  Типу в .htaccsess можна вказувати в яких саме папках я буду перехвачувати запрос. Перенаправляю всі запроси в даній папці в put.php

		- if ($_SERVER['REQUEST_METHOD'] == "PUT"){ - Перевіряю чи запрос методом PUT. Я запрашую КУРЛом, методом PUT, тож кондішн пройде.

			- Шоб я розумів ці заголовки. Тепер я  посилаю курлом запит на файл методом PUT. В htaccsess я перенаправив всі запити на put.php і код тепер виконується в ньому. Курлом, я вказав, що звертаюсь методом put, тож у файлі put.php цей конфішн if ($_SERVER['REQUEST_METHOD'] == "PUT"){  пройде. А якщо я у файлі put.php напишу строку заголовка header("HTTP/1.1 409 Create error");, то цей заголовок передасться КУКЛУ. 

				- Тобто. КУРЛОМ я роблю запит на сервер. В заллежності від того як на сервері відпрацює скріпт, повернуться різні заголовки КУРЛУ (Умовно 200, якщо все ок)

 6) в ПХП-м можна генерувати файл zip на ходу. А cURL-ом можна стягнути цей файл собі на сторінку

	$curl = curl_init(); 
	curl_setopt($curl, CURLOPT_URL, 'http://myhost.com/zip.php'); - zip.php - до цього файлу я звертаюсь
	curl_setopt($curl, CURLOPT_BINARYTRANSFER, 1); - CURLOPT_BINARYTRANSFER - це я вказую що дані будуть бінарними. Зазвичай дані передаються текстом. Мені треба щоб файл з яким я буду звязуватись віддавав зіп файл. Текст тут не підійде. Тому вказую щоб дані булм бінарними

	curl_setopt($curl, CURLOPT_HEADERFUNCTION, 'curlHeaderCallback'); - curlHeaderCallback() - ф-ція дозволяє задати заголовки файлу у якому метод КУРЛ. Тобто. Я стягую собі зіп архів з іншого файлу КУРЛОМ. Але на даний момент мій файл у якому метод КУРЛ маж заголовоко text/txt, тобто все що може выддати мый документ - це текст. Якщо я стягну зіп архів через КУРЛ, я не зможу взяти цей файл. Для цього є цей метод. Він дозволяє змінити заголовки в текущому файлі, після того як прийшли дані КУРЛа.  

		- header('Content-Disposition: attachment; filename="file-name.zip"'); якщо у документа є цей заголовок, браузер подумає що це зіп файл з назвою file-name.zip . 

	function curlHeaderCallback($curl, $headers) { - З того що я бачу, то ця - ція просто викличеться у файлі, до якого я звертаюсь через КУРЛ. Вона викличеться дуже рано, ще на рівні читання заголовків. Спеціаліст каже що у аргумент $headers попадуть заголовки того документа, до якого я звертаюсь через КУРЛ (не знаю як).

		header($headers); - всі які зараз є на сторінці будуть у аргументі $headers. Тобто строчка header($headers); задає заголовки які цей документ вже має

		header('Content-Disposition: attachment; filename="file-name.zip"'); - Після цього браузер почне скачувати файл file-name.zip Скачається він у будь якому випадку, а от за наповнення його відповідає скіпт файла, у який я звертаюсь через КУРЛ

			- Як створювати зіп архів і наповнювати його файлами, а файли текстом описувати не буду. Там ваще просто. як це робиться описано у файлі zip.php

		return strlen($headers);
	 }

 7) curl_getinfo($curl); - виведе дані про звязок з КУРЛа - $result = curl_getinfo($curl); // var_dump($result);

	array (size=26)
	  'url' => string 'http://stock.on/php4/demo/curl/zip.php' (length=38)
	  'content_type' => string 'text/html; charset=UTF-8' (length=24)
	  'http_code' => int 200
	  'header_size' => int 146
	  'request_size' => int 69
	  'filetime' => int -1
	  'ssl_verify_result' => int 0
	  'redirect_count' => int 0
	  'total_time' => float 0.035001
	  'namelookup_time' => float 0.028355
	  'connect_time' => float 0.028692
	  'pretransfer_time' => float 0.028734
	  'size_upload' => float 0
	  'size_download' => float 0
	  'speed_download' => float 0
	  'speed_upload' => float 0
	  'download_content_length' => float 0
	  'upload_content_length' => float 0
	  'starttransfer_time' => float 0.034933
	  'redirect_time' => float 0
	  'redirect_url' => string '' (length=0)
	  'primary_ip' => string '192.168.33.10' (length=13)
	  'certinfo' => 
	    array (size=0)
	      empty
	  'primary_port' => int 80
	  'local_ip' => string '10.0.3.14' (length=9)
	  'local_port' => int 46462

	- Це тільки мала частина. Метод curl_getinfo() може вивести набагато більше, якщо ввести правильні аргументи 

 8) В принципі це і так понятно, але навсяк випадок напишу. І курлом і вебсокетами, можна посилати 





 

----- Регулярки. В принципі те саме що і в скріпті, тільки тут більше флагів і ф-ції для роботи з ними не так називаються 
1) В пхп 7 з регулярок видалили POSIX(ereg_), залишилось тільки PCRE(preg_), їх можна оприділити по префіксу preg_ Регулярки працюють стандартно, тобто береться якиїсь шаблон і накладається на строку. Наприклад слово ход у слові 'находити'. Cпочатку 'ход' прикладається до "нах" - не совпало, потім до 'ахо', не совпало, і тд  
	/./ - крапка це будь який символ крім перевода строки. preg_match('/./', 'PHP 5', $matches); - знайти будь який символ в 'PHP 5' $matches - це масив, у якому будуть дані що совпали. preg_match('/./', 'PHP 5', $matches); echo $matches[1]; // Р - типу змінна $matches буде в глобвльній області бачення 
		- preg_match('/PHP.5/', 'PHP 5', $matches);    echo $matches[0]; // РHP 5
		- preg_match('/PHP.5/', 'PHP-5', $matches); echo $matches[0]; // РHP 5
		- preg_match('/PHP.5/', 'PHP5', $matches); echo $matches[0]; // нічого не виведе, не совпало
// \ Экранирование метасимволов и разделителей
	- preg_match('/.com/', 'site.com', $matches);	echo $matches[0]; // .com
	- preg_match('/.com/', 'site-com', $matches);	echo $matches[0]; // -com
	- preg_match('/\.com/', 'site-com', $matches); echo $matches[0]; //
	- preg_match('/\.com/', 'site.com', $matches); echo $matches[0]; // .com

 - Повторения
/*
{m} точное вхождение
{m,n} минимум и максимум
{m,} минимум вказаний, максимум неограничено
*/

	- preg_match('/tre{1,2}f/', 'trf', $matches); echo $matches[0]; //
	- preg_match('/trе{1,2}f/', 'tref', $matches); echo $matches[0]; // tref
	- preg_match('/trе{1,2}f/', 'treef', $matches); echo $matches[0]; // treef
	- preg_match('/trе{1,2}f/', 'treeef', $matches); echo $matches[0]; //
	​
	- preg_match('/fo{2,}ba{2}r/', 'foobaar', $matches); echo $matches[0]; // foobaar
	- preg_match('/fo{2,}ba{2}r/', 'fooooooobaar', $matches); echo $matches[0]; // fooooooobaar
	- preg_match('/fo{2,}ba{2}r/', 'fobaar', $matches); echo $matches[0]; //

 - Повторення можна замінити Квантифікаторами
/* Квантификаторы
? что и {0,1}
+ что и {1,}
* что и {0,}
*/

	- preg_match('/PHP.?5/', 'PHP 5', $matches); echo $matches[0]; // PHP 5
	- preg_match('/PHP.?5/', 'PHP5', $matches); echo $matches[0]; // PHP5
	​
	- preg_match('/a+b/', 'caaabc', $matches); echo $matches[0]; // aaab
	- preg_match('/a+b/', 'cabc', $matches); echo $matches[0]; // ab
	- preg_match('/a+b/', 'cbc', $matches); echo $matches[0]; //
	​
	- preg_match('/a*b/', 'caaaabc', $matches); echo $matches[0]; // aaaab
	- preg_match('/a*b/', 'cbc', $matches); echo $matches[0]; // b​

Метасимволы
 - початок, кінець строки. Якщо помістити регулярку між ^xyz$, то це має совпадати слово повністю
// ^ Ограничение начала строки
	- preg_match('/^abc/', 'abcd', $matches);	echo $matches[0]; // abc
	- preg_match('/^abc/', 'xabcd', $matches); echo $matches[0]; //
​
// $ Ограничение конца строки
	- preg_match('/xyz$/', 'abcdxyz', $matches); echo $matches[0]; // xyz
	- preg_match('/xyz$/', 'xyza', $matches); echo $matches[0]; //

// [...] Kласс искомых символов. Якщо елементи будуть знаходитись у квадратних дужках [...], то це означає, що буде шукатись будь який з них //  [abc] - шукається хоча б a або b або c, 
	- preg_match('/[0-9]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // 1995
	- preg_match('/[^0-9]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // PHP is released in -Галочка внутрі квадратних скобок це отріціеіє - знайди те що не включає в себе числа від 0 до 9. ЗВЕРНУТИ УВАГУ, ПРОБІЛ ТЕЖ ШУКАЄТЬСЯ
	- preg_match('/[a-zA-Z ]+/', 'PHP is released in 1995',$matches);	echo $matches[0]; // PHP is released in
	- preg_match('/[^a-zA-Z ]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // 1995 -Замість a-z можна вказати будь які букви, можна навіть [abcde...]

// (...) Группировка элементов.
	- $subject = 'PHP is released in 1995'; $pattern = '/PHP [a-zA-Z ]+([12][0-9])([0-9]{2})/';
		- preg_match($pattern, $subject, $matches); print_r($matches);  У перший так і попадає все повна строка совпадения, а в інші ключі попаде елементи з дужок // [0]=>PHP is released in 1995, [1]=>19, [2]=>05

 - В пхп регулярні строки це як строка а не обєкт на відміну в js. Тому їх треба писати а апострофах (не в лапках) - '/[^0-9]+/' . Тому що строка в лапках це ще не строка, вона парситься в строку. Тобто "4\*" це не кінечний варіант, кінечним варіантом цього буде просто зірочка "4*", тому якщо буду писати в лапках, то треба буде писати "4\\*", щоб воно шукало 4* а не - 4 може бути 0 а може хоч скільки
	- Всі спеціальні символи(? + ] ...) треба екранувати

 - Любое выражение начинается с символа-ограничителя (delimiter по англ.). В качестве него обычно используют символ /, но можно использовать и другие символы, не имеющие специального назначения в регулярках, например, ~, # или @ (Вроді спеціаліст казав, що замість слеша може використовуватись взагалі будь який символ, який не використовується в регулярці). Альтернативные разделители используют, если в выражении может встречаться символ /. Затем идет сам шаблон строки, которую мы ищем, за ним второй ограничитель и в конце может идти одна или несколько букв-флагов.

/*
\t \n \f \r (ASCII 9, 10, 12, 13)
\d ( [0-9] )
\D ( [^0-9] )
\s ( [\t\n\f\r ] ) - пробіл теж попадає
\S ( [^\t\n\f\r ] ) - як \s, але навпаки ( і без пробіла )
\w ( Любая буква, цифра, символ подчеркивания )
\W ( Противоположность \w )
* /
	
 - \b ( Позиция между соседними символами \w и \W ) - Схоже на \w, але тут підпаде тільки повне сходження. Типу решітки не в щот, тільки букви цифри
	$string = "##Testing123##";
		- preg_match('/\b.+\b/', $string, $matches); echo $matches[0]; // Testing123 - решітки не в щот
		- preg_match('/\bTesting\b/', $string, $matches); echo $matches[0]; // Не совпаде, оскільки це не повний вираз, повний Testing123

 - //\B ( Противоположность \b ) 

// Жадные квантификаторы: * и + ( В скріпті теж є жаднісь )
	$subject = '<b>I am bold.</b> <i>I am italic.</i> <b>I am also bold.</b>';
	preg_match('#<b>(.+)</b>#', $subject, $matches); 
	echo $matches[1]; // I am bold.</b> <i>I am italic.</i> <b>I am also bold. - Ось чому ці квантефікатири називаються жадними (* +), після того як вони знайдуть останній шаблон(</b>), вони продовжують шукати його далі по строці. Цю багу можна вилікувати за допомогою ? // preg_match('#<b>(.+?)</b>#', $subject, $matches); echo $matches[1]; // I am bold.
		Флаг U (PCRE_UNGREEDY) - Этот модификатор инвертирует жадность квантификаторов, таким образом они по умолчанию не жадные. Но становятся жадными, если за ними следует символ ?. Такая 			возможность не совместима с Perl. Его также можно установить с помощью (?U) установки модификатора внутри шаблона или добавив знак вопроса после квантификатора (например, .*?).
			- $subject = '<b>I am bold.</b> <i>I am italic.</i> <b>Iam also bold.</b>'; preg_match('#<b>(.+)</b>#U', $subject, $matches); echo $matches[1]; // I am bold.

 Модификаторы (флаги)
 - З регістронезалежним і з мультистроковим тут так само як і в скріпті
 // m Многострочный поиск
	$subject = "ABC\nDEF\nGHI";
	preg_match('/^DEF/', $subject, $matches);
	echo $matches[0]; // preg_match('/^DEF/m', $subject, $matches);
	echo $matches[0]; // DEF

// S Однострочный поиск: "." = . + перевод строки. Тобто якщо поставити цей флаг, крапка('/./s') буде крапкою, а не всім крім перевода строки і символи перевода строки будуть вирізатись
	$subject = "ABC\nDEF\nGHI";
	preg_match('/BC.DE/', $subject, $matches);
	echo $matches[0]; //
	preg_match('/BC.DE/S', $subject, $matches); у мене працювало тільки з малою s. і наскільки я зрозумів при парсінгу, він перетворює текст в одну строку, але запамятовує де вони були, тому при echo $matches[0]; виведеться BC\nDE. По ходу це придумали для того, щоб не писати флаг мультистрочності 
	echo $matches[0]; // BC\nDE 

​
// x Пропуск пробелов и комментариев(#) в тексте шаблона. Для читабельності регулярки можна використовувати пробіли і коменти. Щоб при парсінгу їх не враховувати, треба поставити флаг 'x'
	$subject = "ABC\nDEF\nGHI";
	preg_match('/A B C/', $subject, $matches);
	echo $matches[0]; //
	preg_match('/A B C/x', $subject, $matches);
	echo $matches[0]; // ABC

// D Что и $, если строка не заканчивается \n
	preg_match('/BC$/', "ABC\n", $matches);
		echo $matches[0]; // BC -Типу доллар по ходу не враховує перевод строки і всеодно вважає що строка закінчується на BC, а не на BC і пробіл вкінці, А з флагом D почне враховувати
	preg_match('/BC$/D', "ABC\n", $matches);
		echo $matches[0]; //
​// A Что и ^ (начало строки)
	preg_match('/[a-c]{3}/i', '123ABC', $matches);
		echo $matches[0]; // ABC
	preg_match('/[a-c]{3}/iA', '123ABC', $matches);
		echo $matches[0]; //

// Функции поиска 
	$subject = '<b>I am bold.</b> <i>I am italic.</i>';
	$pattern = '#<[^>]+>(.*)</[^>]+>#U';
	preg_match($pattern, $subject, $matches);
		print_r($matches); // [0]=><b>I am bold.</b>, [1]=>Iam bold.
	preg_match_all($pattern, $subject, $matches,PREG_PATTERN_ORDER);
		print_r($matches);


 - preg_match_all - те ж саме що і preg_match, але він працює не першого сходження, а знайде всі сходження. Типу флага global к скріпті. Дані що підходять він розкладе у багатовимірний масив. Яким чином він це буде робити, можна регулювати константами. Наприклад, можна вказати, що групіровані елементи будуть в одномі підмасиві з знайденим шаблоном чи отдільно.
	- $subject = '<b>I am bold.</b> <i>I am italic.</i>'; 	$pattern = '#<[^>]+>(.*)</[^>]+>#U';
		preg_match_all($pattern, $subject, $matches,PREG_PATTERN_ORDER);
		print_r($matches);
			// [0][0] => <b>I am bold.</b>, [0][1] => <i>I amitalic.</i>
			// [1][0] => I am bold., [1][1] => I am italic.

		preg_match_all($pattern, $subject, $matches,PREG_SET_ORDER);
		print_r($matches);
			// [0][0] => <b>I am bold.</b>, [0][1] => I am bold.
			// [1][0] => <i>I am italic.</i>, [1][1] => I am italic.

// Функция замены. До даних, що я згрупував у дужках, можна буде звернутись по принципу - доллар($) і порядковий номер даних у дужках 
	$subject = 'April 15, 2003';
	$pattern = '/(\w+) (\d+), (\d+)/i'; // '$1' '$2', '$3';
		$replace = '$2 $1, $3'; // "\$2 \$1, \$3" - Якщо у подвійних кавчках, то треба екранувати доллари 
		echo preg_replace($pattern, $replace, $subject); // 15 April, 2003

// Функция разделения
 - preg_split - типу explode, тільки регуляркою можу настроювати як хочу по чому розбивати. Вона варіативна, є різні константи для неї, її можна настроювати, не буду все розписувати, краще загуглити 
	$subject = 'hypertext language, programming';
	$pattern = '/[\s,]+/';
	$words = preg_split($pattern, $subject);
	print_r($words); // [0]=>hypertext, [1]=>language, [2]=>programming


 Флаг u - говорит, что выражение и текст, по которому идет поиск, исплоьзуют кодировку utf-8, а не только латинские буквы. Без него поиск русских (и любых других нелатинских) символов может работать некорректно, потому стоит ставить его всегда.


 ----------------- Namespace ПРостранство імен -----------------
 - Спеціаліст казав думати про Namespace як про папку. Суть неймспейсів в тому, щоб розкласти це все в різні участки памяті. Це вирішить проблему з Пересечением имен функций, констант и классов
 1) \ - Родзделитель цих папок (участків пвмяті по ходу)
 2) namespace є вже і у пустому файлі. якщо його запросити, то повернеться пуста строка, але він є
	__NAMESPACE__ - Константа імені namespace
 2) У файла є неймспейс, і під ним код. Весь цей код буде у пространстві імені цього файлу. Типу як файли в папці
	- Але це не означає що в проекті мають бути реальні папки з цими назвами \Module_name\Model\Test пхп по ходу буде хранити ці участки памяті в по них можна буде бродити, типу зліва батько, справа дитина і тд
	- Можна навыть зробити 2 неймспейси у файлі, але краще не треба
 2) - Щоб обявити імя namespace для файла треба написисати namespace MyModule;
	- namespace має йти перший файлі, тобто перед ним не має бути коду
 2) І коли вже я маю файли з неймспейсами, їх можна підключити у якийсь файл. Код цього файлу буде мати глобальне пространство імен, а підключені файли з неймспейсами - своє пространство - Файл index.php
							<?php
								require_once "MyModule.php";
								require_once "AnotherModule.php";
								/* А это глобальное пространство имён. Здесь наш код */
							?>
 2) Якщо у файлі є неймспейс Project і також у цьому файлі є клас Connection, то імя цього класа буде не Connection, а Project\Connection Це мам пхп його переіменує. Клас по ходу буде в під участку памяті, учаска памяті цього файлу. Але код внутрі файлу буде розуміти, що до чого, це я зрозумів з того, що коли при присвоєнні класа обєкту, не треба було вводити $obj = new Project\Connection; Він розумів і традиційний запис $obj = new Connection; 
	<?php
		namespace Project;

		class Connection{
		  function __construct(){
		    echo __CLASS__.'<br>'; // 
		  }
		}
		echo 'Из PROJECT:<br>';
		$obj = new Connection;
	?>
 2) 
 2) Якщо я знахожусь у файлі з namespace Project; i заінклюдив у нього файл з неймспейсом - namespace Project\Sub; а у файла з namespace Project\Sub; є клас Connection, то цей клас можна присвоїти у файлі з namespace Project; таким чином - $obj = new Sub\Connection; Тобто повний шлях у нього Project\Sub\Connection, але я вже знаходжусь у пространстві Project Тут все як з папками
	- Я можу заінклюдити файл з namespace Project; і в ньому вже настворювати обєктів $obj1 = new Project\Connection; $obj2 = new Project\Sub\Connection;
		- Є і абсолютні шляхи, вони починаються з корня. Я не зрозумів чому, але файл, у який інклюдиться файл з неймспейсом Project - це \ Я зробив ці висновки, оскільки в цьому файлі був свій клас Connection і він створював від нього обєкт $new = \Connection; Тут з абсолютними шляхами як в ссилках, можна ними користуватись звыдки завгодно. Типу якщо у неймспейсі є Sub є константа CONSTT, я її можу вивести так - echp CONSTT. І якщо у корневому є константа з таким іменем, я її можу вивести указавши її шлях - echo  \CONSTT, так само можна вивести константу, якщо і в namespace Project є така константа - echo \Project\CONSTT
 2) У файлі у якому є неймспейс можуть бути тільки класи, ф-ції і константи. 
	- ф-ції у файлі неймспейса працюють типу як замикання. Спочатку він шукає реалізацію ф-ції у себе в файлі, потім у файлі, родительського неймспейса і до корневого а потім вже йде в глобальну облась. 
	- Якщо я задав namespaceу файлі, то це вже отдільна область бачення. Кожен неймспейс - отдільна область бачення, щоб не було конфліктів мабуть. У файлі де є namespace навіть не можна просто звернутись до якоїсь ф-ції, так як вона у глобальній області бачення. Типу якщо я викличу strlen(), її не буде знайдено. Якщо я опишу свою strlen, конфліктів не буде. Щоб зайти у глобальну область, треба поставити перед нею обратний слеш \strlen; Спеціаліст зробив свою ф-цію strlen, і через неї викликав глобальну function strlen ($str){ return \strlen($str) } Тобто неймспейс - це отдільна область бачення. Тут навіть можна переписати нативну ф-цію пхп. У неї глобальна область бачення, а у тої що у неймспейсі буде локальна
	- І то що глобальна ф-ція викликається так, \strlen мабуть дає відповідь на те, чому у файлі у якому інклюдяться неймспейси можна викликати клас, що знаходиться в ньому, \Class. По ходу цей обратний слеш це якиъсь вход в глобальну облась бачення
	- Якщо я не перезаписував нативні ф-ції пхп у файлі з неймспейсом, або у родительських неймспейсах, то можна обійтись без обратних слешів для роботи з цією ф-цією
 2) Але ці "замикання" діють тідьки на ф-ції і константи. З класами не так. Класи будуть шукатись тільки у файлі неймспейса, тобто якщо написати new Exeption() - буде помилка, оскыльки він не розуміє що це. Щоб він зрозумів, треба перед ним покласти обратний слеш, і він знайде його в глобальній області бачення
 2) Псевдоніми
 - Наприклад у файл інклюдяться файли з неймспейсами і серед них є неймспейс My\Full\Classname
	- use My\Full\Classname as Bar; Я дав йому псевдонім Bar і тепер можу працювати з ним $obj = new Bar; // объект класса My\Full\Classname
	- Якщо в файлі в який інклюдиться неймспейси є цей клас теж, то до нього треба буде звертатись так - $obj = new namespace\Bar; // объект класса Foo\Bar
	- Можна нанавіть працювати з останнім куском - use My\Full\NSname; - те саме, що My\Full\NSname as NSname, але то такоє. NSname\subns\func(); // функция My\Full\NSname\subns\func - Типу навіть шлях до ф-ції треба використовувати обратні слеші
	- щоб не писати кожного разу обратні слеші перед глобальним класом, можна написати use \ArrayObject; // $obj = new ArrayObject(array(1)); // глобальный ArrayObject

/* Remove false, than $productData->getAuthor() will be fine */ false && 


<?php if ($_options = $block->getOptionList()):?>
                <dl class="item-options">
					<?php foreach ($_options as $_option) : ?>
						<?php $_formatedOptionValue = $block->getFormatedOptionValue($_option) ?>
                        <dt><?= $block->escapeHtml($_option['label']) ?></dt>
                        <dd>
							<?php if (isset($_formatedOptionValue['full_view'])): ?>
								<?= /* @escapeNotVerified */ $_formatedOptionValue['full_view'] ?>
							<?php else: ?>
								<?= /* @escapeNotVerified */ $_formatedOptionValue['value'] ?>
							<?php endif; ?>
                        </dd>
					<?php endforeach; ?>
                </dl>
			<?php endif;?>


 - Хюго так підключив скріпт
var config = {
    deps: [
        "js/navigation" цей файл знаходиться у web/js
    ]
};










