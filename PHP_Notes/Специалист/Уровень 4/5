 ----- Регулярки. В принципі те саме що і в скріпті, тільки тут більше флагів і ф-ції для роботи з ними не так називаються 
1) В пхп 7 з регулярок видалили POSIX(ereg_), залишилось тільки PCRE(preg_), їх можна оприділити по префіксу preg_ Регулярки працюють стандартно, тобто береться якиїсь шаблон і накладається на строку. Наприклад слово ход у слові 'находити'. Cпочатку 'ход' прикладається до "нах" - не совпало, потім до 'ахо', не совпало, і тд  
	/./ - крапка це будь який символ крім перевода строки. preg_match('/./', 'PHP 5', $matches); - знайти будь який символ в 'PHP 5' $matches - це масив, у якому будуть дані що совпали. preg_match('/./', 'PHP 5', $matches); echo $matches[1]; // Р - типу змінна $matches буде в глобвльній області бачення 
		- preg_match('/PHP.5/', 'PHP 5', $matches);    echo $matches[0]; // РHP 5
		- preg_match('/PHP.5/', 'PHP-5', $matches); echo $matches[0]; // РHP 5
		- preg_match('/PHP.5/', 'PHP5', $matches); echo $matches[0]; // нічого не виведе, не совпало
// \ Экранирование метасимволов и разделителей
	- preg_match('/.com/', 'site.com', $matches);	echo $matches[0]; // .com
	- preg_match('/.com/', 'site-com', $matches);	echo $matches[0]; // -com
	- preg_match('/\.com/', 'site-com', $matches); echo $matches[0]; //
	- preg_match('/\.com/', 'site.com', $matches); echo $matches[0]; // .com

 - Повторения
/*
{m} точное вхождение
{m,n} минимум и максимум
{m,} минимум вказаний, максимум неограничено
*/

	- preg_match('/tre{1,2}f/', 'trf', $matches); echo $matches[0]; //
	- preg_match('/trе{1,2}f/', 'tref', $matches); echo $matches[0]; // tref
	- preg_match('/trе{1,2}f/', 'treef', $matches); echo $matches[0]; // treef
	- preg_match('/trе{1,2}f/', 'treeef', $matches); echo $matches[0]; //
	​
	- preg_match('/fo{2,}ba{2}r/', 'foobaar', $matches); echo $matches[0]; // foobaar
	- preg_match('/fo{2,}ba{2}r/', 'fooooooobaar', $matches); echo $matches[0]; // fooooooobaar
	- preg_match('/fo{2,}ba{2}r/', 'fobaar', $matches); echo $matches[0]; //

 - Повторення можна замінити Квантифікаторами
/* Квантификаторы
? что и {0,1}
+ что и {1,}
* что и {0,}
*/

	- preg_match('/PHP.?5/', 'PHP 5', $matches); echo $matches[0]; // PHP 5
	- preg_match('/PHP.?5/', 'PHP5', $matches); echo $matches[0]; // PHP5
	​
	- preg_match('/a+b/', 'caaabc', $matches); echo $matches[0]; // aaab
	- preg_match('/a+b/', 'cabc', $matches); echo $matches[0]; // ab
	- preg_match('/a+b/', 'cbc', $matches); echo $matches[0]; //
	​
	- preg_match('/a*b/', 'caaaabc', $matches); echo $matches[0]; // aaaab
	- preg_match('/a*b/', 'cbc', $matches); echo $matches[0]; // b​

Метасимволы
 - початок, кінець строки. Якщо помістити регулярку між ^xyz$, то це має совпадати слово повністю
// ^ Ограничение начала строки
	- preg_match('/^abc/', 'abcd', $matches);	echo $matches[0]; // abc
	- preg_match('/^abc/', 'xabcd', $matches); echo $matches[0]; //
​
// $ Ограничение конца строки
	- preg_match('/xyz$/', 'abcdxyz', $matches); echo $matches[0]; // xyz
	- preg_match('/xyz$/', 'xyza', $matches); echo $matches[0]; //

// [...] Kласс искомых символов. Якщо елементи будуть знаходитись у квадратних дужках [...], то це означає, що буде шукатись будь який з них //  [abc] - шукається хоча б a або b або c, 
	- preg_match('/[0-9]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // 1995
	- preg_match('/[^0-9]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // PHP is released in -Галочка внутрі квадратних скобок це отріціеіє - знайди те що не включає в себе числа від 0 до 9. ЗВЕРНУТИ УВАГУ, ПРОБІЛ ТЕЖ ШУКАЄТЬСЯ
	- preg_match('/[a-zA-Z ]+/', 'PHP is released in 1995',$matches);	echo $matches[0]; // PHP is released in
	- preg_match('/[^a-zA-Z ]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // 1995 -Замість a-z можна вказати будь які букви, можна навіть [abcde...]

// (...) Группировка элементов.
	- $subject = 'PHP is released in 1995'; $pattern = '/PHP [a-zA-Z ]+([12][0-9])([0-9]{2})/';
		- preg_match($pattern, $subject, $matches); print_r($matches);  У перший так і попадає все повна строка совпадения, а в інші ключі попаде елементи з дужок // [0]=>PHP is released in 1995, [1]=>19, [2]=>05

 - В пхп регулярні строки це як строка а не обєкт на відміну в js. Тому їх треба писати а апострофах (не в лапках) - '/[^0-9]+/' . Тому що строка в лапках це ще не строка, вона парситься в строку. Тобто "4\*" це не кінечний варіант, кінечним варіантом цього буде просто зірочка "4*", тому якщо буду писати в лапках, то треба буде писати "4\\*", щоб воно шукало 4* а не - 4 може бути 0 а може хоч скільки
	- Всі спеціальні символи(? + ] ...) треба екранувати

 - Любое выражение начинается с символа-ограничителя (delimiter по англ.). В качестве него обычно используют символ /, но можно использовать и другие символы, не имеющие специального назначения в регулярках, например, ~, # или @ (Вроді спеціаліст казав, що замість слеша може використовуватись взагалі будь який символ, який не використовується в регулярці). Альтернативные разделители используют, если в выражении может встречаться символ /. Затем идет сам шаблон строки, которую мы ищем, за ним второй ограничитель и в конце может идти одна или несколько букв-флагов.

/*
\t \n \f \r (ASCII 9, 10, 12, 13)
\d ( [0-9] )
\D ( [^0-9] )
\s ( [\t\n\f\r ] ) - пробіл теж попадає
\S ( [^\t\n\f\r ] ) - як \s, але навпаки ( і без пробіла )
\w ( Любая буква, цифра, символ подчеркивания )
\W ( Противоположность \w )
* /
	
 - \b ( Позиция между соседними символами \w и \W ) - Схоже на \w, але тут підпаде тільки повне сходження. Типу решітки не в щот, тільки букви цифри
	$string = "##Testing123##";
		- preg_match('/\b.+\b/', $string, $matches); echo $matches[0]; // Testing123 - решітки не в щот
		- preg_match('/\bTesting\b/', $string, $matches); echo $matches[0]; // Не совпаде, оскільки це не повний вираз, повний Testing123

 - //\B ( Противоположность \b ) 

// Жадные квантификаторы: * и + ( В скріпті теж є жаднісь )
	$subject = '<b>I am bold.</b> <i>I am italic.</i> <b>I am also bold.</b>';
	preg_match('#<b>(.+)</b>#', $subject, $matches); 
	echo $matches[1]; // I am bold.</b> <i>I am italic.</i> <b>I am also bold. - Ось чому ці квантефікатири називаються жадними (* +), після того як вони знайдуть останній шаблон(</b>), вони продовжують шукати його далі по строці. Цю багу можна вилікувати за допомогою ? // preg_match('#<b>(.+?)</b>#', $subject, $matches); echo $matches[1]; // I am bold.
		Флаг U (PCRE_UNGREEDY) - Этот модификатор инвертирует жадность квантификаторов, таким образом они по умолчанию не жадные. Но становятся жадными, если за ними следует символ ?. Такая 			возможность не совместима с Perl. Его также можно установить с помощью (?U) установки модификатора внутри шаблона или добавив знак вопроса после квантификатора (например, .*?).
			- $subject = '<b>I am bold.</b> <i>I am italic.</i> <b>Iam also bold.</b>'; preg_match('#<b>(.+)</b>#U', $subject, $matches); echo $matches[1]; // I am bold.

 Модификаторы (флаги)
 - З регістронезалежним і з мультистроковим тут так само як і в скріпті
 // m Многострочный поиск
	$subject = "ABC\nDEF\nGHI";
	preg_match('/^DEF/', $subject, $matches);
	echo $matches[0]; // preg_match('/^DEF/m', $subject, $matches);
	echo $matches[0]; // DEF

// S Однострочный поиск: "." = . + перевод строки. Тобто якщо поставити цей флаг, крапка('/./s') буде крапкою, а не всім крім перевода строки і символи перевода строки будуть вирізатись
	$subject = "ABC\nDEF\nGHI";
	preg_match('/BC.DE/', $subject, $matches);
	echo $matches[0]; //
	preg_match('/BC.DE/S', $subject, $matches); у мене працювало тільки з малою s. і наскільки я зрозумів при парсінгу, він перетворює текст в одну строку, але запамятовує де вони були, тому при echo $matches[0]; виведеться BC\nDE. По ходу це придумали для того, щоб не писати флаг мультистрочності 
	echo $matches[0]; // BC\nDE 

​
// x Пропуск пробелов и комментариев(#) в тексте шаблона. Для читабельності регулярки можна використовувати пробіли і коменти. Щоб при парсінгу їх не враховувати, треба поставити флаг 'x'
	$subject = "ABC\nDEF\nGHI";
	preg_match('/A B C/', $subject, $matches);
	echo $matches[0]; //
	preg_match('/A B C/x', $subject, $matches);
	echo $matches[0]; // ABC

// D Что и $, если строка не заканчивается \n
	preg_match('/BC$/', "ABC\n", $matches);
		echo $matches[0]; // BC -Типу доллар по ходу не враховує перевод строки і всеодно вважає що строка закінчується на BC, а не на BC і пробіл вкінці, А з флагом D почне враховувати
	preg_match('/BC$/D', "ABC\n", $matches);
		echo $matches[0]; //
​// A Что и ^ (начало строки)
	preg_match('/[a-c]{3}/i', '123ABC', $matches);
		echo $matches[0]; // ABC
	preg_match('/[a-c]{3}/iA', '123ABC', $matches);
		echo $matches[0]; //

// Функции поиска 
	$subject = '<b>I am bold.</b> <i>I am italic.</i>';
	$pattern = '#<[^>]+>(.*)</[^>]+>#U';
	preg_match($pattern, $subject, $matches);
		print_r($matches); // [0]=><b>I am bold.</b>, [1]=>Iam bold.
	preg_match_all($pattern, $subject, $matches,PREG_PATTERN_ORDER);
		print_r($matches);


 - preg_match_all - те ж саме що і preg_match, але він працює не першого сходження, а знайде всі сходження. Типу флага global к скріпті. Дані що підходять він розкладе у багатовимірний масив. Яким чином він це буде робити, можна регулювати константами. Наприклад, можна вказати, що групіровані елементи будуть в одномі підмасиві з знайденим шаблоном чи отдільно.
	- $subject = '<b>I am bold.</b> <i>I am italic.</i>'; 	$pattern = '#<[^>]+>(.*)</[^>]+>#U';
		preg_match_all($pattern, $subject, $matches,PREG_PATTERN_ORDER);
		print_r($matches);
			// [0][0] => <b>I am bold.</b>, [0][1] => <i>I amitalic.</i>
			// [1][0] => I am bold., [1][1] => I am italic.

		preg_match_all($pattern, $subject, $matches,PREG_SET_ORDER);
		print_r($matches);
			// [0][0] => <b>I am bold.</b>, [0][1] => I am bold.
			// [1][0] => <i>I am italic.</i>, [1][1] => I am italic.

// Функция замены. До даних, що я згрупував у дужках, можна буде звернутись по принципу - доллар($) і порядковий номер даних у дужках 
	$subject = 'April 15, 2003';
	$pattern = '/(\w+) (\d+), (\d+)/i'; // '$1' '$2', '$3';
		$replace = '$2 $1, $3'; // "\$2 \$1, \$3" - Якщо у подвійних кавчках, то треба екранувати доллари 
		echo preg_replace($pattern, $replace, $subject); // 15 April, 2003

// Функция разделения
 - preg_split - типу explode, тільки регуляркою можу настроювати як хочу по чому розбивати. Вона варіативна, є різні константи для неї, її можна настроювати, не буду все розписувати, краще загуглити 
	$subject = 'hypertext language, programming';
	$pattern = '/[\s,]+/';
	$words = preg_split($pattern, $subject);
	print_r($words); // [0]=>hypertext, [1]=>language, [2]=>programming


 Флаг u - говорит, что выражение и текст, по которому идет поиск, исплоьзуют кодировку utf-8, а не только латинские буквы. Без него поиск русских (и любых других нелатинских) символов может работать некорректно, потому стоит ставить его всегда.


 ----------------- Namespace ПРостранство імен -----------------
 - Спеціаліст казав думати про Namespace як про папку. Суть неймспейсів в тому, щоб розкласти це все в різні участки памяті. Це вирішить проблему з Пересечением имен функций, констант и классов
 1) \ - Родзделитель цих папок (участків пвмяті по ходу)
 2) namespace є вже і у пустому файлі. якщо його запросити, то повернеться пуста строка, але він є
	__NAMESPACE__ - Константа імені namespace
 2) У файла є неймспейс, і під ним код. Весь цей код буде у пространстві імені цього файлу. Типу як файли в папці
	- Але це не означає що в проекті мають бути реальні папки з цими назвами \Module_name\Model\Test пхп по ходу буде хранити ці участки памяті в по них можна буде бродити, типу зліва батько, справа дитина і тд
	- Можна навыть зробити 2 неймспейси у файлі, але краще не треба
 2) - Щоб обявити імя namespace для файла треба написисати namespace MyModule;
	- namespace має йти перший файлі, тобто перед ним не має бути коду
 2) І коли вже я маю файли з неймспейсами, їх можна підключити у якийсь файл. Код цього файлу буде мати глобальне пространство імен, а підключені файли з неймспейсами - своє пространство - Файл index.php
							<?php
								require_once "MyModule.php";
								require_once "AnotherModule.php";
								/* А это глобальное пространство имён. Здесь наш код */
							?>
 2) Якщо у файлі є неймспейс Project і також у цьому файлі є клас Connection, то імя цього класа буде не Connection, а Project\Connection Це мам пхп його переіменує. Клас по ходу буде в під участку памяті, учаска памяті цього файлу. Але код внутрі файлу буде розуміти, що до чого, це я зрозумів з того, що коли при присвоєнні класа обєкту, не треба було вводити $obj = new Project\Connection; Він розумів і традиційний запис $obj = new Connection; 
	<?php
		namespace Project;

		class Connection{
		  function __construct(){
		    echo __CLASS__.'<br>'; // 
		  }
		}
		echo 'Из PROJECT:<br>';
		$obj = new Connection;
	?>
 2) 
 2) Якщо я знахожусь у файлі з namespace Project; i заінклюдив у нього файл з неймспейсом - namespace Project\Sub; а у файла з namespace Project\Sub; є клас Connection, то цей клас можна присвоїти у файлі з namespace Project; таким чином - $obj = new Sub\Connection; Тобто повний шлях у нього Project\Sub\Connection, але я вже знаходжусь у пространстві Project Тут все як з папками
	- Я можу заінклюдити файл з namespace Project; і в ньому вже настворювати обєктів $obj1 = new Project\Connection; $obj2 = new Project\Sub\Connection;
		- Є і абсолютні шляхи, вони починаються з корня. Я не зрозумів чому, але файл, у який інклюдиться файл з неймспейсом Project - це \ Я зробив ці висновки, оскільки в цьому файлі був свій клас Connection і він створював від нього обєкт $new = \Connection; Тут з абсолютними шляхами як в ссилках, можна ними користуватись звыдки завгодно. Типу якщо у неймспейсі є Sub є константа CONSTT, я її можу вивести так - echp CONSTT. І якщо у корневому є константа з таким іменем, я її можу вивести указавши її шлях - echo  \CONSTT, так само можна вивести константу, якщо і в namespace Project є така константа - echo \Project\CONSTT
 2) У файлі у якому є неймспейс можуть бути тільки класи, ф-ції і константи. 
	- ф-ції у файлі неймспейса працюють типу як замикання. Спочатку він шукає реалізацію ф-ції у себе в файлі, потім у файлі, родительського неймспейса і до корневого а потім вже йде в глобальну облась. 
	- Якщо я задав namespaceу файлі, то це вже отдільна область бачення. Кожен неймспейс - отдільна область бачення, щоб не було конфліктів мабуть. У файлі де є namespace навіть не можна просто звернутись до якоїсь ф-ції, так як вона у глобальній області бачення. Типу якщо я викличу strlen(), її не буде знайдено. Якщо я опишу свою strlen, конфліктів не буде. Щоб зайти у глобальну область, треба поставити перед нею обратний слеш \strlen; Спеціаліст зробив свою ф-цію strlen, і через неї викликав глобальну function strlen ($str){ return \strlen($str) } Тобто неймспейс - це отдільна область бачення. Тут навіть можна переписати нативну ф-цію пхп. У неї глобальна область бачення, а у тої що у неймспейсі буде локальна
	- І то що глобальна ф-ція викликається так, \strlen мабуть дає відповідь на те, чому у файлі у якому інклюдяться неймспейси можна викликати клас, що знаходиться в ньому, \Class. По ходу цей обратний слеш це якиъсь вход в глобальну облась бачення
	- Якщо я не перезаписував нативні ф-ції пхп у файлі з неймспейсом, або у родительських неймспейсах, то можна обійтись без обратних слешів для роботи з цією ф-цією
 2) Але ці "замикання" діють тідьки на ф-ції і константи. З класами не так. Класи будуть шукатись тільки у файлі неймспейса, тобто якщо написати new Exeption() - буде помилка, оскыльки він не розуміє що це. Щоб він зрозумів, треба перед ним покласти обратний слеш, і він знайде його в глобальній області бачення
 2) Псевдоніми
 - Наприклад у файл інклюдяться файли з неймспейсами і серед них є неймспейс My\Full\Classname
	- use My\Full\Classname as Bar; Я дав йому псевдонім Bar і тепер можу працювати з ним $obj = new Bar; // объект класса My\Full\Classname
	- Якщо в файлі в який інклюдиться неймспейси є цей клас теж, то до нього треба буде звертатись так - $obj = new namespace\Bar; // объект класса Foo\Bar
	- Можна нанавіть працювати з останнім куском - use My\Full\NSname; - те саме, що My\Full\NSname as NSname, але то такоє. NSname\subns\func(); // функция My\Full\NSname\subns\func - Типу навіть шлях до ф-ції треба використовувати обратні слеші
	- щоб не писати кожного разу обратні слеші перед глобальним класом, можна написати use \ArrayObject; // $obj = new ArrayObject(array(1)); // глобальный ArrayObject

/* Remove false, than $productData->getAuthor() will be fine */ false && 


<?php if ($_options = $block->getOptionList()):?>
                <dl class="item-options">
					<?php foreach ($_options as $_option) : ?>
						<?php $_formatedOptionValue = $block->getFormatedOptionValue($_option) ?>
                        <dt><?= $block->escapeHtml($_option['label']) ?></dt>
                        <dd>
							<?php if (isset($_formatedOptionValue['full_view'])): ?>
								<?= /* @escapeNotVerified */ $_formatedOptionValue['full_view'] ?>
							<?php else: ?>
								<?= /* @escapeNotVerified */ $_formatedOptionValue['value'] ?>
							<?php endif; ?>
                        </dd>
					<?php endforeach; ?>
                </dl>
			<?php endif;?>


 - Хюго так підключив скріпт
var config = {
    deps: [
        "js/navigation" цей файл знаходиться у web/js
    ]
};










