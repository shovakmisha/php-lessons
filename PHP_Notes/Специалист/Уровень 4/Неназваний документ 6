
 ----------------------------------------- REST API --------------------------------

 1) REST - це договір (абстракція). Це не стандарт.

 2) спеціаліст каже що можна передавати різні дані, не тільки json, xml, html

 3) При обміні даними REST використовує http методи 

	- GET - Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные. 

	- POST - используется для отправки сущностей к определённому ресурсу 

	- PUT 

	- DELETE(удаляет указанный ресурс)). У КУРЛа не має константи, щоб вказати що я передаю цей заголовок. Типу якщо я хочу вказати що передаю методом пост, я напишу CURLOPT_POSTFIELDS. А для DELETE не має такого. КУРЛ дозволяє кастомно вказати заголовок. curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "DELETE"); - відправить заголовок DELETE

 3) Зазвиай у сцмс-ках метод request відповідає за все шо приходить (У мадженті наприклад я з нього витягую все що звязано з адресною строкою. Типу які дані приходять, якщо наприклад я зайшов на якусь сторінку в браузері) У цьому випадку він відповідає за то щоб взяти дані яку прийшли через REST.  $book = $app->request()

	- Ну а метод response() відповідає за те що скріпт віддає (у браузер або через REST) - $res = $app->response();
	
		- Якщо додатково треба послати заголовок наприклад, можна його додати у респонз - $res["Content-Type"] = "application/json"; Пысля цього у цієї сторінки буде тип контенту json. Це важливо, так як до цієї сторінки я у даному випадку звертаюсь за контентом. І дуже важливо який пив контенту вона віддає

 4) Помимо тих заголовків що має http, можна йому додавати кастомні заголовки (Я теж можу). Деякі з них стають популярними і є вже майже стандартними. 

	- curl_setopt($curl, CURLOPT_HTTPHEADER, ['X-HTTP-Method-Override: PUT']); - X-HTTP-Method-Override - замінити заголовок на PUT. У даному випадку я посилав дані методом пост. Але після цьго я вже звертався до ресерса методом PUT. І після цього у тому файлі до якого я буду звертатись курлом, можна буде витащити з масива put ці дані, які я йому PUT['some data']






























 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Структура МВС
	○ application
		□ contrlollers
		□ models
		□ views
	○ images
	○ styles
	○ .htaccess
		□ RewriteCond %{REQUEST_FILENAME} !-f
		□ RewriteRule !\.(js|gif|jpg|png|css)$ index.php-Картинки,стилі скріпти віддавати на пряму,остальне перенаправляти на index.php
	○ index.php (bootstrap)
		○ Инициализация
			□ путей по-умолчанию для поиска файлов - типу якшо файла не має, де ще його шукати. Внизу я пописав цю ситуацію
			□ необходимых конфигурационных	данных
			□ автозагрузки классов
		○ Инициализация FrontController
		○ Роутинг
		○ Вывод данных

-- Маршрутеризація
	- Вся інфа приходить через адресну строку http://домен/контролер/екшн(ф-ція по ходу)/параметр(цей параметр передасться екшну)/значення параметра
	- Воно ж і так спокатку йде на бутстраповський файл index.php (це на сервері налаштовується на який файл) і звідси вже все розрулюється

1) Контролер - обробляє запрос. Що хоче користувач, звідки він прийшов.. Авторизація наприклад, типу чи він зареєстрований чи ні. Коли він розібрав що до чого, він передає управління моделі.
	- Як правило, на сайті є 1 головний контролер FrontController (как правило, встроенный), інші кастомні. В файлы контролера я назначаю контролер. Якщо для контролера або екшна в мене є кастомний метод обробки назначаю його, якщо не має, назначаю дефолтний
	- Контролер - майже завжди singleton
	- Коли я обробляю строку є внегласне правило переводити першу букву імені контролера в верхній регістр 
	- те ж саме для екшна. Імя екшна з малої букви і прикріпити до нього слово Action // actionnameAction
2) Модель - працює з базою, з хмл




3) Пути по-умолчанию для поиска файлов - коли я указую шлях у ф-ціях звязаних з шляхом до файлів, є поняття як - шлях за замовчуванням. Типу fopen('filename', 'path'); Якщо цей шлях не підходить, php почне шукати з тої директорії, яка буде указана у path. Вона буде перевіряти всі поки не перевірить всі. Цей path знаходиться і htacsses і його можна знайти вивівши ф-цію phpinfo(); // include_path .:/usr/share/php (типу це шлях до index.php  хоча мабуть і не завжди). За замовчуванням тут не завжди 1 і понятне діло що на сервері наврядче у нього буде такий шлях
	- Щоб добавити альтернативні шляхи - set_include_path(get_include_path()':application/controllers (новий шлях)' І тепер якщо контролер знаходиться в sitename/application/controllers а я визвав його sitename/ він його знайде - require_once($class.'.php');


