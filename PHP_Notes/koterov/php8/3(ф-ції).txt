1) Обовязкові($x) параметри треба вказувати перед необовязковими($x = 10). Інакше буде помилка. 

2) начиная с версии РНР 8.1 значения по умолчанию могут выступать объекты class Kilogram {
										public function size ()
										{
											return 1_ООО;
										}
									   }
									   
									   function convert ( $value, $factor = new Kilogram () )
									   {
										return $value * $factor->size();
									   }
									   
									   echo convert (11) ; // 11000
									   echo '<br />';
									   echo convert (11, new Kilobyte ()) ; // Kilobyte - це теж класс, схожий на Kilogram. Я написав його тут для прикладу
																		   
3) Спред оператор. Є ф-ція sum, яка приймає 1 аргумент - function sum($items){}; А коли я викликаю її і додаю декілька аргументів, пхп візьме тільки перший, інші проігнорує. 

	- echo sum(1, 2, 3, 4); - Щоб пхп взяв всі аргументи (вони попадуть в масив), треба при обявленні ф-ції, перед $items, поставити ... - function sum(...$items){};
	
	- Якщо спред оператор вказати як аргумент, при виклику ф-ції, то він розпакує масив. Для прикладу вкажу сам масив, а не змінну, яка містить масив
	
		function add($a, $b) {
		    return $a + $b;
		}

		echo add(...[1, 2]); // 3
		
4) Починаючи з РНР 8.0 аргументи ф-ції можна передавати у будь-якому порядку. Головне, щоб аргумент співпадав іменем з параметра ф-ції. Щоб це зробити - треба вказати аргумент через :

	function convertToGrams ($value, $factor = 1_000)
		return $value * $ factor;
	}
	echo convertToGrams(factor: 1024, value: 11);
	
	- Ще фішка в тому, що це стосується і нативних ф-цій пхп. Кароче працює всюди.
	
5) У пхп є тепер фішка, коли ф-ція поверталє конкретний тип, а точніше приводила значення ф-ції у конкретний тип. Це ця байда з :int. Якщо пхп працює у звичайному режимі, то він приводить значення у конкретний тип так, як я звик - (==) мягке зрівнення або мягке приведення до якогось типу. Наприклад - int '22' => 22

	- Але якщо включити строгий режим типізації(strict _types = 1), то int '22' => 22 викличе РНР Fatal error - Argument must Ье of type int
	
6) Я писав про це в розділі класів, але і у ф-ціях це так само. Щоб задати параметр ф-ції null або int треба написати - function myFunction(?int $value)

	- Також вже в тілі ф-ції можна використати такий код - $value ??= 1000; Це те саме, що обрізаний тернарний оператор $value = $value ? : 1000; тільки не мало б бути помилки
	
7) Если функция не должна возвращать никакого значения, в качестве возвращаемого типа указывается - void

	- never - Функция либо вызывает конструкцию языка exit() або die(), либо выбрасывает исключение. Це наприклад можна використати при редіректі 301
	
	- Типи void і never використовуються тільки для повернення значень ф-цій. Не можна принудити якусь змінну до цих типів - function sayHello(void $name)
	
8) Не можна якиїсь змінній присвоїти масив $GLOВALS, але можна присвоїти по ссилці - $a = &$GLOВALS['а'];

	- Мабуть це і так зрозуміло, але коли я пишу у ф-ції global $а; - це всерівно, що $a = &$GLOВALS['а']; 
	
	- Це заплутано, але коли я створюю змінну $a, це я поміщаю в масив $GLOВALS['а']; Потім у ф-ції я звертаюсь до неї global $а; тим самим я ссилаюсь на $GLOВALS['а']; 
	
		$a = &$GLOВALS['а']; і коли я видаляю змінну $a у ф-ції - unset($а); цим самим я розриваю коннект між змінною та суперглобальним масивом. А $GLOВALS['а'] нікуди не дівається. Тобто поки є $GLOВALS['а'], я завжди можу до неї звернутись(echo $a), вона не видалилась
		
			- А коли напишу unset ($GLOВALS['а']); то змінна видалиться з суперглобального масиву.
		
9) Про це колись казав спеціаліст. Скріпт заносить ф-ції в карманчик і хранить їх там. Коли є ф-ція у ф-ції, то щоб пхп прочитав вложену ф-цію, треба залізти у оберточну ф-цію. І тоді пхп занесе внутрішню ф-цію у карман і її можна буде викликати у будь-якому участку кода.

10) Якщо ф-ція повертає строку або null, то можна написати function x() : ?string

11) Стрілочні ф-ції - це ті ж самі анонімні ф-ції, тільки компактіші.

	- Стрелочные функции всегда возвращают результат вычисления выражения. Тобто там є return; і його вказувати не треба інакше Fatal Error
	
	- $сuЬ = array_map( fn(int|float $n) => $n * $n * $n, [1, 2, 3, 4, S] ); // $cuЬ // [1 ,8 , 27, 64, 125]
