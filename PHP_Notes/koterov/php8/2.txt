1) $х = $х ? : 1; - Если переменная инициализирована - ее значение остается неизменным, если нет - ей присваивается единица

	- Начиная с версии РНР 8.0, обращение к неинициализированной переменной в таком контексте будет завершаться предупреждением РНР warning : Undefined variable $х. Чтобы не получить это предупреждение, потребуется задействовать конструкцию isset () - $х = isset ($x) ? : 1 ;
	
2) Оператор match зрівнює трьома ====. Це по суті оператор switch, але його результат можна поставити у змінну.

	- Конструкция match - возвращается первое найденное соответствие, после чего поиск прекращается
	
	- Щоб перевірити декілька варіантів на рівність - використоується кома - $date = new DateTime();
										 $day = match($date->format('М')) {
										 	'Jan', 'Mar', 'Apr', 'Jul', 'Aug', 'Oct', 'Dec' => 31,
										 	'Apr', 'Jun', 'Sep', 'Nov' => 30,
										 	'Feb' => 28,
										 };
										 
	 	- Якщо б $date->format('М') замінити на якусь біліберду, типу тумбаюмба, це приведе до РНР Fatal error: Uncaught UnhandledМatchError : Unhandled match case; Тобто якщо немає співпадінь, буде помилка.
										 
	 - До цього я завжди клав у конструкцію switch() i match() якусь змінну у дужки, щоб перевірити її case-ом або у випадку match (назву це внутрішніми змінними). Але як і у випадку з switch() так і у випадку з match() - у їх дужки котеров кладе true, і перевіряє змінну, яку він задав трохи вище. Херово пояснив, знаю. Суть у тому, що конструкції switch() i match() можуть працювати зі змінними, які не у їхніх дужках, а обявлені поза конструкціями.
	 
	 										$number = 120;
											$x = match (true) { 
												$number > 0 && $number <= 10 => "$number меньше 10 и больше 0",
												$number > 10 && $number <= 100 => "$number меньше 100 и больше 10",
												$number > 100 && $number <= 1000 => "$number меньше 1000 и больше 100",
												$number >= 1000 => "$number больше 1000 или меньше 0"
											    };
										    	// $x присвоїться ->120 меньше 1000 и больше 100
	 
	 - Поскольку в качестве ключей и значений могут выступать любые выражения, можно задействовать даже функции -   $str = 'Hello, PHP!';
															$arr = [1, 2, 3, 4, 5];
															$obj = new DateTime();

															$arg = 'string';
															
															echo match($arg) {
															    gettype($str) => $str,
															    gettype($arr) => print_r($arr),
															    gettype($obj) => var_dump($obj)
															}; // Hello, PHP!
		
		- Тобто gettype($str) - це 'string'
		- Якщо присвоїти це все, типу $x = match ($arg), то $x буде містити те, що у змінній $str  // Hello, PHP!

3) Якщо у речення з подвійними лапками підставляти значення масиву, то не треба обрамляти лапками змінну масиву - $arr['one'] = 14; // "Событие произошло $arr[one] дней назад";

	- Однако в случае многомерных массивов интерполировать элемент уже не получится - $arr[0][0] = 14; Тому треба або брати значення у фігурні дужки {} або конкатинувати
	
4) list() - Раніше я писав, що можна присвоювати тільки результат ф-ції. Тепер по ходу це змінилось. $arr = [1, 2, 3]; list($one, $two, $three) = $arr; 

	- Начиная с версии РНР 7.1 , конструкцию list() можно заменять на квадратные скобки [$у, $х] = [$х, $у];
	
	- Конструкция list() работает только с числовыми массивами, нумерация индексов которых начинается с нуля.
	
5) Злиття масивів за допомогою оператора +; $sum = $fst + $snd; - $fst і $snd; - це масиви. Якщо у них будуть одинакові ключі(key), то при злитті залишиться ключ з масиву $fst тому, що він зліва.

6) Дивна поведінка пхп. Якщо зрівнювати 2 масиви по значенням, то поведінка стандартна(ключі мають бути одинакові і щоб пройшла перевірка на ===, значення мають бути одного типу). Але з ключами не так. Ось 2 масиви -  $fst = [1 => 1, 2 => 2];
				$snd = [1 => 1, '2' => 2];
				$fst === $snd // true; Недивлячись на то, що '2' - строка.
				
7) Ф-цій пошуку по масивах є такий великий діапазон, що мені лінь описувати. Головне знати, що якщо я хочу знайти щось у масиві, можна глянути доку.


