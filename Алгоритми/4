
 ------------------------------ Глава 5 - Хеш таблиці -----------------------------

 1) Хеш таблиці - це якась прослойка між тим хто запрашує дані і даними. У хешах храниться лінка на дані. На вході хеш получає строку, а видає цифру - http://joxi.ru/8AnEVnwuzW4z82. 

	- Итак, хеш-функция связывает строки с числами. Типу я питаю у хеша - де у масиві храниться #element - Він каже - у масиві у 3-му індексі. А як я памятаю читання з масива мгновенне. Тобто не треба вже бінарний пошук - тут швидкість блискавична O(1).

	- Мені ніколи не прийдеться реалізовувати хеш таблиці. Вони вже є у кожній мові програмування. Наприклад масиви. Це коли я по ключу витягую значення. Тобто ця операція прохдить швидко.

 2) Хеш таблиця це і є ключ - значення. Якщо я добре зрозумів, то це просто паралельні масиви коли у одному храниться ключ а у іншому значення. Але поки я не можу зрозуміти за рахунок чого така швидкісь. Ключі ж теж треба шукати

	- Це теж поки не розумію чому і нашо воно знадобиться. Очень важно, чтобы хеш-функции были последова­тельными, то есть неизменно возвращали один и тот же результат для одинаковых входных данных. Тобто #element завжди буде повертати 3, #element2 завжди буде повертати 2. Якщо цього не буде, все похериться

 3) Друга аналогія яку можна привести - це номера контакти в телефонній книзі - хеш(імя контакта) і значення на яке веде хеш (номер телефона)

	- Або домен і апішка - google.com == 74.125.239.133

 4) Також кеші використовуються для кешування. 

	- Це вже від себе. Я бачив як хранятся кеші у мадженті. Вони хранятся в масиві. Цей автор теж у якості прикладу кеша приводить масив і обєкт (стукають до ключа, получаю значення). Тож мабуть не треба дивуватись шо маджента хранить кеші у масиві. Мабуть це правильно



 ----- Коллизии ----

 1) Кароче хеші використовують масиви для збереження даних. Швидкість запису і читання масиву я вже знаю. Тобто є 33 товарів і масив у якому 33 ячейок. Якщо кожен елемент розмістити у масив, у мене буде швидкість читання O(1). І коєфіцієнт заповнення масиву - 1 (якщо буде масив з 3-ма ячейками і тільки одна ячейка буде заповнена - коєфіцієнт буде 1/3 (1 ділити на 3)).

	- Я про це писав коли предполагав як дістаються дані з бази у фейсбук. У хешах так само. Наприклад всі мої 33 товарів мають назву алфавітних букв, ну або перша буква - соотвецтвенно я даю хеші кожному товару і розкладаю товари по ячейках - http://joxi.ru/D2PzQoZiq6eoKr

		- Хеш відіграє роль сірі або гугла який все знає. http://joxi.ru/l2Z46oyTzL5vOr - Я до нього стукаюсь, вказуючи хеш,а він повертає мені ячейку масива у якій хранятся дані.

	- Але що якщо у мене буде 2 товвари на оду букву? Якщо я запланував спочатку що всі мої ячейки будуть хранитись по алфавіту і 2 хеші (апельсин, авокадо) ведуть на одну ячейку - це називається колізією. Зазвичай з нею боряться так як я вже писав у перших главах - В одну ячейку масива запихують ЗВЯЗАНИЙ СПИСОК - http://joxi.ru/bmoEVXwu3dLp9A

 2) Тепер я вроді поняв хеш - це ф-ція set/get - яка добавляє дані у маси і бере дані з масива. Тобто програмісту вже дається тільки ці 2 методи (ці ж самі масиви). А вже як це реалізовано, це вже не до програміста - це лоу левел ленгвіч. Але всеодно трохи опишу головні принціпи.

 	- хеш-ф-ція - яка буде кидати всі елементи у одну ячейку масива (а у ячейці соотвецтвенно всі дані будуть хранитись звязаним списком) - це дуже херова хеш ф-ція. треба максимально порівну розприділити дані по масиву - http://joxi.ru/Dr8RE7kCovqjJ2

 3) В загальному вважається що пошук через хеш-ф-ції проходить за час - O(1). Час O(1) називається постоянним. Постоянний він із за того що який би не був довгий масив, пошук в ньому завжди буде за час - O(1)

 4) Хорошою практикою вважається міняти хеш-таблицю коли коєфіцієнт більше 0.7



  ------------------------------ Глава 6 - Поиск в ширину -----------------------------

 1) Поиск в ширину - алгоритм для роботи з графами. Поиск в ширину позволяет найти кратчайшее расстояние между двумя объ­ктами. Але це більш обширне поняття. Наприклад за допомогою "Поиск в ширину" можна написати гру в шашки (тобто коротший шлях для перемоги).

 2) Я вже писав раніше про алгоритм пошуку оптимального маршруту між різними містами. Тут я напишу ще один алгоритм - http://joxi.ru/Y2Lz0oWi7q4jOr - Вы намереваетесь доехать на автобусе с минимальным количеством пересадок. Тобто є декілька поінтів і щоб добратись до якогось поінта мені треба 1 степ - Задача такого типа называется задачей поиска кратчайшего - тобто знайти мінімальну к-сть степів щоб добратись до цілі.

 3) Для пошуку в ширину мені треба зробити граф. Граф моделирует набор связей між поінтами, по яких мені треба пройтись - http://joxi.ru/VrwElJwu7kEVG2 - це граф гри в покер. Тобто хто кому винен на даний
 момент.

	- Каждый граф состоит из узлов и ребер - http://joxi.ru/nAyv8gwUgb0YNr

	- Узел может быть напрямую со­единен с несколькими другими узлами. Эти узлы называются соседями. http://joxi.ru/l2Z46oyTzLPERr - Адит соседом Алекса не является, потому что они не соединены напрямую . При этом Адит является соседом Рамы и Тома.

 4) Тобто Поиск в ширину работает с графами. Он помогает ответить на вопросы двух типов:

	- тип 1: существует ли о путь от узла А к узлу В?

	- как выглядит кратчайший путь от узла А к узлу В?

 5) Щоб взнати шо таке "Поиск в ширину" можна провести аналогію. Я шукаю серед друзів у фейсі хто продає манго. І алгоритм який мені треба буде побудувати, це пройтись по друзях і запитати в них чи вони продають манго. Якщо жоден з них не продає манго, треба буде пройтись по друзях друзів. Типу мій друг Аліса продає? Так -> завершити пошук. Ні -> продовжити пошук по її друзях - http://joxi.ru/82QB5lacwpo3EA . Це і є широкий пошук. Тобто

	- тип 1: существует ли о путь от узла А к узлу В? (Есть ли продавец манго в вашей сети?) - Це по ходу означає чи у текущого друга є якісь друзі щоб додати і їх у список перевірки

	- как выглядит кратчайший путь от узла А к узлу В? (Кто из про­давцов манго находится ближе всего к вам?) - Якщо глянути у ф-цыю, яку я написав нижче, буде быльш зрозуміло. Я так поняв, що цей кратчайший путь це буде результат ф-ції пошука продавця манго. Тобто я спочатку шукаю продавця серед друзів, потім серед друзів друзів і тд. В рерультаті я кщо я когось зайду, то в мене буде кратчайший шлях як знайти цього продавця - зайти до другі Івана, в нього в друзях є Вася, а у васі є друг Рафік, який займається продажами манго 

 6) Продовжуючи аналогію - мої друзі - це звязки першого рівня, друзі друзів - звязки другого рівня. Пошук не перейде на 2-й рівень, поки він не закінчиться на першому рівні і так далі (3-й, 4-й рівень)

 7) Це що провірка відбувається спочатку на першому рівні, потім на другому ... позитивно вліяє на проізводітельность. Тобто це що спочатку я добавляю всоїх друзів у список провірки, потім друзів друзів і тд - це називається ЧЕРГОЮ. Коли є черга, я впевнений що я не буду перевіряти спочатку 3-й рівень, потім 1-й. Черги трохи нагадують стеки.

 8)  Если вы поставите в очередь два элемента, то элемент, добавленный пер­вым, будет извлечен из очереди раньше второго. А ведь это свойство можно использовать для реализации списка поиска! Люди , добавленные в список первыми, будут извлечены из очереди и проверены первыми - http://joxi.ru/12Mzjodil1PRGA - First In, First Out («первым вошел, первым вышел»).

	- На практиці це буде виглядати так - http://joxi.ru/E2pEgxwu7xL33A - шукаю коротший шлях до кінця. Граф вже побудований. S має 2-х сусідів (вузли, до яких веде одне ребро). Проходжусь по сусідах, і питаю в них чи вони це кінечна точка. Соотвецтвенно вони першими зайшли в чергу для пошуку. Жожен з них не являється кінечною точкою. Потім проходжусь по сусідах і перший сусід, має сусіда який являється кінечною точкою. Програма закінчена. Довжина коротшого шляху до кінця = 2 (степи) 

 ------ Реализация графа --------

 9) Як це все реалізовується в програмуванні. Наприклад є вузел і він має 3-х сусідів. Пройшовши главу по хеш-таблицях можна уявити як вони будуть звязуватись. У мові програмування скоріш за все це буде масив і ключ з вузлом. Якщо цей вузел має сусідів, то ці сусіди будуть хранитись у цьому вузлі - http://joxi.ru/4AkgeRYfolpPyA - (масив у якому ключ, а у ключі буде хранитись масив з сусідами). Вже можна уявити як буде йти пошук і що таке левели.

	

	Тобто graph['you'] = буде хранити всії сусідів. Як хеш або лінка. Стукаєшся до мене - получаєш сусідів. Але не суть. Думаю крім хеша, у мені можна хранити і іншу лінку. Суть у тому, що я главний і від мене проісходять сусіди (як родове дерево, батьки гллавні як як. Щоб получити мене, треба стукатись через батьків - http://joxi.ru/vAWzZoxiglbPR2 - Такая особая разновидность графа, в которой нет ребер, указывающих в об­ратном направлении, называется ДЕРЕВОМ.). Тобто у мене буде лінка на моїх сусідів, а у них на мене не буде лінки (хіба що вони будуть у мене у друзях. Саме тому важливо робити перевірки на елементи які вже були провірені. Наприклад як тут, що у друзів я є у друзях. При провірці друзів, воно знайде мене і від мене знов почнеться перевірка всіх моїх друзів - ТОБТО ЗАЦИКЛЕННЯ і так до безкінечності.)

	- Так буде виглядати більш складний граф з сусідами сусідів - http://joxi.ru/Y2Lz0oWi7q5Qwr

		graph = {}
		graph [ "you"] = [ "alice", " ЬоЬ", "claire"]
		graph("bob"] = ("anuj", "peggy"]
		graph["alice"] = ["peggy"]
		graph["claire"] = ["thom", "jonny"]  18 - 21
		graph["anuj"] = []
		graph["peggy"] = []
		graph["thom"] = []
		graph("jonny"] = []

		- У Ануджа, Пегги, Тома и Джонни соседей нет. Линии со стрелками ука­зывают на них, но не существует стрелок от них к другим узлам. Такой граф называется направленным - отношения действуют только в одну сторону. Итак, Анудж является соседом Боба, но Боб не является соседом Ануджа. Можливо щоб краще зрозуміти - через Боба я можу витягнути Анужа, але через Анужа я не витягу Боба. Це то що я писав про родове дерево вверху.

		- Але крім НАПРАВЛЕНОГО графіка є НЕНАПРАВЛЕНИЙ. В ненаправленном графе стрелок нет, и каждый из узлов являет­ся соседом по отношению друг к другу. Например, оба следующих графа эквивалентны - http://joxi.ru/ZrJzyo5iwDpRVr - коли оба хранять лінку один на одного. Це за такі випадки я писав вверху про зациклення. Оба ці єелементи безкінечно будуть ссилатись один на одного, тому дуже важливо робити перевірки - якщо елемент вже перевірявся, більше його не перевіряти.

 10) Порядок добавлення вузлів(елементів у масив) не має ніякого значення. Тут те саме як з масивами або з хеш-таблицями.

	graph["claire"] = [ "thom", "jonny"]
	graph["anuj"] = []

	швидкісь буде така сама як і

	graph["anuj"] = []
	graph["claire"] = [ "thom", "jonny"]

 12) Тепер як це реалізувати в коді (http://joxi.ru/E2pEgxwu7xZwaA - цю логіку буду реалізовувати). Шукаю чи хтось з друзів моїх друзів - продавець 

	function person_is_seller(name) { - метод який перевіряє ци персона - продавець.
	    return name[name.length - 1] === "m";
	}

	const graph = {}; 

	graph["you"] = ["alice", "bob", "claire"]; - мої друзі. 

	друзі друзів
	graph["bob"] = ["anuj", "peggy"];
	graph["alice"] = ["peggy"];
	graph["claire"] = ["thom", "jonny"];

	друзі друзів друзів
	graph["anuj"] = [];
	graph["peggy"] = [];
	graph["thom"] = [];
	graph["jonny"] = [];



	function search(name) {
	    let search_queue = [];
	    search_queue = search_queue.concat(graph[name]); - search("you"); - отже шукаю всіх друзів "you" - це при першому запуску ф-ції - ["alice", "bob", "claire"];

	    // This array is how you keep track of which people you've searched before.

	    const searched = []; - Тут буду хранити всіх друзів яких я провірив щоб не було зациклення

	    while (search_queue.length) { - тут вже 3 друзі 'you'. Поки я не провірю всіх друзів друзів, цикл буде крутитись.
		let person = search_queue.shift(); - видаляю перший елемент зі списку пошуку і потім з ним буду працювати. Але це що я його видаляє - це реалізація first in first out

		// Only search this person if you haven't already searched them
		if (searched.indexOf(person) === -1) { - Якщо ця персона ще не проходила провірку чи вона є продавцем (щоб не було зациклення)

		    if (person_is_seller(person)) { - Якщо цей чувак продавець - ф-ція завершиться
		        console.log(person + " is a mango seller!");
		        return true;
		    }

		    search_queue = search_queue.concat(graph[person]); - всі друзі друга, який пройшов провірку і виявилось що він не підходить додаються в кінець спика в якому я шукаю продавця. А враховуючи те що провірка починається з початку списка завжди, то це реалізація first in first out

		    // Marks this person as searched
		    searched.push(person); - Додаю чувака який пройшов провірку на продавця і виявилось що він не продавець у список провірених людей. По ньому я буду чекати людей яких я вже провірив щоб не було зациклення 
		}
	    }
	    return false;
	}

	search("you"); // thom is a mango seller!

	- Це основа реалізації - http://joxi.ru/Q2Kz7o6iLqBpdm - це постепова реалізація - http://joxi.ru/LmG9DozuwDajMA

	- Це коли я поступово розширяю круг пошуку - це і є ПОШКУ В ШИРИНУ

	Таким образом, время выполнения ПОШУКА В ШИРИНУ составляет как минимум О( количество ребер).

 13) Таким чином добавлення одного елемента в список пошуку займає О(1) і перейти від одного елемента до іншого теж займає час О(1). Можна сказати що Поиск в ширину выполняется за время О(количество
людей + количество ребер), что обычно записывается в форме количество вершин , Е - количество ребер).

 14) Щоб краще зрозуміти графи - http://joxi.ru/YmEzDojiwqpkB2 - Тут є розпорядок дня. Просипаюсь я завжди з самого початку. Від цього будуть залежати всі інші елементи. Я можу прийняти душ або почистити зуби в будь якому порядку, це не має значення. А от позавтракать я завжди буду робити останнім, так як він знаходиться на 2-му рівні.

	- Або інший приклад розпорядку дня http://joxi.ru/RmzEkMwuYwokLr . Я не можу одягнутись поки поки не зроблю ритуали які йдуть перед ним.

		- Можно сказать, что этот список в некотором смысле отсортирован. Если задача А зависит от задачи В, то задача А находится в более поздней по­зиции списка. Такая сортировка называется топологической ;


	











 
