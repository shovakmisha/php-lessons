
 ----------------------------------- Жадные алгоритмы ------------------------------------

 1) Жадний алгоритм дуже простий. Завжди треба брати підходящий варіант а потім теж брати варіант який найбільше підходить. Зачасту це найкраще що може бути. Так він не завжди підходить, але це работає. 

	- Нприклад мені треба піти на максимальну к-сть лекцій. І зачасту вони йдуть паралельно. Я просто беру першу яка скрше за всіх завершиться і йду на неї, потім вибираю ті які починаються після цієї і по тому ж принципу (яка скоріш за всіх завершиться)

 2) Задача. Я хочу щоб моя програма яку я веду по радіо була у максимально всіх штатах. Тож мені треба піти на радіостанції, які охватують декілька штатів і продати їм свою програму. Але так як я нищеброд, то я не можу продати всім станціям. Тож задача в тому щоб мінімалька к-сть радіостанцій охватувала максимальну к-сть штатів - http://joxi.ru/l2Z46oyTzaYDOr 

 - Как найти минимальный набор станций, который бы покрывал все 50 штатов? Вроде бы простая задача, верно? Оказывается , она чрезвычайно слож­на. Вот как это делается точним алгоритмом:

	1. Составить список всех возможных подмножеств станций 	так называемое степен.н.ое множество. В нем содержатся O(2 ^n) (2 в степені к-сті штатів) возможных подмножеств.

		- Тобто якщо штатів мільйон, то 2 в степені мільйон - це піздец, роки пройдуть

	2. Из этого списка выбирается множество с наименьшим набором станций, покрывающих все 50 штатов.


 - Тут на допомогу приходять жадні алгоритми. Його ще називають приближеним із за того що він не точний, але як бачу краще так як скріпт який роками буде вибирати штати. І ф-ла швидкості тут вже набагато краща O(n^2) n в сепені 2

	1. Выбрать станцию, покрывающую наибольшее количество штатов, еще не входящих в покрытие. Если станция будет покрывать некоторые штаты, уже входящие в покрытие, это нормально.

	2. Повторять, пока остаются штаты, не входящие в покрытие.

 ------------------------------ ответвление про множества ---------------------------
 
 - Множества не мають дублікатів. Якщо з цого масиву зробити множество - arr = [1, 2, 2, 3, 3, 3], буде [1,2,3]

 - С двумя множествами можно выполнить ряд интересных операций

	- обєдинити - Якщо в 2-х множествах є одинакові елементи, то при зєднанні, вони оба будуть у списку

	- Пересичение - Виявляю одинакові елементи у 2- множествах

	- Разность - Виявляю елементи які не схожі. Цю операцію можна робити в 2 сторони. Можу забрати всі елементи з першого множества які не такі як у другого і навпаки.

		Под разностью множеств понимается исключение из одного множества элементов, не присутствующих в другом множестве.

 ------------------------------------------------------------------------------------

 - Автор використав множества щоб упростити приклад

    let states_needed = new Set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"]); // штати які мені треба покрити

    const stations = {}; // радіостанції. Назва => штати які вона покриває

    stations["kone"] = new Set(["id", "nv", "ut"]);
    stations["ktwo"] = new Set(["wa", "id", "mt"]);
    stations["kthree"] = new Set(["or", "nv", "ca"]);
    stations["kfour"] = new Set(["nv", "ut"]);
    stations["kfive"] = new Set(["ca", "az"]);

    const final_stations = new Set(); // тут будуть хранитись станції, коли ф-ція завершить роботу


    while (states_needed.size) {

        let best_station = null;
        let states_covered = new Set(); - Тут беде список всіх штатів які вже покриті

        for (let station in stations) {


            let states = stations[station];

            let covered = new Set([...states_needed].filter((x) => states.has(x))); // вибираю станцію яка покриває найбільшу к-сть штатів, але тільки тих які мені треба. Тобто в мене ізначально був масив з потрібними штатами, але кожного разу як я буду вибирати станцію яка покриває найбільшу к-сть штатів з тих які мені потрібно, список цих штатів буде викреслюватись зі списку states_needed

		- Таким образом, covered - содержит множество штатов, не входящих в покрытие(states_covered), которые покрываются текущей станuией!

            if (covered.size > states_covered.size) { // - Це як я буду кожного разу проходитись по станціях, якщо ця станція покриє більше штатів як всі інші станції(взагалі всі станції що є в списку ізначально)...
                best_station = station; - // я візьму її в змінну
                states_covered = covered; // і також візьму в змінну штати які вона покрила
            }
        }
        states_needed = new Set([...states_needed].filter((x) => !states_covered.has(x)));  // викреслюю зі списку штатів які мені треба покрити ті які покриває текуща станція. 

        final_stations.add(best_station); // добавляю цю станцію в список. І все вона вже не видалиться зі списку, якщо я її тут додав. Тобто як бачу принцип дуже простий. Дивлю, ага - на даний момент ця станція покриває найбільшу к-сть штатів що мені треба - супер - добавляю її в список і вона там і залишиться. А тим часом штатів які мені треба покрити стає все менше. Трохи туповато, але работає
    }

    console.log(final_stations); // Set { 'kone', 'ktwo', 'kthree', 'kfive' }

 - Зрівнення жадного і точного алгоритму - http://joxi.ru/823dpX3T9Xp4PA





 Кынечним результатом ф-ції буде станції, які охватують максимальну к-сть штатів
