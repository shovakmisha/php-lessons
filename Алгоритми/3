
 ---------------------- Глава 4. Быстрая сортировка ---------------------------

 1) Як сортується масив швидкою сортіровкою

	- Помните: мы используем стратегию «разделяй и властвуй» . Следователь­но, массив должен разделяться до тех пор, пока мы не придем к базовому случаю. Алгоритм быстрой сортировки работает так: сначала в массиве выбирается элемент, который называется опорным - хай буде перший елемент в масиві, але потім я розпишу як краще вибирати опорний елемент.

		- Базовий випадок - це якраз і буде коли в мене є 1 елемент точки опори, справа буде пустий масив або 1 елемент більший за точку опори, а зліва буде пустий масив або 1 елемент менший за точку опори. Тобто в одному степі я зможу працювати максимум з 3-ма елементами масиву. І весь функціонал зводиться щоб звести до цього випадку.

			- Хоча якщо често то базовий це коли взагалі сортувати не треба, тобто це стопор рекурсії - пустий масив або масив з одним елементом. При стопорі можна буде не запускати рекурсію а повернути пустий масив або масив з одним елементом

	- Теперь мы находим элементы, меньшие опорного, и элементы, большие опорного. І в результаті в мене буде 2 підмасиви. Цей процес називається розділенням.

	- Якби ці підмасиви були відсортовані, то можна було б просто скласти опорний елемент, элементы, меньшие опорного, и элементы, большие опорного і в результаті в мене був би відсортований масив. Логічно було б предположити що опорний елемент треба брати десь з середини.

 2) З прикладом краще це зрозуміти


	function quicksort(array) {

	// Оприділяю базовий випадок, коли не треба сортувати масив - це коли у масив пустий або у масиві 1 елемент. 
	  if (array.length < 2) {
	    return array;
	  }

	  // recursive case. Не знаю чому автор назвав це рекурсивним випадком. Це ж точка опори по якій я буду ділити масив на 2 підмасиви.
	  let pivot = array[0];

	  // Підмасив елементів менших за точку опори
	  let less = array.slice(1).filter(function(el) { - Кожний степ рекурсії буде вирізати з масиву перший елемент (1-й елемент буде точкою опори) і проходитись по всіх елементах масиву і шукати елементи, які менші за за нього. ці елементи будуть знаходитись у масиві  less (Якщо не понятно, можна загуглити ф-цію filter - http://joxi.ru/l2Z46oyTzLRMDr)
	    return el <= pivot;
	  });

	  //  Підмасив елементів більших за точку опори
	  let greater = array.slice(1).filter(function(el) { - Кожний степ рекурсії буде вирізати з масиву перший елемент (1-й елемент буде точкою опори) і проходитись по всіх елементах масиву і шукати елементи, які більші за за нього. ці елементи будуть знаходитись у масиві  greater
	    return el > pivot;
	  });

	  return quicksort(less).concat([pivot], quicksort(greater)); - І так до кінця рекурсії. буде складуватись ліва частина від точки опори + точка опори + права частина від точки опори. Коли рекурсія розмотається, кінечною точкою буде і зліва і з праві буде або пустий масив або масив з одним елементом. І на обратному путі рекурсії вони будуть додаватись.

		- Те що воно буде работати - це ДОКАЗАТЕЛЬСТВО ПО ИНДУКЦИИ. Суть у тому, що мені теж треба оприділити базовий випадок і індукційний переход. Наприклад щоб доказати що я можу піднятись по сходах(всі сходи одинакові), мені треба знати що я можу піднятись на першу ступеньку. Якщо це є, то треба оприділити індукційний переход - на одну ступеньку вверх. І коли в мене є ці 2 умови я можу сказати що по сходах я піднімусь. Це і є ДОКАЗАТЕЛЬСТВО ПО ИНДУКЦИИ

			- При сортуванні масивів ДОКАЗАТЕЛЬСТВО ПО ИНДУКЦИИ теж работає. Також тут діє принцип розділяй і володій. Я вже знаю, що я можу за 1 степ відсортувати масив з 3-х елементів. Все що мені залишається це розділити великий масив  і рекурсивно проходитись по маленьким його частинах. Спочатку я беру довільну точку опори у великому масиві, більші за точку опори кидаю справа, менші зліва, потім роблю те саме з цими підмасивами що стоять справа і зліва.

			- У цій ф-ції я зробив те саме. Оприділив базовий кейс - то що якщо у мене буде точка опори, зліва 1(або 0) елементів, і з права 1(або 0) елементів - то якщо я їх складу, в мене буде відсортований масив. Індукційний перехід у цьому випадку має мене приводити до базового випадку. Тобто якщо в мене є великий масив, при кожному переході(степу рукурсії), має залишатись менше елементів
	}

	console.log(quicksort([10, 5, 2, 3])); // [2, 3, 5, 10]

	- розпишу по степах. Це ця ж сама ф-ція

		function quicksort(array) {
		  if (array.length < 2) {
		    return array;
		  }

		  let pivot = array[0];

		  let less = array.slice(1).filter(function(el) {
		    return el <= pivot;
		  });

		  let greater = array.slice(1).filter(function(el) {
		    return el > pivot;
		  });

		  return quicksort(less).concat([pivot], quicksort(greater));
		}



		- console.log(quicksort([6, 9, 1, 4, 10, 5, 2, 3]));

			- пішла перша рекурсія

			function quicksort([6, 9, 1, 4, 10, 5, 2, 3]) {
			  if (array.length < 2) {
			    return array;
			  }

			  let pivot = array[0]; // 6

			  let less = array.slice(1).filter(function(el) { // 1,4,5,2,3
			    return el <= pivot;
			  });

			  let greater = array.slice(1).filter(function(el) { // 9, 10
			    return el > pivot;
			  });

			  return quicksort([1,4,5,2,3]).concat([6], quicksort([9, 10])); // тобто запустяться 2 ф-ції
			}

				- пішла друга рекурсія, спочатку ліва

				function quicksort([1,4,5,2,3]) {
				  if (array.length < 2) {
				    return array;
				  }

				  let pivot = array[0]; // 1

				  let less = array.slice(1).filter(function(el) { // Тут пусто так як не має меншого за 1
				    return el <= pivot;
				  });

				  let greater = array.slice(1).filter(function(el) { // 4,5,2,3
				    return el > pivot;
				  });

				  return quicksort([]).concat([1], quicksort(4,5,2,3)); // Тут ліва вже не буде работати, вона завершила роботу і поверне пустий масив.
				}

					- Це вже работає права частина лівої ф-ції

					function quicksort([4,5,2,3]) {
					  if (array.length < 2) {
					    return array;
					  }

					  let pivot = array[0]; // 4

					  let less = array.slice(1).filter(function(el) { // 2,3
					    return el <= pivot;
					  });

					  let greater = array.slice(1).filter(function(el) { // 5
					    return el > pivot;
					  });

					  return quicksort([2, 3]).concat([4], quicksort(5)); // права частина вже не буде работати, вона поверне значення 5
					}

						function quicksort([2,3]) {
						  if (array.length < 2) {
						    return array;
						  }

						  let pivot = array[0]; // 2

						  let less = array.slice(1).filter(function(el) { // нічого
						    return el <= pivot;
						  });

						  let greater = array.slice(1).filter(function(el) { // 3
						    return el > pivot;
						  });

						  return quicksort([]).concat([2], quicksort(3)); // права частина вже не буде работати, вона поверне значення 5
						}

				--------------------------------------------------------

				Ліва частина завершила свою роботу

				- Якщо пройтись знизу вверх, буде - 2, 3 - це повернула остання. Вона буде зліва

									- 2, 3, 4, 5 - це повернула передостання 

										- 2, 3, 4, 5 - це повернула передостання 

											- 1, 2, 3, 4, 5 - це повернула перша 

				- Масив [1,4,5,2,3] відсортувався за 3 степи

				--------------------------------------------------------

				- Праву частину не буду розписувати, вже понятно як це работає



	- Може так буде понятніше. В мене є масив - [10, 1, 2, 3, 100, 200, 300]

		- Я беру перший елемент у масиві - 100 і всі елементи менші за нього ставлю вліво, всі елементи більші за нього ставлю вправо. І все 100 вже не участвує у рекурсіях, він вже тільки додастья в масив, на обратній дорозі, коли масиви зліва і справа посортуються - [left] + 100 + [right]

		- Потім це саме буде робитись для остальних двох масивів.

		- Можна тільки уявити яким хаосом це сортується ------------------------------------------------------ якось так мабуть. Це я пробував описати стек
									--4--   ---8---			----70---
									 - -	 -- --			 ---  ---
									  -	  - -			  -- --
										   -			   - -
								 	   				    -
		- З цього мого супер пупер графіка що я написав, можна зрозуміти, що хоча це і швидже ніж перевіряти всі елементи масиву, це не світлова швидкість
									
 


 3) Ця робота що я описав, відбувається, якщо точка опори - 1-й елемент в масиві. Від точки опори залежить швидкість виконання.

 4) На даний момент я знаю всі ці 5 алгоритмів - http://joxi.ru/L216bOacRawR8A

	- задача о коммивояжере - це задача про то шо у мене я якесь n к-сь міст де мені треба побувати. І алгоритм щоб обїхати їх пошвидше буде n факторіал - якщо n = 5, то (5*4*3*2*1). Так, це важкий алгоритм але поки ніхто краший не придумав. Позначається він - O(n!) - n факторіал. Тобто щоб знайти шлях найшвидше обїхати 5-ти міст, треба буде зробити 120(5*4*3*2*1) операцій 

		- http://joxi.ru/Dr8RE7kCovKzE2

	- Алгоритм Быстрая сортировка ще називають алгоритмом сортировка слиянием (це не факт, просто я так поняв так як у них були одинаковы ф-ли). Як видно на графіку, він швидший з сортіровку вибором про яку я писав раніше (глава 2)

		- В худшем случае быстрая сортировка работает за время О( n(2) ). Тобто n в квадраті - те саме що і сортіровка вибором. Але це в гіршому випадку, в середньому вона займе O(n * log n) Чому так?

			- Якщо алгоритм швидкого сортування получає відсортований масив - quicksort([1,2,3,4,5,6,7,8]); то він відпрацює 8 разів - http://joxi.ru/5mdgM6Ef30q0Nr - це легко перевірити ф-цією яку я писав вверху. Тобто зліва від опорного числа завжди оказується пустий масив. 

				- Тобто при кожному степі він буде проходитись по всіх елементах які залишились справа і на 8-му степі залишиться 1. Це дуже нагадує сортування вибором де я сортував авторів пісень по популярності, там я теж не розумів чому О велике у цьому випадку n у квадраті - у моєму випадку 8 * 8. Я і тоді не розумів чому 8 множиться на 8 так як понятно що на останньому степі рекірсії я не буду перевіряти 8 елементів, там залишиться тільки 1. В тут краще б підійшло n * (n * 0.5 ). Автор обіцяв пояснити потім чому так.  

				- http://joxi.ru/zANzVoLivy1VXA - Так буде якщо я брав би завжди середне значення - вже 4 степи. Із за того що масив завжди ділиться на 2 

				- Тобто у кращому випадку сортування О - велике буде O(log n) (тому що масив завжди ділиться на 2 - типу в мене був такий масив [1,2,3,4,5,6,7,8] я вибрав середне значення 4 і в мене будуть 2 масиви [1,2,3]) + 4 + [5,6,7,8] і т д. Соотвецтвенно складуватись вони будуть теж як степені - 2 4 8 16 ... - Ось чому log(2) n - тобто скільки двійці треба перемножитись щоб отримати число яке == к-ті елементів в масиві при кожному спепі рекурсії.  

				- а у гіршому O(n(2)) (тому що візьметься кожен елемент масива, тому що я беру перший елемент і не буду ділити масив на 2 частини) - http://joxi.ru/5mdgM6Ef30q0Nr

 5) !!!! АЛЕ!!! Не дивлячись на то, що масив ділиться на 2 чистини, я в будь якому випадку в кожному степі рекірсії буду проходитись по всіх елементах масива потім підмасива і тд щоб знайти найменше значення. Тож - log(2) n тут не дуже підходить. Тому що вроді як масив ділиться на 2, але всерівно по кожному з його елементів я буду проходитись. 

	- Це вже отсебятіна, але я думаю що автор мав це написати. Він це і писав, але в контексті - не прямим словом. Питання в тому - чому цей метод пришвидшуж роботу????. З самого початку, коли я писав цю швидку сортіровку я не міг зрозуміти, чому тут log(2) n - вона ж не підходить. Понятно що вона підходить при бінарному пошуку так як там я завжди беру половину а іншу половину відкидую. Там понятно чому це діє - 2 4 8 16 ... Але тут я не відкидую половину масиву, я розділяю масив на 2 частини і працюю з кожною частиною. І сортування не йде многопоточне. Так само як і всі - в 1 стек складується блок за блоком. А швидший цей метод із за того що з графіку понятно, що чим більший масив, тим погіршується час роботи. Тобто якщо точка опори завжди буде 1-й елемент і масив буде відсортований - 1 2 3 4 ... то цей метод спочатку візьме 1 - зрівнить її з усіма остальними, потім 2, зрівнить її з остальними крім двійки і тд. А якщо елементів мільйон - це катастрофа.  Саме тому дуже важливо щоб точка опори була посередині масиву, ось як це буде працювати - http://joxi.ru/BA05vlZSMZ1Ezr - Тут автор каже що буде 4 стеки. Якби це була сортіровка вибором, було б 8 степів. тобто ф-ла log(2) n - не підходить

		- Але ф-ла log(2) n і не має підходити, навіть якщо у мене завжди кращий випадок і я завжди буду брати середне число. Тут ф-ла буде O(n log n) - Але це не точна ф-ла - це середне(приблизне) значення, автор це каже. В мене тут по ф-лі з масивом з 8-ми елементів виходить 24, а я порахував, що ящо посумувати зі скількома елементами я працював за всі степи, вийшло десь 15, тобто навіть швидше, хоча я може не добре рахував 

	- САМЕ ГОЛОВНЕ. Щоб вибрати середній елемент в масиві, атор каже брати случайне число. Мабуть це якиїсь феномен математичний, але це работає. Зазвичай це якраз і дає найкращий результат.











