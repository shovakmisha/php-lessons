
 ------------------------------- Алгоритм Дейкстры ------------------------------

 1) В попередній главі я розглядував пошук в ширину - і за допомогою нього я шукав коротший шлях до точки. Там був граф і точки і перемішаючить по точках я добирався до якоїсь конкретної конечної точки. І вкінці в мене була інфа - як добратись до якоїсь точки пройшовши найменшу к-сть точок. Але менша к-сть точок не означає найшвидший шлях. Треба брати до уваги і відстань між точками а не тільки к-сть точок.

	- Щоб знаходити найшвидший шлях, використовують - Алгоритм Дейкстры

 2) Каждому ребру назначается время перемещения в минутах. Алгоритм Дейкстры используется для поиска пути от начальной точки к конечной за кратчайшее возможное время. На ребрах цього графіка вказані хвилини від одної точки до іншої - http://joxi.ru/823dpX3T93PVaA

	- Якщо б я шукав пошуком в ширину, скоріш за все я б вибрав варіант через точку А(7 хвилин (6 + 1)). Скоріш за все тому що я себе знаю, я б почав шукати з точки A, а не B. 

 3) Алгоритм Дейкстры состоит из четырех шагов:

	1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).

		- http://joxi.ru/823dpX3T93PVaA - На цьому графі у мене є 2 точки через які я можу почати пошук найшвидшого шляху. ДО одної добиратись 6 хв (A), до іншої 2 (B). Про інші вузли я поки нічого не знаю. На цьому етапі вибираю вузел (B). Потім проходжусь по сусідах (B) http://joxi.ru/krDzDoEiKx8G32. І бачу, що з точки (B) до точки (A) шлях займає 3 хв. Тобто з начальної точка до точки А - 6хв, а з начальної точки в точку (B) а потім в точку (A) шлях займає 5хв (Мабуть труба буде уважно перевіряти точки де я був при таких умовах. В попередньому уроці я писав що не треба перевіряти елементи які я вже провірив щоб не зациклитись. Цикл буде йти так що спочатку я знайду точку А потім точку B, так як вони сусіди першого рівня. Коля я другий раз попадаю на точку А, вона вже формально сусід 2-го рівня. І на цей момен вона вже буде у списку перевірених точок. Тож коли я пишу кондішн щоб не зациклюватись, треба брати і це до уваги)

	2. Обновить стоимости соседей этого узла Тобто кожного разу коли я буду провіряти сусідів елемента я так поняв найшвидший шлях до цих сусідів в мене вже буде десь хранитись, але якщо я знайду коротший, мені треба буде його оновити

		- Получається тепер я в точці B і бачу що в ного є 2 сусіди - кінечна точка (до якої весь шлях буде займати 7хв) і точка A, до якої я знайшов швидший шлях 5хв. Коли я знаходжу коротший шлях до якоїсь точки, ці дані треба запиисати. Тож я міняю що від початкової точки до точка А коротший шлях буде не на пряму, а через точку B. Якщо б це був пошук в ширину, на цьому б я зупинився так як я знайшов кінечну точку. Але так я це Алгоритм Дейкстры, ф-ція продовжує работати.

	3. Повторять, пока это не будет сделано для всех узлов графа.

		- Найшвидший шлях від точки B то кінечної точки я вже знаю. Але в мене зявились нові дані - до точки А можна добратись за меншу к-сть часу. Тож продовжую працювати з точкою А. А від неї шлях до кінця вже займає 1 хв. Тож найшвидший шлях до кінечної точки 6хв - Початок -> B -> A -> кінець 

	4. Вычислить итоговый путь.

 4) З цього можна зрозуміти, що Алгоритм Дейкстры і пошук в ширину покажуть геть різні результати.

 5) Алгоритм Дейкстры  - це граф у якому до ребер привязані числа час перехода по цьому ребру між сусідами. Число яке привязане до ребра називається ВЕСОМ

	- Граф с весами называется взвешенным графом. Граф без весов называется невзвешенным графом - http://joxi.ru/l2Z46oyTzLp1yr

	- Для вычисления кратчайшего пути в невзвешенном графе используется поиск в ширину.

 6) в пошуку в ширину я розказував про направлені і ненаправлені вузли. Якщо є 2 вузли зєднані і в кожному з них є лінка один на одного - це цикл. Понятно що це погано. і циклів треба ізбігати. 

	- !!!! Ал­горитм Дейкстры работает только с направленными ациклическими графами, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).

 7) Як це виглядає на практиці. В мене є книга. І яхочу обміняти її на піаніно. Понятно що це не можливо. Єдиний варіант - продати книгу, докласти грошей і купити піаніно. Або є ще варіант зробити як той чувак що міняв ручку на різні речі і в ітозі поміняв на машину (якщо десь треба буде доплатити, це теж можна включити в алгоритм).

	Тож проходжусь по всіх знайомих взнаю що в кого є і хто на що згоден помінятись - http://joxi.ru/vAWzZoxiglpn12

		- «Я тебе дам за книгу вот этот постер, - говорит Алекс. - Это моя любимая группа Destroyer. 

			- Или могу дать за книгу редкую пластинку Рика Эстли и еще $5». 

		------------- постер . Тож з нього треба починати -------------

		- «0, я слышала, что на этой пластинке есть отличные песни, - говорит Эми. - Готова отдать за постер или пластинку мою гитару или ударную установку».

		------------ Емі може дати її гитару или ударную установку, за постер і рідку пластинку. Якщо я захочу помітясь то мені все ж таки треба буде купити ту рідку пластинку за 5$

		- Все життя хотів грати на гітарі - каже Бетховен. Бетховен віддасть мені його піаніно, за БУДЬ ЯКУ річ Емі.


	- Цей рафік - http://joxi.ru/vAWzZoxiglpn12 і описує цю всю ситуацію.

		- Це Граф с весами. Веси в даному випадку - гроші. Тобто мені треба получити піаніно чим дешевше. І так, на цьому графіку ціни не співпадаютьть з тим що мені говорили люди. Мабуть автор вже добавив ціни від себе. 

 8) Перше, що треба зробити - це підготуватись - побудувати таблицю з вартістю всіх вузлів. Звичайно дані в таблиці будуть оновлюватись при роботі алгоритма.

	<!--- Також треба добавити в таблицю стовбчик Батько (що я міняю текущий вузел. Перший раз це книга) -->

 9) І так, менше всіх мені обійдеться постер, з нього і почну. І тут питання - чи вдасться мені получити постер дешевше як безкоштовно (тобто що мені ще і доплатять)? Тобто зробити серыю обмінів при я кому у мене буде постер + ще шось (або гроші). НІ - НЕ ВДАСТЬСЯ. Для прикладу я їду на роботу і я можу до неї добратись через 2 точки - або через парк або через школу - http://joxi.ru/bmoEVXwu3dRdDA

	- Я ніяк не зможу знайти шлях швидший до школи як за 2 хвилини. Як не дивно, але з ціною на обміни те саме. Я ніяк не зможу взяти постер дешевше як за безцінь. В этом заключается ключевая идея алгоритма Дейкстры: в графе ищется путъ с наименъшей стоимостъю . Пути к этому узлу с менъшими затратами не существует!

	- Тож на першому кроці моя таблиця буде виглядати отак - http://joxi.ru/krDzDoEiKxROV2 - є ціни пластинки і постера, інші бескінечність.

 10) Шаг 2: Вычислить, сколько времени потребуется для того, чтобы добраться до всех его(постера) соседей (стоимость). 

	- У постера в сусідах 2 пердмети Эми - гитара или ударная установка - http://joxi.ru/l2Z46oyTzL0QQr між гітарою і барабаном, вибираю барабан.

	- Тобто є 3 стовбчики

		- що міняю

		- на що міняю

		- Ціна, скільки мені обійдеться цей обмін. (але в цю цыну вже вроды буде входити кінечна ціна. Тобто попередні приплюсуються)

	- Кожного разу коли я роблю обмін, я заношу дані в таблицю. Ці дані я маю коли отримую сусідів постера - http://joxi.ru/ZrJzyo5iwDaPar (так, графік відрізняється від слів людей коли я говорив про обмін)

 11) Знов повертаюсь до першого кроку. ВАЖЛИВО - Барабан вже є в мене в таблиці і я його можу отримати за 35 баксів якщо обміняю книгу на постер (безкоштовно) а постер на барабан (35 баксів). І тут я чекаю що ребро між пластинкою і барабаном 20 баксів. Тобто пластику можна обміняти на барабан за 20 баксів (книгу можна обміняти на пластинку за 5 баксів). І в ітозі 25 баксів. А це дешевше за ті дані які я маю в таблиці. Тож заношу нові дані в таблицю і тепер замість того щоб спочатку міняти книгу на постер і на барабан, я міняю книгу на пластинку і барабан - http://joxi.ru/DrlgV3efVx9pXA

	- Вартість гітари в таблиці теж оновилась. тому що дешевше поміняти книгу на пластинку і потім поміняти на гітару (20 баксів), як спочатку міняти книгу на постер і потім на гітару (30 баксів).

	- Соотвецтвенно в таблиці батьком музичних інстументів буде - пластинка! 

 12) І в гітари і в барабана в сусідах є піаніно. Роблю все по аналогії і заповнюю таблицю - http://joxi.ru/brRz6oRi760wEr - Таким образом, самая дешевая цепочка обменов обойдется Раме в $35.

	- Проходя по родительским узлам в об­ратном направлении, мы получаем полный путь - http://joxi.ru/a2XzQokiwgx03r



 ----------- Ребра с отрицательным весом -----------

 1) В предыдущем примере Алекс предложил в обмен на книгу один из двух предметов.

	- Предположим, Сара предложила обменять пла­стинку на постер и при этом она еще и даст Раме $7. Рама ничего не тратит при этом обмене, вместо этого он получит $7. ПОСТЕР Как изобразить это предложение на графе? - http://joxi.ru/52agYDMfEe6E7r - -7$

		- Так, я раныше писав, що немаэ сенсу шукати постер дешевше за безцынь. Але тепер сенс зявився - Я ще і в плюсі залишусь на 2 бакси - http://joxi.ru/E2pEgxwu7xdGpA

		- Але тоді все піде по пизді, так як Алгоритм Дейкстры не працює з ребрами у яких мінусове значення. ТОМУ ТРЕРДЖЕННЯ ПРО ПОСТЕР що не треба шукати шляхи, якими можна взяти постер дешевше як за безцінь - не треба. Покажу на простому прикладі. Мені треба найдешевше взяти барабан - http://joxi.ru/vAWzZoxiglpn12 - шукаю як поміняти постер на барабан - до постера я можу добратись двома шляхами - http://joxi.ru/DrlgV3efVxMOqA - безкоштовно і з плюсом у 2 бакси. Звичайно вибираю з плюсом у 2 бакси

			- Тобто з самого початку - шукаю барабан - створюю таблицю для першого вузла - http://joxi.ru/v293l81IZNEPvr

			- Потім - найдем узел с наименьшей стоимостью и обновим стоимости его со­седей. В этом случае постер оказывается узлом с наименьшей стоимостью. Итак , в соответствии с алгоритмом Дейкстры, к постеру невозможно перейmu более дешевым способом, чем с оплатой $0

			- Оновлюю сусідів постера і бачу барабан http://joxi.ru/nAyv8gwUgbOdqr - 35 баксів - заношу дані в таблицю

			- Я ще не переходив до вузла барабана, тож принцип пошук в ширину зберігається. Переходжу у вузел "Редкая пластинка". Оновлюю список її сусідів а серед них є і постер. Ребро до нього -7 баксів - звичайно вибираю його і оновлюю дані в таблиці. - http://joxi.ru/a2XzQokiwgx3kr - постер - -2 бакси. Постер був бесплатний, тепер там -2 бакси. Нагадаю що оновлюю тільки тоді, коли це дешевше ніж було. 

			- І не дивлячись на те що я знаю що барабан у такому випадку можна купити на 2 бакси дешевше - я не можу це зробити

				ЛАМАЄТЬСЯ ОСНОВНИЙ ПРИНЦИП - Якщо я обробляю вузел, то до вузла не можна добратись кращим(дешевшим) шляхом. Тобто я 1 раз обробив вузел постер і все. А коли ребра мають мінусове значення, то логіка як бачу ламається, соотвецтвенно ламається логіка алгоритму.

					- Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый алгоритмом Беллмана - Форда. Рассмотрение этого алгоритма выходит за рамки этой книги, но вы сможете найти хорошие описания в Интернете.

 

 --------- Реализация цього алгоритму в программном коде ----------

 - http://joxi.ru/12Mzjodil7M7OA - є такий граф. Початковою точкою буде start і від нього йдуть 2 точки A i B. Для реализации этого примера понадобятся три хеш - таблицы.

 1) Граф
	graph["start"] = {}
	graph["start"]["a"] = б
	graph["start"]["b"] = 2

	http://joxi.ru/DmB8DjGUJjwM6A

	- Включим в граф остальные узлы и их соседей:

		graph["a"] = {}
		graph["a"]["fin"] = 1 - фініш

		graph["b"] = {}
		graph["b"]["a"] = 3

		graph["b"]["fin"] = 5  - фініш

		graph["fin"] = {} - У конечного уэла нет соседей

	- Полная хеш-таблица графа выглядит так: http://joxi.ru/YmEzDojiwj0RB2


 2) Также понадобится хеш-таблица для хранения стоимостей всех узлов. Стоимость узла определяет, сколько времени потребу­ется для перехода к этому узлу от начального узла.

	infinity = float("inf"); - безкінечність
	costs = {}
	costs["a"] = 6
	costs["b"] = 2
	costs["fin"] = infinity - ПОКИ Я НЕ ЗНАЮ ВАГУ РЕБРА МІЖ ВУЗЛАМИ ВАГА БУДЕ - БЕЗКІНЕЧНІСТЬ

 3) Для родителей также создается отдельная таблица:

	parents = {}
	parents["a"] = "start"
	parents["b"] = "start"
	parents["in"] = None

  - Наконец, вам нужен массив для отслеживания всех уже обработанных уз­лов, так как один узел не должен обрабатываться многократно: processed = [].


 ---------------

 - На этом подготовка завершается. Теперь обратимся к алгоритму - http://joxi.ru/KAxB9qwcZ6MJPm

	// the graph - цей граф трохи нагадує EAV
	const graph = {};
	graph["start"] = {};
	graph["start"]["a"] = 6;
	graph["start"]["b"] = 2;

	graph["a"] = {};
	graph["a"]["fin"] = 1;

	graph["b"] = {};
	graph["b"]["a"] = 3;
	graph["b"]["fin"] = 5;

	graph["fin"] = {};

	// The costs table - хеш-таблица для хранения стоимостей всех узлов
	const costs = {};
	costs['a'] = 6;
	costs['b'] = 2;
	costs['fin'] = Infinity;

	// the parents table
	const parents = {};
	parents['a'] = 'start';
	parents['b'] = 'start';
	parents['fin'] = null;

	let processed = [];


	// Найти узел с наименьшей стоимостью среди необработанных
 
	function find_lowest_cost_node(costs) {

	  let lowest_cost = Infinity; // Алгоритм Дейкстры буде шукати сусіда ноди, яка має меншу вагу і потім буде відштовхуватись від цієї ноди. 

<-- на самому початку має я не знаю вес який буде вести до фінішу. Я точно знаю тільки вес ребер які йдуть від начальної точки (до вузлів A i B) -->

	  let lowest_cost_node = null; // найшижча вага до фінішу. На самому початку я не знаю яка вона буде

	  // Go through each node
	  for (let node in costs) { // на самому початку проходжусь по вузлах які йдуть з стартового вузла // costs = {a: 6, b: 2, fin: Infinity}

					- Коли я другий раз заходжу в цю ф-цю з цим же масивом - даны в ньому вже інші - {a: 5, b: 2, fin: 7}

	    let cost = costs[node];

	    // Якщо я ще не знайшов найнижчу ціну до фінішу і якщо текущо нода ще не оброблялась
	    if (cost < lowest_cost && (processed.indexOf(node) === -1)) { // Тобто - наприклад на самому початку я маю точки A I B + Infinity як найнижча вага до них. Infinity із за того що я не знаю точної ваги A I B. І ось я получив їхнє значення(вагу) - 6 і 2. Звичайно вони будуть менші за Infinity

									// Коли я другий раз заходжу в цю ф-цю з цим же масивом, точка B вже не буде оброблятись так як вона в масиві processed

									//  в загальному цей кондішн означає - Если это узел с наименьшей стоимостью из уже виденных и он еще не был обработан •••

	      // ... set it as the new lowest-cost node.
	      lowest_cost = cost;
	      lowest_cost_node = node;
	    }
	  }
	  return lowest_cost_node;
	}

		- В результаті цього циклу (при провірці начальної ноди, я буду мати сусіда стартової точки у якої найменша вага - B з вагою 2)

		- Другий раз коли я зайду у цю ф-цію, я буду вибирати найменшого сусіда точки B. Тобто буде кінечна точка і точка А, а так як до точки А менша вага, я поверну точку А. Тобто недивлячись на то що я знайшов кінечну точку, я не завершую роботу ф-ції, а продовжую працювати з сусідом у якого менша вага.




	let node = find_lowest_cost_node(costs); - Найти узел с наименьшей стоимостью

	while (node !== null) { - Если обработаны все узлы, цикл while завершен

	  let cost = costs[node]; - Тож ф-ція find_lowest_cost_node знайде мені сусіда з найменшою вагою і цей сусід храниться у змінній -node

	  // Go through all the neighbors of this node

	  let neighbors = graph[node]; - Коли я найшов сусіда з найменшою вагою, починаю працювати з ним.



	  Object.keys(neighbors).forEach(function(n) { - Перебрать всех соседей текущего узла. Тут якраз і буде реалізована логіка оновлення таблиці. Якщо вага до текущого вузла + вага до його сусіда буде нижча як до вузла (з початкової точки у даному випадку), то дані того вузла треба буде оновити, так як обходний шлях через вузел буде займати меншу вагу.

	    let new_cost = cost + neighbors[n];- Если к соседу можно быстрее добраться через текущий узел. Я додаю то ваги текушого вузла, вагу сусіда. 

	    // If it's cheaper to get to this neighbor by going through this node - Тобто вузел B межує з вузлом А. Вузел А межує з початковою точкою. У моєму випадку до вузла А я доберусь з меншими затратами (5) ніж з початкової точки (6). Тож ці дані треба записати в таблицю

	    if (costs[n] > new_cost) {

	      // ... update the cost for this node
	      costs[n] = new_cost; - обновить стоимость для этого узла. Тобто - крім точка А, тут є і кінечна точка. Але вага цієї точки буде не вага ребра від точки B в кінечну точку, а вага від начальної точки до точки B + до кінечної точки. Тобто вага до кінечної точки через точку B = 7.

	      // This node becomes the new parent for this neighbor.
	      parents[n] = node; - Этот узел становится новым родителем для соседа. Якщо в точку А скоріше добратись з точки B, то точка B стаэ батьком точки А 
	    }
	  });

		- Після того як я пройшов сусідів ноди B (А і конечна точка) - я знайшов кінечну точку і знайшов що до точки А можна добратись за 5 хв. Заношу ці дані у таблицю parents

	  // Mark the node as processed
	  processed = processed.concat(node); - Узел помечается как обработанный. Пешрий раз у цей список попав вузел B (costs['b'])
	  
	  // Find the next node to process, and loop
	  node = find_lowest_cost_node(costs); - Найти следующий узел для обработки и повторить цикл. Тобто Якщо я тепер у точці B, знайде його сусідів і вибере сусіда з найменшою вагою 
	}

	console.log("Cost from the start to each node:");
	console.log(costs); // { a: 5, b: 2, fin: 6 }

 ---------------------------------------

	Я тепер поняв що таке сусід. Наприклад коли я був у точці А, то в нього сусід був тільки конечна точка - http://joxi.ru/12Mzjodil7M7OA

	- Тобто я не буду перелопачувати всі шляхи що є кожного разу. Тільки сусідів (а правильніше сказати нащадків). Якщо є таке, що 2 різних парента мають одне й те саме дитя - це ок, можна переоприділити ціну на вигіднішу, але не буде таконо що я залізаю назад або ще у якісь дебрі. Не треба загружатись. Творець алгоритма вже нагрузився. А мені головне що цей спосіб работає. 

 ---------------------------------------

 КАРОЧЕ Я ВАЩЕ НЕ ДОГНАВ ЯК БУДУВАТИ ГРАФИ. Маю на увазі що для маленьких прикладів ще ок але для великих, коли мільйони точок, це ж по любому вручну малювати катастрофа.


 Практичне заняття - http://joxi.ru/L216bOacRWwbeA . По аналогії треба робити 3 таблиці

	// the graph
	const graph = {};
	graph["start"] = {};
	graph["start"]["one"] = 5;
	graph["start"]["two"] = 2;

	graph["start"]["one"] = 4;
	graph["start"]["two"] = 2;

	graph["a"] = {};
	graph["a"]["fin"] = 1;

	graph["b"] = {};
	graph["b"]["a"] = 3;
	graph["b"]["fin"] = 5;

	graph["fin"] = {};

	// The costs table - хеш-таблица для хранения стоимостей всех узлов
	const costs = {};
	costs['a'] = 6;
	costs['b'] = 2;
	costs['fin'] = Infinity;

	// the parents table
	const parents = {};
	parents['a'] = 'start';
	parents['b'] = 'start';
	parents['fin'] = null;

	let processed = [];

 


	
	

		

 










