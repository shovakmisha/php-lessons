
 1)  С бинарным поиском вы каждый раз загадываете число в середине диапазона и ис'КЛючаете половину оставшихся чисел.

	- Типу якшо діапазон в мене задача вгадати число від 1 - 100, і мені може дати відповідь менше більше. А загадуєме число 99(я цього не знаю). То спочатку я кажу 50, щоб  відрізати половину, мені кажуть що загадуєме число більше. Потім я кажу 75 і тд

	- За 7 кроків можна взнати число 1, якщо є 100 чисел - http://joxi.ru/DrlgV3efVZRyPA. Це гарантія, що за 7 кроків можна взнати будь яке число від 1 до 100

	- Можна до цього й самому здогадатись, що бінарний пошук работає тільки відсортованому списку. оСЬ ЧОМУ ВЕЛИКІ МАСИВИ ДАНИХ ТВКІ ЯК ТЕЛЕФОННІ КНИГИ - ВІДСОРТОВАНІ ПО АЛФАВІТУ

 2) В об­щем случае для списка из n элементов бинарный поиск выполняется за log 2 n шагов, тогда как простой поиск будет выполнен за n шагов.

	- log 2 тому що завжди масив ділиться на 2 при бінарному пошуку. На половину

 3) log(10) 100 - означає скільки разів треба перемножити 10 щоб отримати 100. Правильна відповідь 2 (Тут йде аналогія з виведенням в спепінь 10(2) == 100 (Тобто 10 * 10 == 100))

	- Тобто - log(10) 100  = 2;

	- Логарифм по сенсу противоположний виведенню в степінь - 10(2) = 100     ==    log(10) 100 = 2
								- 10(3) = 1000    ==    log(10) 1000 = 3

 4) Для списка з 8 елементів пошук з алгоритмами буде log(2) 8 == 3 тому тому що 2 в 3-му степені == 8. Тобто треба буде зробити максимум 3 степи щоб знайти рандомне число з 8-ми

	- Для списка з 1024 елементів пошук з алгоритмами буде log(2) 1024 == 10

	- Сенс у тому що я завжди ділю на половину при бінарному пошуку, тому log(2)

 ------------------------------------------------------
	- Ремарка. У бінароному пошуку, коли є слово log - це підразумівається - log(2) - так як ділиться завжди на 2
 ------------------------------------------------------

 5) Бінарний пошук працює тільки з відсортованим масивом. Нижче буде ф-ція якій я прередам масив з даними і значення яке я шукаю в цьому масиві. Якщо я знайду це значення в масиві, ф-ція поверне його порядковий номер. Це відсортований масивю

	Я буду шукати значення 7 у масиві  [1, 3, 5, 7, 9] - http://joxi.ru/brRz6oRi7nWNkr

	function binary_search(list, item) {

	  let low = 0; // - Початкове значення(індекс) масива - 0

	  let high = list.length - 1; // - останнє значення(індекс) масива - 4
	  
	  while (low <= high) {

	    let mid = Math.floor((low + high) / 2); // Каждый раз алгоритм проверяет средний элемент масива. Если значение (low + high) непарне, то округляю його в меншу сторону.

	    let guess = list[mid]; - це середне значення (по порядку) масива. Не то що воно завжди буде середнім. Середне на даний момент. Наприклад при першій провірці це буде середне значення масива, потім середне значення вде меншого діапазону і тд

		- Тобто наприклад я шукаю значення 7 у масиві [1, 3, 5, 7, 9]; Перший раз додасться 0 + 4 = 2 і цей індекс буде текущий у циклі. Значення індекса 2 у масиві = 5 

	    if (guess === item) { // - Якшо так випало що це середне значення == тому що я шукаю - повертаю індекс того значення що я шукаю
	      return mid;
	    }
	    if (guess > item) { // - Если названное число было слишком мало, то переменная low обновляется соответственно:

					- Тобто якщо число яке я шукаю в масиві менше від текущого середнього в масиві, то права частина масиву від середнього і до кінця відрізається і наступного разу там вже не буду шукати це значення

					- і навпаки

	      high = mid - 1; 
	    } else {
	      low = mid + 1;
	    }
	  }
	  
	  return null;
	}

	- const my_list = [1, 3, 5, 7, 9];

	- binary_search(my_list, 7);
----------------------------------------
	- Це якраз то про що я описував. Це бінарний пошук і тут застосовується ця формула - log(2) n(список у якому я буду шукати) (Тобто скільки разів треба буде перемножити двійку щоб було число як елементів у списку). Важливо розуміти що це не супер точна ф-ла. Невеликі погрішності це ок. Коли процесор обробляє мільйонний список, і погрішності у мене декілька мілісекунд (наприклад одна ітерація виконується за одну мілісекунду), то це ок.
----------------------------------------

 6) Упражнения 1.1 Имеется отсортированный список из 128 имен, и вы ищете в нем зна­чение методом бинарного поиска. Какое максимальное количество проверок для этого может потребоваться?

	 - log(2) 128 = 7

 7) Логарифмічний час - це к-сть спроб яких треба пошуку при бінарному пошуку

	- Лінійний час - це к-сть спроб яких треба пошуку при послідовному пошуку.


 -------------------------------------------- О - велике -----------------------------------------

 1) О(n) - велике просто позначає скільки треба операцій щоб виконати якиїсь код в гіршому випадку. О - велике підрозуміває швидкість виконання алгоритму, але насправді немає такого що він має розраховувати секунди. Секунди будуть вираховуватись на основі к-сті операцій.

	- Взагалі О - велике використовується щоб взнати як виросте час виконання скріпта коли список елементів по яких я буду шукати виросте. Типу графіки можна буде будувати на основі цього.

	- (n) - Це к-сть операцій у гіршому випадку. Тобто якщо я використовую послідовний пошук і в списку є 1000 елементів, то (n) буде 1000

	- О - це прозто позначка, а велика із за того що сапс лок, тому і велика.

	- Запомните простое правило: в «О-большое» игнорируются числа, задействованные в операциях сложения, вычитания, умно­жения или деления. Ни одно из следующих значений не является правильной записью «О-большое»: О(n + 26) | О(n / 26) ...

 2)  Ниже перечислены пять разновидностей «О-большого», которые будут встре­чаться вам особенно часто, в порядке убывания скорости выполнения:

 наприклад в мене є задача зробити 16 квадратиків на листку. За секунду може виконатись 10 операцій

	- O(log n) - или логарифмическое время. Пример: бинарный поиск.

		- По цьому алгоритму я просто буду складувати листок. Якщо я складу його 4 рази, в мене буде 16 квадратів - log(2) 16 = 4

		- Тобто, ще раз. Є кориляція, що бінарний пошук займе часу - час одної ітерації * к-сть ітерацій. Ця ф-ція що я писав вверху наглядно показує що формула діє. Я запихнув у неї список з якоюсь к-кістю елементів (n) і ітерацій у циклі було стільки ж скільки вказано у цій ф-лі - log(2) n(к-сть елементів у списку). Можливо з невеличкими погрішностями  

	- О(n) - или линейное время. Пример: простой поиск. Якщо я буду робити послідовно 16 квадратиків, то буде - О(16)

	- О(n* log n) -  Пример: эффективные алгоритмы сортировки (быстрая сортировка - но об этом в главе 4)

	- О(n(2) ) - Пример: медленные алгоритмы сортировки (сортировка выбо­ром - см. главу 2).
	
	- О(n!). Пример: очень медленные алгоритмы (задача о коммивояжере - о ней будет рассказано в следующем разделе).


 -------------------------------------- Массивы и связанные списки --------------------------------------

 1) При использовании массива все задачи хранятся в памяти непрерывно (то есть рядом друг с другом) - http://joxi.ru/vAWzZoxigVdav2

	- Теперь предположим, что вы захотели добавить четвертую задачу. Но сле­дующий ящик уже занят - там лежат чужие вещи! - http://joxi.ru/zANzVoLivZMN7A

		- В этом случае вам при­дется запросить у компьютера другой блок памяти, в котором поместятся все четыре задачи, а потом переместить все свои задачи туда. Тобто коли я додаю елемент в масив і він не поміщається в рядах памяті, компютер буде шукати новий участок памяті, де поміститься весь масив. А це вже не дуже продуктивно і повільно.

	- В принципі можна завчасно задати великий масив щоб він не блуждав по різних участках памяті, хоча і в цьому є очевидні недоліки, про які і так понятно.

 2) Для вирішення проблем з памятю для масива є звязані списки. Вкожному елементі списка храниться лінка на слідуючий елемент в списку. А як я памятаю що коли я зберігаю щось у памяті, я кажу компютеру - збережи це в памяті і він зберігає. І у кожного з цих елементів є адреса на участок памяті в якому він лежить

	- Тож зі списками вже проще шукати елементи списка. І вже не треба прочісувати всю памяь, я вже буду знати де шукати. Тобто це своєобразна цепочка з даними і лінками.

	- І добавлення нового елемента в список вже не буде великою проблемою. Просто добавляю елемент у будь який участок памяті і вказую на нього лінку у попередньому елементі списка.

	- Але і тут є свої недоліки. Щоб взнати де знаходиться останній елемент, а я знаю тільки адресу першого, мені треба пройтись від самого першого, по всіх елементах до самого останнього.

		- Тут автор приводив приклад, коли є типу тести якісь, де спочатку заходиш на першу сторінку, там є кнопка NEXT, переходжу на другу і так до кінця. Тобто я не можу зайти на сайт і перейти на останню сторінку зразу, або з будь якої іншої сторінки крім передостанньої.

 3) А що як мені не підходить варіант зі списками і я хочу ці ж самі тести не у вигляді коли переходжу з попереднього на наступний а хочу щоб на одній сторінці в мене були всі тести (імя всіх тестів), і кожне імя теста буде лінкою на цей тест. Ось це вже то як работають масиви.

	- Щоб провести аналогію, я йду компанією в кінотеатр. І у нас є общий білет, де вказані місця для всіх - це масив. А от коли ситуація така, що з самого початку я знаю тільки місце одного(першого) чувака, а він вкаже місце другого, а другий вкаже місце третього, то це вже звязаний список. Тобто перескакування з одного елемента в другий це те саме що пошук місць в кінотеатрі. Щоб другий знайшов місце одинадцятого, цому треба буде спитати всіх де знаходиться одинадцятий.

	- Умовно ситуація з масивами така, що у кожного є білет де вказані місця всіх друзів. Це не то що вони вже в курсі кожного елемента, просто вони дуже легко вираховуються у звязку з тим що вони йдуть один за одним. Типу якщо я знаю перший елемент і його індекс наприклад 0, то якщо мені треба буде 5-й елемент - це логічно що він буде знаходитись через 4 участки памяті до нульового. У четвертому участку памяті буде знаходитись 5-й елемент. Це миттево вираховується компютером

	- http://joxi.ru/nAyv8gwUgQJbDr - На цій таблиці показано, що читання масивів займає дуже мало часу (одну ітерацію), а от добавлення елемента в масив вже займає стільки ітерацій, скільки займає довжина масива. А із списком навпаки якраз. Читання йде дуже повільно а вставка швидко. 

		- Основуюсь на тому що я писав вверху, це із за того що щоб добавити новий елемент в масив (а особливо якщо на початок масива), мені треба буде перемістити всі елементи масива на 1 вправо і із за того O(n) - тобто ітерація по всіх елементах масиву. Я вже якщо прочитати елемент з масиву, мені треба буде знайти тільки будь-який елемент з масиву і додати до нього потрібне число і це буде вже той участок памяті який мені потрібно. 

		- Ну а зі списком чому так теж понятно. Щоб почитати останній елемент, мені треба буде пройтись по всіх елементах списку щоб знайти його - тому O(n), а от щоб вставити новий елемент, треба буде до останнього додати лінку на новий останній елемент - тому це одна ітерація.

			- Хоча думаю це трохи лукавство, тому що щоб вставити новий елемент, треба буде спочатку знайти той елемент з яким він буде звязаний, а якщо це буде останній елемент, то треба буде пройтись по всіх елементах списку - тож O(1) тут вже не підійде

				- На практике обычно сохраняются ссылки на первый и последний элементы связанного списка

			- І ще я догнав, що в списку можна брати будь-який елемент, вставляти замість нього інший, просто вказавши лінку на нього. А у тому що я викинув буде лінка вже на наступний елемент, тож цепочка не прервалась і все работає, тільки вже з новим елементом.

			- ЯКЩО В МЕНЕ є ЗАДАЧі ТИПУ ПРОГРАМИ ТРЕНІРОВОК АБО ЩЕ ЯКОЇСЬ БАЛДИ, ДЕ ДАНІ ЧАСТО ЗАПИСУЮТЬСЯ ЯК ЧИТАЮТЬСЯ ТО КРАЩЕ ВИКОРИСТАТИ ЗВЯЗАНИЙ СПИСОК. Це по цих причинах що я писав вверху. 




--------------------------------------------------
 - Ремарка про масиви - В этой книге термин «индекс» означает то же, что и «ПОЗИЦИЯ».
--------------------------------------------------



 4) ВИДАЛЕННЯ ЕЛЕМЕНТІВ З ПАМЯТІ

	- http://joxi.ru/l2Z46oyTzN44Vr

	- З видаленням елементів так само. Списки краще підходять. Умовно якщо видалити елемент зі списка, то просто треба буде у елемента, який стоїть перед виделеним елементом змінити лінку на наступний елемент, а якщо це буде масив, то треба буде копіювати/вставляти всі елементи вліво, які стоять справа від видаленого.

	- Видалити елемент з памяті можна завжди.


 5) Ця фішка з читанням масивів і звязаних списків - це як доспуп доступ до них. Всего существуют два вида доступа: произвольный(у масивів) и последовательный(у списків). Це то що я писав, що щоб взяти будь який елемент масиву понадобиться буквально 1-2 ітерації, а щоб взяти елемент зі списку, треба буде пройтись по всіх елементах які знаходяться перед елементом який я шукаю. Із за того що масиви мають произвольный доступ - вони такі популярні.

	- Наприклад коли користувачі заходять на Facebook то там полюбому використовуються масиви, так як там дуже часто треба буде читати дані з усого переліку користувачів.

	- Але не обовязково щоб були масиви або звязані списки. Можна щоб було гібридно. Наприклад якщо є список усіх імен користувачів у Facebook, то можна зробити 26 ячейок на букви(а б в г) масивом, а вже у масиві будуть хранитись лінки на звязані списки.

 6) Трохи сортіровки (СОРТИРОВКА ВЫБОРОМ). Наприклад є список виконавців і мені треба скласти на основі того скільки разів їх слухали список по їх популярності. Це мені треба буде проходитись по всьому списку виконавців, шукати в кого найбільше прослуховувань і у того у кого найбільше, кидати вверх. І у наступній перевірці він вже не буде участвувати в перевірці. Тобто вкінці залишиться 2 виконавці, а потім один. 

	- Формула для цього буде O(n в квадраті) або O(n * n). На даний момент дивно чому так. Чому ф-ла виглядає так ніби я не викидував виконавців зі списку для перевіряння після того як вибрав найпопулярнішого. По хорошому мало б бути так, що якщо на початку я перевіряю всіх користувачів, а вкінці список звужується до одного, то було б справедливіше множити весь список на половину списка, типу O(n * 0.5). Але ф-ла всерівно виглядає O(n * n). Подробиці чому так у 4-тій главі, але тепер можу сказати що це із за того, що "O-велике" ігнорує константи типу - 0.5

 7) Тепер напишу ф-цію, яка сортує елементи від самого малого до самого великого. 

	- Спочатку напишу ф-цію яка шукає найменше значення  масиву

		function findSmallestIndex(array) {

		  var smallestElement = array[0]; // Тут буде хранитись найменше значення масиву. Для початку назначу, що найменше значення це перший елемент масиву з індексом 0

		  var smallestIndex = 0; // Для хранения индекса наименьшеrо значения

		  for (var i = 1; i < array.length; i++) { // починаю лічильник з другого елемента в масиві, так як перший вже оприділений як найменший і він у змінній smallestElement
 
		    if (array[i] < smallestElement) { - Тут вся магія. Якщо текуший елемент в масиві, менший за перший, він стає найменшим, поставиться у змінні smallestElement і smallestIndex і потім вже він буде перевірятись з іншими елементами на найменшість. 

							- Якшо текуший елемент у циклі більший за найменший елемент у масиві, код у цьому кондішні не виконається

		      smallestElement = array[i];
		      smallestIndex = i;
		    }
		  }

		  return smallestIndex;
		}
 
		- console.log(findSmallestIndex([5, 3, 6, 2, 10])); // 3

	- Тепер коли я маю ф-цію яка знаходить найменший елемент у масиві, можна написати ф-цію сортування (СОРТИРОВКА ВЫБОРОМ).

		function selectionSort(array) {

		  var sortedArray = []; - Створбб новий масив куди буду складувати вже відсортовані елементи
		  var length = array.length;

		  for (var i = 0; i < length; i++) {

		    var smallestIndex = findSmallestIndex(array); // Finds the smallest element in the array - Шукаю найменший елемент в масиві за допомогою ф-ції, яку я писав вверху - findSmallestIndex()

		    sortedArray.push(array.splice(smallestIndex, 1)[0]); // Adds the smallest element to new array - Переміщаю найменший елемент в новий масив, і получається що я складую попорядку у новий масив значення від найменшого до найбільшого

		  }

		  return sortedArray; - Повертає відсортований масив
		}


 ---------------------------
 - Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.). Але я не знаю чи це точно так. Автор написав цю тезу і ніде не описував чому.
 --------------------------






