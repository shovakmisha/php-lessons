
 -------------------------------- ГЛАВА 3 - РЕКУРСІЯ -------------------------------

 1) Кожна рекурсія складається з двох частин.

	- Базовий випадок - Тут ф-ція не викликає себе. Тут я ставлю перевірки щоб не запускати ще раз рекурсію

	- Рекурсивний випадок - Тут ф-ція викликає себе

	- Ці 2 частини це if/else в одній частині перевіряю чи треба ще раз викликати ф-цію, а в іншій частині викликаю рекурсивну ф-цію

	- СУТО РЕКУРСІЇ В ТОМУ ЩОБ ПРИВЕСТИ РЕКУРСИВНИЙ ВИПАДОК ДО БАЗОВОГО

 2) Стек - це last in - first out.

 3) СТЕК ВИКЛИКІВ. Весь час я ним користуюсь просто не підозрюю про це. Наприклад є ф-ція яка викликає 2 інші ф-ції

	greet('meggie'); - Винесу виклик ф-ції вверх для зручності, щоб був код флоу. Кароче я викликаю цю ф-цію і компютер виділяє блок памяті під виклик цієї ф-ції. Тепер я маю блок памяті з іменем greet

	function greet(name) {  - змінній name присвоюється значення 'meggie' - http://joxi.ru/MAjElawujLnV62 - Це теж буде знаходитись у блоці з памяттю ф-ції - greet(). Тобто коли я викликаю ф-цію починається ця робота - виділення памяті під ф-цію, виділення памяті для свойст цієї ф-ції

	  console.log('hello, ' + name + '!');

	  greet2(name); - Потім це саме буде для цієї ф-ції - http://joxi.ru/zANzVoLivZEvXA - Компютер виділяє память вже для нової ф-ції. Але як бачу по картинці це не просто виділення памяті, він обєднує ці участки памяті у яких є виклик цих ф-цій у стек. При чому блок з ф-цією greet2() знаходиться вверху цього стеку (last in - first out)

		- Тобто на даний момент компютер хранить у памяті стек з двох ф-цій. Коли ця ф-ція відпрацює, greet2() викинеться зі стеку і звільнить память (і свойства що в ній храняться теж видаляться - http://joxi.ru/zANzVoLivZEVLA). і у стеку залишиться тільки greet(). Ось чому є цей принцип last in - first out. Він дуже зручний для клд флоу - ф-ція зайшла в стек, відпрацювала і вийшла зі стеку.

		- Верхній блок у стеку оприділяє що робить стек і він управляє стеком. Тобто який блок з ф-цією на вершині стека, той і активний 

		- Ф-ція greet ще не завершила свою роботу, вона просто передала управління стеку іншій ф-ції. Поки ф-ція greet2 не відпрацювала, greet приостановлюється і знаходиться в частично завершенном состоянии. Всі свойства ф-ції greet храняться в памяті ще 

	  console.log('getting ready to say bye...'); - Тепер ф-ції greet2 вже не має в стеку.

	  bye(); - Тепер вже ця ф-ція додається в стек http://joxi.ru/V2VbKoXUdYwN82 (greet2 вже відпрацювала і звільнила память. Вона вже не в стеку)

	}

	function greet2(name) {

	  console.log('how are you, ' + name + '?');
	}

	function bye() {
	  console.log('ok bye!');
	}

------------------------------------------------------------
 - Этот стек, в котором со­хранялись переменные разных функций, называется стеком вызовов. 
------------------------------------------------------------

 4) Стек вызовов с рекурсией. Рекурсивные функции тоже используют стек вызовов!

	- Наприклад я роблю ф-цію факторіала. Факторіал 5 - це - 5*4*3*2*1.

	function fact(x) {
	  if (x === 1) {
	    return 1;
	  }
	  return x * fact(x - 1);
	}

	console.log(fact(3)); - Стек для ціє рекурсії буде виглядати так - http://joxi.ru/D2PzQoZiqR7g7r

		- Повний стек буде виглядати так - http://joxi.ru/EA4LvxOioxbEKA

		Якщо розбити по степах, то це буде виглядати так. Нагадаю, що це буде ф-ція в ф-ції. І змінна х у кожній ф-ції буде своя за рахунок замикання

			1) fact(x) - у памяті виділилась память з назвою fact і у цьому ж блоці змінній х присвоїлось значення = 3. На даний момент це верхній блок у стеці.

			2) Кондішини зупинки не пройшли, отже пішла рекурсія. return x * fact(x - 1); - це буде цей же самий стек, але верхній блок тепер буде з новою ф-цією. Тобто це буде та сама ф-ція fact але вже нова (у новому блоці) і з значенням х = 2. Тобто тепер у стеці я маю 2 блоки.

			3) Рекурсія - це як розварачувати клубок. Поки я не дойду до стопаря, всі блоки з ф-ціями і їх свойства будуть лежати в стеку і займати память. Наприклад тепер у мене в памяті лежать 3 блоки з ф-ціями. І ніодна не може завершитись із за цієї строчки - return x * fact(x - 1); - І тут я попадаю на блок з 3-ю ф-цією - http://joxi.ru/J2bglQGf054vnA і кодом if (x === 1) {
																						    return 1;
																						  }

				- Після цього 3-й блок випав зі стеку повернувши 1 (if (x === 1) { return 1; }) - ВСЕ КЛУБОК РОЗМОТАВСЯ ПОВНІСТЮ. Тепер клубок буде змотуватись, або точніше сказати буде звільнюватись память зі стеку. Тобто 2-му блоку у стеку дістася код - return x * 1 (return 1);

					- Оскільки х 2-го блока == 2, Значить ретурн 2-го блоку буде - return 2 * 1

					- Другий блок теж випав зі стеку, повернувши першому стеку 2.

			4) І тепер в стеку залишилась одна ф-ція - ориганальна - function fact(3) {
										  if (3 === 1) {
										    return 1;
										  }
										  return 3 * 2; -- Вкінці буде 6
										}

			5) Тобто якщо факторіал виглядає так 5*4*3*2*1 - то я зробив навпаки - 1*2*3*4*5 - що в принципі те саме.

	- Кожній програмі виділяється огранічений обєм памяті в стеці. Якщо стек буде переповнений (наприклад якщо буде безкінечна рекурсивна ф-ція) це викличе помилку. Автор тут не казав що це за стек. Чи це якиїсь отдільний участок памяті чи це ті ж самі масиви або списки. Кароче не понятно. але я точно знаю що при безкінечній рекурсивній ф-ції комп висне.


								 --------------------------- Глава 4 ----------------------------


 5) Быстрая сортировка - Вы узнаете о стратегии «разделяй и властвуй». Цей алгоритм сортіровки набагато швидший з сортіровку вибором про яку я писав раніше (глава 2)

	- Наприклад в мене є участок землі 1680*640 (не квадратний) і мені треба його розділити на найбільші ОДИНАКОВІ квадратні участки, як тільки можна. Тобто такі варіанти не підійдуть - http://joxi.ru/eAOz1oKi9ay952

		- Воспользуйтесь стратегией «разделяй и властвуй~! Алгоритмы на базе этой стратегии яв­ляются рекурсивными.

		- Решение задачи методом «разделяй и властвуй ~ состоит из двух шагов:

			1. Сначала определяется базовый случай. Это должен быть простейший случай из всех возможных

			2. Задача делится или сокращается до тех пор, пока не будет сведена к ба­зовому случаю

		------- Рішення ------

		- базовий випадок у цьому випадку буде такий участок землі, де одна сторона вдвічі більше іншої - типу 50 на 25. Моя ф-ція має працювати до тих пір, поки я не знайду такий паралелограм. Чому це так я пояснив тут - !!!ЕВКЛИДА 

		- Логіка така, що кожного разу коли запуститься рекурсивна ф-ція, я маю бути ближчим до БАЗОВОГО ВИПАДКУ.

		1) Якщо участок 1680*640, то з них можна получити 2 квадрати 640*640 і залишиться ще участок розміром 400*640

			-  !!!ЕВКЛИДА - То що самий великий участок для меншого паралелограма буде самим великим участком і для більшого паралелограма - це то теорії ЕВКЛИДА - http://joxi.ru/V2VbKoXUdqxvl2

		2) цей участок 400*640 теж треба розділити на найбільші квадрати. І цей алгоритм для цього теж підійде. http://joxi.ru/eAOz1oKi9aynK2 - Після цього у мене буде квадрат розміром 400*400 і участкок розміром 240*400. Тобто це та ж сама херня. Шукаю найбільше значення яке підходить і викидую його з задачі, щоб наступного разу воно не путалось під ногами.

		3) Отсекая поделенную часть, мы приходим к еще меньшему размеру сегмента 240*240 і остача 240 Х 160 М. - http://joxi.ru/KAxB9qwcZ8WQym

		4) После очередного отсечения получается еще меньший сегмент 160*160  і остача 160*80 - http://joxi.ru/BA05vlZSMV0Xvr

		5) ЦЕ КІНЕЦЬ. Так як 160 рівно вдвічі більший за 80 і вже остачі не буде. Алгоритм розділяй і володій завершив свою роботу.

			- ПОЛУЧАЄТЬСЯ ЩО НАЙБІЛЬШІ КВАДРАТИ НА ЯКІ МОЖНА РОЗДІЛИТИ ПЕРИМЕТЕР 1680*640 ЦЕ 80*80 - http://joxi.ru/VrwElJwu7kVR52

			- ЦЕ ПО ХОДУ ЯКАСЬ ТЕОРІЯ ВЖЕ ДОКАЗАНА, ЩО ЯКЩО ВИДІЛЯТИ КВАДРАТ З ПАЛАЛЕЛОГРАМА БАГАТО РАЗІВ, ТО ТО Я ДЕСЬ ДІЙДУ ДО ТОГО ВИПАДКУ, КОЛИ В МЕНЕ БУДЕ ПАРАЛЕЛОГРАМ У ЯКИЙ ПОМІСТЯТЬСЯ 2 ОДИНАКОВІ КВАДРАТИ.

 6) Вспомните, как работает стратегия ~разделяй и властвуй•:

	1. Определите простейший случай как базовый. найпростіше що може бути.

	2. Придумайте, как свести задачу к базовому случаю.

 7) Може після цього краще стану розуміти рекурсії. 

	- Є задача - додати всі елементи масиву і є масив з елементами 2, 4, 6

		- По принципу розділяй і володій, мені спочатку треба оприділити базовий випадок і зробити щоб робота рекурсії прямувала до нього. Найпростіше що я можу придумати в цьому випадку - це пустий масив або масив з одним елементом - СУПЕР - підходить, тоді рекурсія буде робити щоб в масиві стало менше елементів. І в ідеалі шоб кожний раз коли відработає рекурсія, треба щоб я був ближчий до цілі.

			СОВЕТ - Когда вы пишете рекурсивную функцию, в которой задействован массив, ба­зовым случаем часто оказывается пустой массив или массив из одного эле­мента. Если вы не знаете, с чего начать, - начните с этого.

		- Може і є така ф-ція, але наскільки знаю в джаваскріпті не має такого, що можна дістати суму всіх елементів масива. Тепер напишу кастомну. За один степ я можу виділити 1 елемент масива (перший наприклад). Якщо б я знав, що я буду працювати з масивами, які мають мільйони елементів, можливо можна б взяти за 1 раз і більше елементів з масива і це б скоротило к-сть степів в стільки раз скільки б я взяв елементів за 1 степ, але поки візьму 1.

			- Мабуть якби я працюва з мільярдними масивами, требаб було б робити якиїсь бінарний пошук щоб взнати оптимальне число елементів, яке треба було б додавати за 1 раз. Але мені поки хватить так, що буду брати 1 елемент масива за 1 степ.

			- Тож я можу виділити 1 елемент з масиву і ддавати до нього остальну частину масиву до тих пір поки в масиві не закінчаться елементи. 

				- В цьому і буде полягати моя рекурсія - типу 1-й спеп - x[0] + [5 elements], 2-й спеп - x[0] + [4 elements] ...  		 

		- Для цього підійде Метод slice() извлекает часть строки и возвращает новую строку - тобто був масив з 3-ма елементами, а слайс видалить 1(у моєму випадку перший) елемент і поверне масив уже з двома елементами. 

			function sumRecursive(arr) {
			  if (arr.length == 1) { // - це буде базовий випадок. До цього буде стремитись рекурсія.
			    return arr[0];
			  }
			  return arr[0] + sumRecursive(arr.slice(1)); // - вирізати перший елемент з масиву. Тобто наступного разу ф-ція sumRecursive буде працювати з меншим масивом.
			}

			console.log(sumRecursive([2,4,6])); // 12

			- Наглядно це працює так - http://joxi.ru/8AnEVnwuzWzJj2 - Тобто на останньому элементі клубок розплутається і остання ф-ція викинеться із папяті і її значення повернеться попередній ф-ції. А виглядає цей графік парабулою тому що воно так і є - спочатку йде вниз щоб розплутати цей клубок, щоб взнати що за значення будуть у sumRecursive(arr.slice(1), а потім йде вверх коли вже замість ф-ції підставляються значення (arr[0] + 6 наприклад)

				1) Остання - sumRecursive([6]) // return 6; - це значення повернулось передостанній - тобто передостання повернула - return 4 (arr[0] передостанньої) + 6

				2) Залишилась перша - Остання повернула 10 (4 + 6), тоді перша поверне 2 + 10. Результат виконяння ф-ції - 12.

			Перевірити це можна, якщо вивести в консольці в ф-ції sumRecursive() значення arr[0]. У кожного блока памяті воно буде різне, так як у наступну рекурсивну ф-цію передається масив без першого елемента масива і вкінці в останню ф-цію передасться масив з одним останнім елементом.  


	-----------------------------------------------------------------------------------------------------

	- return arr[0] + sumRecursive(arr.slice(1)); - sumRecursive(arr.slice(1)) - це завжди якесь конкренте значення тому що ця ф-ція повертає значення. Я не додаю ф-цію чи масив, я додаю значення яке повертає ця фція. 

		- Але щоб взнати це значення, мені треба розплести цей клубок рекурсій. Так, при розплітанні получається що я додаю значення і ф-цію, але після розплінання на обратному путі, замість ф-ції підставляються значення.

		- Так, це важко зрозуміти тому що навіть коли думаєш як буде працювати це, получається щось типу - ф-ція яка відпрацює першою поверне 2 + somefunction(x - i) - і це запутано. Мабуть в такому випадку краще йти з кінця. Знайти коли клубок повністю розпутається (можна буде поставити флажок у кондішні що клубок розпутаний) і дебажити ф-ції вже з значеннями які повернула попередня ф-ція, а не з ф-ціями. Типу - перша поверне 1, друга 2 + 1, третя 3 + 3, ......   

	-----------------------------------------------------------------------------------------------------

				

		------ Тут я видаляв елементи з масива і додава видалені елементи між собою поки в масиві є елементи. В принципі якщо подумати, то якщо б не було циклів у скріпті, не так багато варіантів можна придумати. Я ще придумав що можна було б прибумати якиїсь щотчик, який би перемішався при кожному степі рекурсії. Суть у тому, що принцип той самий - спочтку треба оприділити базовий випадок - кінець масива - а потім стремитись до нього при кожному степі рекурсії. -------- 

 8) Вправа - Напишите рекурсивную функцию для подсчета элементов в списке. для цього ж масива вверху. Це треба уявити що [].length в скріпті немає. По суті це те саме що вверху я писав, тож якщо буду перечитувати це, можна буде це пропустити.

	1) Оприділяю базовий випадок - для мене буде коли в масиві не буде елементів (нагадаю що [].length не має і тому я не вибрав варіант коли в масиві є 1 елемент тому що не знаю як оприділити чи в масиві є 1 елемент).

	function countArray(arr) {

	 if(!arr[0]) {
		return 0;
	 }

	 return 1 + countArray( arr.slice(1) );

	}

 9) Вправа - знайти найбільше чило в масиві

	function maxNum(arr){

	if(!arr[0]){
		return 0;
	}

	 return max = arr[0] > maxNum(arr.slice(1)) ? arr[0] : maxNum(arr.slice(1)); - Якщо число зліва більше як всі числа справа, поверни число зліва і навпаки. Коли рекурсія буде розплітатись, справа буде все менше і менше елементів. Тобто зрівнювання елементів буде справа на ліво 

	}

	





