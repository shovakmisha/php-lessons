1. Ф-ція mkdir(); - попробує создати папку.
	- аргумент recurcive створить файли, яких немає насправді. типу я написав mkdir("/home/.ssh/old/", 0700(права на папку (0 - це якщо хочу у двыйковый системі) ), true) - почне з корневої папки, зайде в home, але папки .ssh немає, він спочатку створить її, а потім створить вже папку old
	- але він не створить папку у родительській категорії, якщо у нього немає доступу
	- Ці правила справедливі і для створення файлів
2. Ф-ція chdir() - змінити директорію
2. Ф-ція rmdir() - видалити директорію
2. Ф-ція кmdir(); - попробує удалити папку. Може удалити тільки пусту папку, і якщо я маю на це права. Взагалі для операцій з файлами, потрібно мати права на це права.
3. Ф-ція getcwd(); - повний шлях до текущої папки починаючи з корня
4. Ф-ція opendir(тут указати шлях); - відкриє папку. (тіпа подвійного клацання миші)
4. Ф-ція closedir(ідетифікатор директорії); - вийти з папки. Працює це так - відкриваю папку ф-цією opendir і поміщаю цей процес у змінну. А у дужки ф-ції closedir(); поміщаю цю змінну. Хоча може й можна працювати з шляхом.
	- Якщо взяти у змінну, там буде шлях до папки
	- Взагалі цей процес роботи з папками буде схожий на роботу з файлами ( fopen() ). Типу не треба залишати директорію відкритою і т.д
5. Ф-ція readdir(); - повертає імя слідуючого елемента в папці. Але не забувати, що папка може називатися papka.txt Якщо взяти ф-цію у змінну, там буде імя файла
	- Типу цією ф-цією можна  перевіряти файли в каталозі. Вона повертає ідентифікатор текущого файлу
	- Скоріш за все слідуючий файл, який вибере ця ф-ція буде залежати від дати створення
	- коли вона дійде до кінця, і не буде вже файлів, повернеться false. Бути уважним при роботі з циклами, оскільки якщо я напишу - while ($e = readdir() ), то цикл зупиниться, якщо файл називається 0. Краще написати while ($e = readdir() !== false )
 - Шоб перевірити чи це файл чи папка є ф-ції 
	- is_file(); - true, якщо файл існує
	- is_dir(); - true, якщо папка існує
5) Ф-ція rewinddir() - Внутрішній вказівник знов буде починатись спочатку ( можна використати для ф-ції readdir )
6. Ф-ція scandir(); - поверне масив, у якому будуть елементи текущої папки. Відсортує елементи по алфавіту у нормальному або у обратному порядку
7. Ф-ція glob(); - ця ф-ція підійде, якщо треба взяти в масив якісь конкретні файли з папки // glob('*.txt') - візьме всі файли, у яких закінчення (.txt)
8. Загрузка файлів на сервер. Декілька директив для цього процеса. Ці настройки можна змінити у файлі php.ini
	- file_uploads - false/true. Чи можна загружати файли на сервер
	- upload_max_filesize - Максимальний розмір загружаємого файла (2мб п/м).
	- post_max-size - Максимальна довжина файлів (2мб п/м)
	- upload_tmp_dir - шлях до временної папки. Справа в тому, що сервер не зразу загружає файли туди, де мені треба, спочатку він загрузить елементи у временну папку
	- max_input_time - час, за який сервер має розібратися з вхідними даними. Тобто, якщо файл не встигне загрузитися за час який я задав або вже заданий у max_input_time, то загрузка перерветься.
	- max_file_uploads - задає максимальну к-сть загружаємих файлів.
9. Файли на сервер відправляються через форму, методом POST.
	- enctype має бути multipart/form-data (не знаю який по умолчанію). Інакше пошлеться тільки шлях файла.
	- input має мати тип file
	- щоб указати максимальний розмір загружаємого файла, можна перед <input type='file'>, написати <input type='hidden' name='MAX_FILE_SIZE' value='30000(розмір)'>
10. $_FILES[] - масив для загружаємих файлів. Це двовимірний масив, верхній масив - це імя input(а), а у внутрішньому є 5 частин
	1) - $_FILES['userfile']['name'] - імя файла
	2) - $_FILES['userfile']['type'] -тип файла (txt, jpg). Не кожен браузер передає
	3) - $_FILES['userfile']['size'] - Розмір файла (у байтах)
	4) - $_FILES['userfile']['tmp_name'] - Временне імя файла. Зазвичай воно складаеться з шляху, де файл лежав у користувача. Це зроблено для того, щоб у временну папку не загружалися файли з одинаковим іменем.
	5) - $_FILES['userfile']['error'] - Код ошобки, которая может возникнуть при загрузке файла. Типу по них можна оприділити, яке повідомлення показати користувачу при помилці
11. Помилки при загрузці файла. Можна до них звертатися як хочу. Можна через імя, можна через число. 
	- UPLOAD_ERR_OK[0] - все добре
	- UPLOAD_ERR_INI_SIZE[1] - Размер принятого файла превысил максимально допустимый размер. Розмір файлів форми.
	- UPLOAD_ERR_FORM_SIZE[2] - Размер загружаемого файла превысил значение MAX_FILE_SIZE (розмір, що указаний у скритому полі форми над <input type='file'>) 
	- UPLOAD_ERR_PARTIAL[3] - Загружаемый файл был получен только частично.
	- UPLOAD_ERR_NO_FILE[4] - Файл не был загружен
	- UPLOAD_ERR_NO_TMP_DIR[6] - Отсуцтвует временная папка
	- UPLOAD_ERR_CANT_WRITE[7] - Не удалось записать файл на диск. Вроді тому, що нема прав.
12. Ф-ція move_uploaded_file(); - переміщає файл з временної папки, у желаєму. Перед тим як перемістити, перевіряє чи загрузився файл через протокол HTTP. Якщо не вдалося перемістити файл, повернеться false.
	- Можна використати і ф-цію copy(); , але тоді не перевіриться чи файл був загружений через протокол HTTP, а це важливо з точки зору безпеки. Хоча є отдільно ф-ції, які це перевіряють.
13. Вроді временна папка, яка принімає загружені файли - одноразова. Файли у временній папці храняться доти, поки я їх не заберу скріптом. Якщо не заберу звідти файл зразу, файл удалиться.
14. PHP не відправляє письма, він каже серверу, відправити письмо. Тож якщо ф-ція mail(); - повернула true, це означає, що письмо передалося на поштовий сервер, а не те, що письмо відправилось на пошту.
15. Через ф-цію mail(); можна посилати заголовки. Заголовки вказуються вкінці.
	 - по суті smtp сервер це теж сервер. Отже йому можна посилати заголовки. Всі аргументи, що я ввів у ф-ції mail це заголовки. 4-й аргумент у цій ф-ції може ствоювати заголовки кастомно. Заголовків є трохи, тому не буду вказувати всі. наприклад TO - замінить адресу отримувача або Content-type - тут можна вказати тип контенту(текст наприклад), кодіровку..
	- наскільки я знаю \r\n це кінець запроса, але спеціаліст звязував всі заголовки через \r\n; кидав їх 4-м аргументом і канало - $headers = "To : <lala@mail.ru>\r\n"; $headers.="..." 
16. MYSQL - регістронезависимий, але прийнято писати оператори великими буквами.
17. По умолчанію оператор SELECT вибере елементи у тому порядку, у яких я їх заніс у БД. Але це не аксіома і не правило, просто зазвичай так є.
	- Але коли я вибираю елементи через оператор SELECT, то елементи будуть розташовані у тому порядку, у яких я запросив. // SELECT e1, e2, e3 - e1 буде перший і т.д
18. Рекомендуєся не використовувати оператор *
 - первичний ключ не обовязково число але обовязково унікальний
 - Ці всі команди, що описані внизу мали б працювати на всіх базах даних. Це типу стандарт для всіх. Но ето не точно
19. LIKE - схожий. Разом з LIKE  використовують оператор %(хоть-шо). // SELECT * FROM table WHERE lenght > 0 AND title LIKE 'web%' - Вибрати все з таблиці table, де довжина більше нуля і поле title містить 'web'. Тобто webmaster теж вибереться. % можна ставити де завгодно ю%код
	- також є оператор =(дорівнює), але це рідко підходить, бо це жосткий оператор. Якщо я написав = 'іван', то вибереться тільки 'іван'.
20. Мош обдиняти таблиці INNER JOIN або просто JOIN, но туй не напишу як, бо мало запутано. 
21. Можна звернутися до поля таблиці у такому вигляды - таблиця.поле
	- Це використовуэться тоді, коли треба взяти два одинакові поля з різних таблиць. Я ж не можу написати SELECT id, id FROM table1, table2
 - DISTING - Вибрати унікальні значення - SELECT DISTING name FROM mytable
22. Можна дати псевдонім таблиці, просто написавши його після таблиці // SELECT * FROM table1 PSEVDONAME
	- Можна дати псевдонім полю, просто написавши його після таблиці SELECT pole as psevdonimPolya. І вже в результаті виведеться не pole a psevdonimPolya
 ON - типу WHERE але краще загуглити
23. LEFT OUTER JOIN (можна без OUTER)теж саме, що і INNER JOIN, але у цьому випадку пристикуються і ті поля які не соотвецтвуют требованіям і у присоединяємого поля буде значення NULL.
25. Якщо при операції INSERT я залишу якесь поле пустим, то зазвичай у нього запишеться NULL. Це архітектор вирішує.
24. У mySql строка не лапки, а апострофи
25. Якщо я знаю всі значення, які буду вносити в таблицю, можна написати INSERT INTO table VALUES (перечислити всі значення і вони вставляться попорядку)
26. З DELETE осторожно, бо аж не вказати WHERE, удалиться все з таблиці.
27. З UPDATE тоже треба осторожно, бо аж не конкретізізувати, обновится всьо.
28. Оператор IN. Запис SELECT * FROM customers WHERE city = 'Краснодар' OR city = 'Белгород' OR city = 'Москва'; мош скоротити до SELECT * FROM customers WHERE city IN('Краснодар', 'Белгород', 'Москва');
	- не тільки для селекта а й для інших
	- Если же вам наоборот, нужно найти всех заказчиков, которые не находятся в этих городах, то добавьте NOT перед IN.
25. Создавання таблиці: - создати таблицю - CREATE DATABASE імя
CREATE TABLE items(
	id - int NOT NULL auto_increment,
	title varchar(255) NOT NULL defaul '',
	description varchar(255) NOT NULL default '',
	content text,
	author varchar(50) NOT NULL default '',
	pubdate timestamp NOT NULL default '',
	PRIMARY KEY (id) (первичний ключ)
)
26. Щоб покласти первичний ключ у phpmyadmin, у стовбці індекст вибрати PRIMARY

20) Зазвичай на машині, з сайтом є веб сервер апач, сервер майскюл, і поштовий сервер. Кожен з них можна замінити на який хочу
	- на кожному з них є своя айпі адреса і свій порт
	- апач обслуговує сайт. Можна сказати папки. Дані які приходять з браузера посилаються на сервер. Він віддає їх на обробу серверній технології (пхп). Пхп розрулює це все і посилає дані вебсерверу обратно, а вебсервер вже віддає браузеру. Суть в тому що тільки пхп зєднує ці 3 сервери між собою. напряму апач і поштовий сервер або ескюел не зможуть звязатись і взагалі знати один про одного
 	- в приципі те ж саме з поштовим сервером і з майскюелем. Кожен з них містить дані з папками. Тобто - дані з електронними адресами відсортовані по папках. Кожна пошта має свою папку. Дані в цій папці теж відсортовані по папках
	- З бд те саме. Кожна таблиця в отдільній папці
