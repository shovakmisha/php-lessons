1. Звертання до БД досить ресурсозатратно. Якщо можна зробити операцію без запросу до БД, краще зробити.
2. Сесія - хранилище для даних (текстовий файл ses_......), до якого є доступ у всіх сторінок на сервері. У спеціаліста сесія хранилася на локальному хості, і він казав, що у кожного хоста різна папка(для временних файлів), яка создає для кожного користувачача нову сесію. Сесія існує поки не закриється браузер.
3. Щоб оприділити, для кого яка сесія використовується кукі. Через кукі сервер посилає користувачу ідентифікатор сесії(ses_......) і імя сесії (Можна назвати як хочу, по умолчанію - PHPSESID). Файл сесії можу подивити, якщо захочу. Можливо навіть редагувати щось внутрі файла (там не важко розібратись).
4. Ф-ція session_start(); - Відкриває сесію або підтримує сесію. У кожного файла, який участвує в сесії має бути прописана ця ф-ція.
5. Впринципі можна обійтися без сесії і написати все вручну, тобто создавати временні файли, генерувати id, посилати файл через кукі.... Просто PHP зробив це все за нас.
6. Елементи сесїї хранятся у суперглобальному масиві $_SESSION і працювати з елементами можна так само як із простим масивом
7. session_destroy(); - Очистить масив $_SESSION.
8. Щоб видалити і сам файлик сесії, треба видалити сесію з кукі. // setcookie(session_name(), '');
9. Сессія: ф-ції
	- string session_name([string $name]); - Ім’я сесії
	- string session_id([string $id]); - Ідентифікатор сесії
	- bool session_regenerate_id([bool $delete_old_session= false]); - Сесія завжди буде з новим ідентифікатотом або кожного разу буде создаватися новий файл сесії
 - директиви(настройки) у файлі php.ini
	- session.auto_start (boolean)['o'] - буде создаватися сесія без ф-ції session_start();
	- session.name (string)['PHPSESSID'] - як буде називатися ім’я сесії
	- session.save_path (string)[''] - де буде хранитися файл сесії
	- session.gc_maxlife
time (integer)['1440(секунди)'] - Сборщик мусора. Уб’є сессію, якій зійшов час. Тобто, кожного разу, коли я відкриваю сторінку, запускаєся тамер (по умолчанію 1440 секунди ), і якщо я не роблю ніякі дії на сторінці, 1440 секунди сесія умирає.
	- session.cookie_lifetime (integer)['o'] - Скільки часу змінна буде хранитися в кукі, недивлячись закритий буде браузер або відкритий. 
	- session.use_cookie (boolean)['1']
	- session.use_only_cookies (boolean)['1' починаючи з PHP 5.3.0] - Використовувати тільки кукі. Це для безпеки. Якщо у користувача відключені кукі, то не треба приклеювати сесію до сторінки методом GET.
	- session.use_trans_sid (boolean)['o'] - На випадок, якщо відключений кукі. Якщо поставити '1', PHP юуде приклеювати сесію до сторінки методом GET
10. Ф-ція parse_ini_fail(); - Зачитує файл з розширенням 'ini', як асоціативний масив. До дорівнює - ключ, після дорівнює - його значення.
11. Ф-ція file_exist(); - провірить, чи існує файл або папка.
	- is_file(); - провірить, чи існує файл.
12. Ф-ція filesize(); - получить размер файла
12. Ф-ція is_dir(); - чи існує директорія(папка) // is_dit("/images");
13. Ф-ція fileatime(); - получить время последнего доступа к файлу
14. Ф-ція filemtime(); - получить время последнего изменения файла
15. Ф-ція is_readable(); - Определяет, доступен ли файл для чтения
16. Ф-ція is_writable(); - Определяет, доступен ли файл для записи
 - Файли. режими роботи.
	- 'r' - Відкриває файл тільки для читання. Поміщає указатель в начало файла.
	- 'r+' - Відкриває файл для читання і запису. Поміщає указатель в начало файла.
	- 'w' - Відкриває файл тільки для запису. Поміщає указатель в начало файла і обрізує файл до нулевої довжини. Если файл не существует - потребует создать.
	- 'w+' - Відкриває файл для читання і запису. Поміщає указатель в начало файла і обрізує файл до нулевої довжини. Если файл не существует - пытается создать.
	- 'a' - Відкриває файл тільки для запису. Поміщає указатель в кінець файла. Если файл не существует - пытается создать. ГЛЮЧНИЙ
	- 'a+' - Відкриває файл для читання і запису. Поміщає указатель в кінець файла. Если файл не существует - пытается создать.
	- 'x' - Создает и открывает только для записи. Поміщає указатель в начало файла. Если файл уже существует, вызов fopen() закончится неудачей, вернет FALSE и выдаст ошибку уровня E_WARNING. Если файл не существует, попытается его создать.
	- 'x+' - Создает и открывает для чтения и записи. Иначе имеет то же поведение что и 'x'
17. Тип resource - шлях до файлів.
18. Ф-ція fopen('шлях до файла', 'режим роботи(r наприклад)'). Можна взяти цей процес у змінну і далі можна буде файл закрити
	- $handle = fopen("file.txt", "r") or die('Помилка'); - Відкриває файл file.txt тільки для читання. Поміщає указатель в начало файла.
	- fclose($handle); - закриє файл. Старатися не залишати файл відкритим, краще закрити. Хоча він і так закриється. Можлива така ситуація, що після відкриття файлу, зєднання може не закритись, а це лишня нагрузка на сервер і тд. В фтп зєднанні використовужться буферизація файлів, тож там особливо важливо закривати зєднання, щоб бути впевненим, що файли передались
	- r - права на файл - типу чмод ... Ще задаютья симвли b або t. b буде означати, що це бінарний(Віндовс за замочуванням так відкриває), а t - текстовий. Рекомендується вказувати якийсь з цих символів на всяк випадок, щоб система точно розуміла що це за файл
	- У змінній $handle буде тип змінної і ідентифікатор // Resource id #3
	- Можна ще вказати щоб він шукав файли у підключенихи кусків коду(інклюд) не з точки зору текущого файлу, а звідти де вони знаходяться, але це не треба використовувати
	- Можна вказати і повний шляж до файлу з хттп(фтп), тоді він буде відкривати зєднання і т.д, хоча фтп не підтримує зрау і читання і запис. Тільки одне з двох. 
	- Конструкція or die('name error') тут дуже корисна. Оскыльки в цього оператора дуже низький приорітет, то він не присвоїться зміннійю. Тому що я не хочу щоб змінній присвоївся die('name error') а хочу щоб було так, що якщо вів відкрив файл - працюємо далі, не відкрив, змінній присвоїться фолс, і вже тоді зявиться ця помилка
19. die таке саме як і exit. Можна з дужками(), можна без дужок.
20. Ф-ція fread(); - читає файл із місця де курсор, доки скажу// fread('файл', скільки символів із нього прочитати (указуєся в байтах) ); Учитуются і пробели і т.д.
	- Він не просто читає, а й переміщає указатель туди, де зупинився.
	- Якщо я хочу, щоб він прочитав весь документ, то можна вказати велике число(від фонаря) або ф-ція filesize();
21. Ф-ція fpassthru(); -Читает указаный файйловый указатель с текущей позиции до конца файла и записывает результат в буфер вывода. 
	- Короче виведе весь файл, починаючи з місця де курсор. Щоб вивести, не треба echo, ф-ція сама виведе.
22. Ф-ція fgets(); - Прочитать строку из файла. Щоб краще розуміти - якщо пробігтися по текстовому файлу циклом foreach, то кожного разу у зміній буде нова строка. 
22. Ф-ція fgetss(); - Читает построчно, вирізуючи всі теги. Якщо я хочу залишити якісь теги, написати їх в дужках.
 - file() - Спеціаліст зробив файл масивом, розмарсивши кожну строчку ключем. І при провірці на масив, видавав true 
	- Також у дужках треба вказати максимальну довжину строки // fgetss($f, 999, '<a>');
	- Якщо у строці, тільки тег, то строка не видалиться, просто виріжеться тег.
	- Ф-ція feof(); - схоже, але повертає false, коли він вперся в кінець файла. Можна для циклів використати
22. Ф-ція fgetc(); - Читает побайтово.
	- Вроді 1 байт == 1 символ. А може все залежить від кодіровки.
22. Тож мабуть якщо є фції, які повертають довжину файла у байтах, а 1 символ = 1 байт, з файлом легко буде працювати, типу ф-ції цикли
23. Ф-ція fwrite(resource $handle, string $string[,int $length]); - Записывает содержимое string в файловый поток handle.
	- если передан аргумент length, запись остановится после того, как length байтов будут записані или будет достигнут конец строки string, смотря что призойдет первым.
	- Возвращает количество записаных батов или FALSE в случае ошибки.
	- Ф-ція fputs(); - аналог fwrite();
	- Запись буде осуществлятися на місце курсора, але не перед буквов, а під буквов. Тобто буква буде змінена на те, що вкажу. Тобто для редагування файлу, краще створити тимчасовий файл, записати туди все що треба і його содержиме кинути знов сюди
23. Спеціаліст завжди працював зі змінною, у яку повернувся результат ф-ції fopen(). Тож може це і єдиний або найкращий варіант. 
24. У windows перевод строки \r\n У всі інших просто \n. Коли я працюю з текстовими файлами з PHP це важливо. Тож краще вказувати у настройках текстового редактора Unix. Це всіх устройит, крім стандартного блокнота Windows.
25. Ф-ція fseek(recource $handle, int $offset[,int $whence]); - зміщує курсор у файлі.
	- $offset - куди зміщувати курсор. Може бути як плюсове, так мінусове число
	- Константи для $whence
		- SSEK_SET - Ф-ція покладе курсор на початок тукстового документа (по умолчанию) і звідти почне працювати.
		- SSEK_CUR -  Ф-ція залишить курсор текущому місці і звідси почне працювати.
		- SSEK_END - Ф-ція покладе курсор на кінець тукстового документа і звідти почне працювати.
	- Хоча є вірогідність, що ця ф-ція може працювати тільки локально.
	- Також ця ф-ція поверне 0, якщо все ок і -1, якщо не все ок
26. Ф-ція ftell(recource $handle) - Сообщає де курсор.
26. Ф-ція rewind(recource $handle) - Сбрасує курсор.
26. Ф-ція feof(recource $handle) - Проверяет, достигнут ли конец файла.
27. Є ексклюзивное запирание файла, но я не поняв, нашто вто.
28. Ф-ція ftruncate(); - Обрізує символи у строці.
	- Але позиція курсора не зміниться. місце, де були символи, заповниться пустими байтами.
29. Ф-ція readfile(); - Виводить весь файл без echo. Ця ф-ція теж саме, що fopen() + fread() + fclose()
 - Короче є багато ф-цій для роботи з файлами і строками. Краще загуглити.  
	- Наприклад копіровати, переіменувати, удалити....

 - file_put_contents - Функция идентична последовательным успешным вызовам функций fopen(), fwrite() и fclose().
	- Если filename не существует, файл будет создан. Иначе, существующий файл будет перезаписан, за исключением случая, если указан флаг FILE_APPEND. 
	- її використав спеціаліст.

 - file_get_contents() - зачитує содержиме файла.
	Короче сенс у тому, що є ф-ції зручніші описаних вище для роботи з файлами, але краще загуглити ніж тут писати

 - Log файл php сприймає як масив по ходу ( типу файл ini ). У тестовому магазині я розбивав файл по строках без ф-ції fgetss(); Типу print_r(file.log); - виведе файл як масив.
	- Те ж саме стосується файлів у яких перший символ крапка - .lalala



