1. GOOKIE - Я кажу браузерови сохранити дані. // Set-Cookie: name= Міша;
 - GOOKIE - це 1 із заголовків ( так як і GET, POST, SERVER...)
2. Ф-ція setcookie(); - добавляє елементи в кукі. // setcookie(string $name[,srting $value [,int $expire=o[,string $path[,sting $domain [,bool $secure=false[,bool $httponly=false]]]]]]);
	- $name - імя. Імя не може містити дефіс. Якщо я покладу дефіс, PHP переіменує це у нижнє підчеркування.
	- $value - значення
	- $expire - скільки часу, буде елемент хранитися в GOOKIE. Вказувати у timestamp // setcookie("TestCookie", $value, time()+3600); - буде хранитися 1 годину. По умолчанію (якщо не вказувати цей параметр) браузер буде хранити дані, поки відкритий браузер.
	- $path - тут указувати конкретніше, які елементи сайта можуть передаватися в GOOKIE. Хоча скоріш за все це не так. Коли я посилаю куку, я вказую папку, у яку її треба буде відправляти браузеру, а якщо її не буде, то незнайшовши цю папку, кука не прийде. Уцьому параметрі можна вказувати папку, куди має приходити кука
	- $domain - ут указувати конкретніше, які домени(поддомени) можуть передаватися в GOOKIE.
	- $secure - Якщо покласти 1(true), то кукы буде віддаватись тільки при https. При http не буде.
	- $httponly - Скаже щоб браузер давав елемени користувачу тільки по протоколу http. Справа в тому, що Звертання до GOOKIE не йде по протоколу http. А у java-script є ф-ція document.cookie, яка вкаже всі кукі.
	- повністю - setcookie("TestCookie", $value, time()+3600, "/docs/", ".explame.com", 1);
3. GOOKIE бувають довговременний і коротковременний. Коротковременний(сесіонний) - поки відкритий браузер.
4. GOOKIE - це не кеш. Взагалі браузер хранить GOOKIE у кеші, але не повністю. Залежить який браузер.
5. Якщо я дав браузеру вивести хоча б 1 символ, GOOKIE вже на можна передати (setcookie(); - буде помилка). Звідси й береться UTF-8 без BOM. BOM - це 3 символи, які добавляє текстовий редактор в началі документа. А наскільки я знаю у php-документі все, що не знаходиться у <?php ?>, перед усім кладеться echo.
	- Коли я перевіряв, у мене помилки хромови була помилка, а у мозілі не було.
	- Також за цим треба слідкувати у підключаємих файлах, , щоб після '?>' нічого не було. Навіть рекомендується у підключаємому файлі не писати закриваючий тег '?>' 
	- Запутано. Ця помилка буде тому, що спочатку сервер дає браузеру заголовки, а потім саму сторінку(<html>...). Після заголовків браузеру передаеться пуста строка, що означає, що заголовки закінчились, далі буде передаватись сторінка. Тож коли браузер починає розбирати, що йому прислав сервер, він бачить - першим ділом заголовки(header. Навіть якщо я нічого не писав, є заголовки, які предаються по умолчанію) і виглядає це так <?php header(...) ?>. А потім сама сторінка, яку він виводить - echo <html>.... Тож коли на початку документа перед <?php header(...) ?> буде пуста строка ( echo \n ), або ще щось, то це й буде ця помилка. Тобто я хочу добавити заголовки на сторінку, після того як вивелось echo.
6. Всі дані GOOKIE храняться у глобальному масиві $_GOOKIE 
5. Видаляти кукі можна, якщо поставити йому дужк малий час існування setcookie("TestCookie", $value, 1);
	- Або якщо у GOOKIE є $name, але нема $value, PHP її видалить.
6. У GOOKIE мож посилати масиви, айбо звичайні він не зрозуміє, треба обробити його ф-цією serialize($array); // Є масив $user = array('name' => 'John', 'login' => 'root'); Обробляю його ф-цією і заношу в змінну x - $x = serialize($user); Буде - a:2:{s:4:"name";s:4:"John";s:5:"login";s:4:"root";} Тобто a(array/масив):2(із 2-х елементів):{s(строка):4(із 4-х елементів):"name";s:4:"John";s:5:"login";s:4:"root";}
	- І тепер залишилось дати імя масиву і занести його в кукі. setcookie('імя', $x);
	- Щоб зробити із GOOKIE-шного масива, звичайний, є ф-ція unserialize(); // $z = unserialize($_COOKIE["user"]);
	- По ходу GOOKIE-шний масив, це строка.
	- Коли я обробив його setcookie, потім цей результат краще обробити ф-цією base64_encode() (base64_dencode() для розшифровки). Щоб краще фохранились дані
7. Метод head - теж саме, що і get, але без тіла, просто заголовки.
8. Я можу вказувати, які заголовки буде посилати сервер браузеру.
10. Заголовки так само як і кукі мають бути до того як щось виведеться.
9. Ф-ція header(); - посилає заголовки.
10. Location - перенаправляє на інший сайт (Методом Get). // header("Location: http://site.ua");
	- Location пошле браузеру статус 302(по умолчанію). 302 статус каже, щоб браузер кожного разу перевіряв цей адрес, перед тим, як іти на новий. Бо можна вказати 301 і браузер не буде перевіряти старий адрес, зразу піде на новий. У кожного браузера різні способи запоминання.
	- 301 статус можна вказати 2-ма способами, перший неудобний, а 2-гий - header("Location: http://site.ru", true, 301);
	- 302 статус підрозуміває тимчасовий переїзд сторінки
	- Після Location спеціаліст клав exit; щоб скріпт не робив в холосту. теж саме робить die
	- Location не покаже сторінку, з якої я перенаравляю.
11. Кнопка 'обновить страницу' == првторить предыдущий запрос.
 - пфсля того як відправилась форма, стеціаліст у файлі, який принімав форму, після її обробки, робив локейшн на цю ж саму сторінку. Оскільки рефреш сторінки - це првторить предыдущий запрос, то форма відправляється ще раз. Оскіли предидущий запрос був відправити форму і ґґ дані. А якщо заголовком зробити локейшн на цю ж саму сторінку, то предыдущий запрос був - дай мені цю сторінку методом гет
12. Refresh - Запрос сеевера (Обновить сторінку, хочу у спеціаліста вона не перезагружалась, або так працює аякс, або у нього мало було контенту на сторінці і не було помітно )у // header("Refresh: тут указувати через скільки секунд");
	- Можна використати як перенаправлення на іншу сторінку. // header("Refresh: 3(секунди); url= http://site.ua");
	- Refresh покаже сторінку, з якої я перенаравляю. Можна використати, як через n секунд ви перейдете на інший сайт.
13. Коли браузер запрашує щось із сервера по якомусь адресу (http://site.ua), він не знає, що там буде. Щоб він знав, Сервер посилає йому заголовки. Наприклад, щоб він знав, що йому посилається html, сервер посилає йому заголовок Content-type: text/html; Тобто навіть якщо є сторінка з розширенням 'html', а я напишу header("Content-type: text/xml"); - браузер буде читати його як 'xml' файл.
	- По ходу у PHP приорітет вищий ніж у HTML
14. у PHP є заголовки, які якщо я не вкажу, вони всерівно пошлються. Бо це у PHP у настройках по умолчанію. Звичайно я їх можу змінити. Наприклад  по умолчанію браузер читає документ як текстовий файл якогось формату (вроді).
	- Но якщо я у файлі напишу заголовок, у якому вкажу що цей файл не html, а текстовий наприклад, то браузер не буде показувати текст файла, а буде робити те, що у налаштуваннях браузера робиться з текстовими файлами (зазвичай скачується). // header("Content-type: file/octet-stream");<Він зрозуміє що це текстовий файл із за цього заголовка
15. Кеш - сайт хранится на локальному компютері і не просить запрос із сервера.
16. Cache-control: - управляти кешем.
	- Cache-control: no-cache; - видалить інформацію з кеша коли я закрию браузер.
	- Cache-control: no-store; - видалить інформацію з кеша коли я покину сторінку.
	- max-age - Максимальний час зберігання інформації в кеші. // header("Cache-control: no-store; max-age=10") - 10 секунд. або просто header("Cache-control: max-age=10") 
	- Expires: - до якого часу буде жити кеш. header("Expires: ".date("r"));
	- max-age має приорітет над Expires.
17. Буферизація - контейнер, куди намітуєся всяке. Мош туди писати любий код PHP. Буферизацією можна вирішити проблеми з заголовками. Можна накидати в неї все підрят, а вона потім все виведе правильно (Спочатку Заголовки, потім все інше).
	- ob_start - Включает буферизацию вывода
	- ob_get_contents - Возвращает содержимое буфера. Мош покласти у змінну і у змінній буде содержиме буфера. 
	- ob_flush - Посылает содержимое буфера, але буфер ще відкритий і у нього продовжують накидуватись елементи
	- ob_end_flush - Посылает содержимое буфера и выключает буферизацию
	- ob_clean - Очищает буфер
	- ob_end_clean - Очищает буфер и выключает буферизацию. Но якщо занести буферний код у змінну, і змінна буде у буфері, а я очистив буфер, змінна і її содержиме  вроді не удалиться.
	- Якщо я не закрию буферизацію, PHP поставить в кінці ob_flush() і буферизація виведеться.
18. Коли я посилаю інфу в кукі, це заголовок. Тобто header('Set-Cookie: name=John'). Ось чому буде помилка, якщо написати це після echo.
19. Хеширование - це закодірування. Ф-ція md5(); і є ще якісь вроді. Є декілька особливостей
	- строка з одинаковими символами дає одні і ті ж самі закодовані символи.
	- строка яка з’явилася після того як я пропустив її через ф-цію md5(); обратно перекодувати не можна.
	- спеціаліст рекомендував ф-цію password_hash(). Якщо присвоїти результат цієї ф-ції у змінну, то пароль можна буде звірити ф-цією password_verify();// php 5.5
20. Є проста аутентифікація з вспливаючим окном у якому звіряєтья общий логін і пароль. (Кінець 1-го уроку)
