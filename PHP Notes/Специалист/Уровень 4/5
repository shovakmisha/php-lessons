 ----- Регулярки. В принципі те саме що і в скріпті, тільки тут більше флагів і ф-ції для роботи з ними не так називаються 
1) В пхп 7 з регулярок видалили POSIX(ereg_), залишилось тільки PCRE(preg_), їх можна оприділити по префіксу preg_ Регулярки працюють стандартно, тобто береться якиїсь шаблон і накладається на строку. Наприклад слово ход у слові 'находити'. Cпочатку 'ход' прикладається до "нах" - не совпало, потім до 'ахо', не совпало, і тд  
	/./ - крапка це будь який символ крім перевода строки. preg_match('/./', 'PHP 5', $matches); - знайти будь який символ в 'PHP 5' $matches - це масив, у якому будуть дані що совпали. preg_match('/./', 'PHP 5', $matches); echo $matches[1]; // Р - типу змінна $matches буде в глобвльній області бачення 
		- preg_match('/PHP.5/', 'PHP 5', $matches);    echo $matches[0]; // РHP 5
		- preg_match('/PHP.5/', 'PHP-5', $matches); echo $matches[0]; // РHP 5
		- preg_match('/PHP.5/', 'PHP5', $matches); echo $matches[0]; // нічого не виведе, не совпало
// \ Экранирование метасимволов и разделителей
	- preg_match('/.com/', 'site.com', $matches);	echo $matches[0]; // .com
	- preg_match('/.com/', 'site-com', $matches);	echo $matches[0]; // -com
	- preg_match('/\.com/', 'site-com', $matches); echo $matches[0]; //
	- preg_match('/\.com/', 'site.com', $matches); echo $matches[0]; // .com

 - Повторения
/*
{m} точное вхождение
{m,n} минимум и максимум
{m,} минимум вказаний, максимум неограничено
*/

	- preg_match('/tre{1,2}f/', 'trf', $matches); echo $matches[0]; //
	- preg_match('/trе{1,2}f/', 'tref', $matches); echo $matches[0]; // tref
	- preg_match('/trе{1,2}f/', 'treef', $matches); echo $matches[0]; // treef
	- preg_match('/trе{1,2}f/', 'treeef', $matches); echo $matches[0]; //
	​
	- preg_match('/fo{2,}ba{2}r/', 'foobaar', $matches); echo $matches[0]; // foobaar
	- preg_match('/fo{2,}ba{2}r/', 'fooooooobaar', $matches); echo $matches[0]; // fooooooobaar
	- preg_match('/fo{2,}ba{2}r/', 'fobaar', $matches); echo $matches[0]; //

 - Повторення можна замінити Квантифікаторами
/* Квантификаторы
? что и {0,1}
+ что и {1,}
* что и {0,}
*/

	- preg_match('/PHP.?5/', 'PHP 5', $matches); echo $matches[0]; // PHP 5
	- preg_match('/PHP.?5/', 'PHP5', $matches); echo $matches[0]; // PHP5
	​
	- preg_match('/a+b/', 'caaabc', $matches); echo $matches[0]; // aaab
	- preg_match('/a+b/', 'cabc', $matches); echo $matches[0]; // ab
	- preg_match('/a+b/', 'cbc', $matches); echo $matches[0]; //
	​
	- preg_match('/a*b/', 'caaaabc', $matches); echo $matches[0]; // aaaab
	- preg_match('/a*b/', 'cbc', $matches); echo $matches[0]; // b​

Метасимволы
 - початок, кінець строки. Якщо помістити регулярку між ^xyz$, то це має совпадати слово повністю
// ^ Ограничение начала строки
	- preg_match('/^abc/', 'abcd', $matches);	echo $matches[0]; // abc
	- preg_match('/^abc/', 'xabcd', $matches); echo $matches[0]; //
​
// $ Ограничение конца строки
	- preg_match('/xyz$/', 'abcdxyz', $matches); echo $matches[0]; // xyz
	- preg_match('/xyz$/', 'xyza', $matches); echo $matches[0]; //

// [...] Kласс искомых символов. Якщо елементи будуть знаходитись у квадратних дужках [...], то це означає, що буде шукатись будь який з них //  [abc] - шукається хоча б a або b або c, 
	- preg_match('/[0-9]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // 1995
	- preg_match('/[^0-9]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // PHP is released in -Галочка внутрі квадратних скобок це отріціеіє - знайди те що не включає в себе числа від 0 до 9. ЗВЕРНУТИ УВАГУ, ПРОБІЛ ТЕЖ ШУКАЄТЬСЯ
	- preg_match('/[a-zA-Z ]+/', 'PHP is released in 1995',$matches);	echo $matches[0]; // PHP is released in
	- preg_match('/[^a-zA-Z ]+/', 'PHP is released in 1995',$matches); echo $matches[0]; // 1995 -Замість a-z можна вказати будь які букви, можна навіть [abcde...]

// (...) Группировка элементов.
	- $subject = 'PHP is released in 1995'; $pattern = '/PHP [a-zA-Z ]+([12][0-9])([0-9]{2})/';
		- preg_match($pattern, $subject, $matches); print_r($matches);  У перший так і попадає все повна строка совпадения, а в інші ключі попаде елементи з дужок // [0]=>PHP is released in 1995, [1]=>19, [2]=>05

 - В пхп регулярні строки це як строка а не обєкт на відміну в js. Тому їх треба писати а апострофах (не в лапках) - '/[^0-9]+/' . Тому що строка в лапках це ще не строка, вона парситься в строку. Тобто "4\*" це не кінечний варіант, кінечним варіантом цього буде просто зірочка "4*", тому якщо буду писати в лапках, то треба буде писати "4\\*", щоб воно шукало 4* а не - 4 може бути 0 а може хоч скільки
	- Всі спеціальні символи(? + ] ...) треба екранувати

 - Любое выражение начинается с символа-ограничителя (delimiter по англ.). В качестве него обычно используют символ /, но можно использовать и другие символы, не имеющие специального назначения в регулярках, например, ~, # или @ (Вроді спеціаліст казав, що замість слеша може використовуватись взагалі будь який символ, який не використовується в регулярці). Альтернативные разделители используют, если в выражении может встречаться символ /. Затем идет сам шаблон строки, которую мы ищем, за ним второй ограничитель и в конце может идти одна или несколько букв-флагов.

/*
\t \n \f \r (ASCII 9, 10, 12, 13)
\d ( [0-9] )
\D ( [^0-9] )
\s ( [\t\n\f\r ] ) - пробіл теж попадає
\S ( [^\t\n\f\r ] ) - як \s, але навпаки ( і без пробіла )
\w ( Любая буква, цифра, символ подчеркивания )
\W ( Противоположность \w )
* /
	
 - \b ( Позиция между соседними символами \w и \W ) - Схоже на \w, але тут підпаде тільки повне сходження. Типу решітки не в щот, тільки букви цифри
	$string = "##Testing123##";
		- preg_match('/\b.+\b/', $string, $matches); echo $matches[0]; // Testing123 - решітки не в щот
		- preg_match('/\bTesting\b/', $string, $matches); echo $matches[0]; // Не совпаде, оскільки це не повний вираз, повний Testing123

 - //\B ( Противоположность \b ) 

// Жадные квантификаторы: * и + ( В скріпті теж є жаднісь )
	$subject = '<b>I am bold.</b> <i>I am italic.</i> <b>I am also bold.</b>';
	preg_match('#<b>(.+)</b>#', $subject, $matches); 
	echo $matches[1]; // I am bold.</b> <i>I am italic.</i> <b>I am also bold. - Ось чому ці квантефікатири називаються жадними (* +), після того як вони знайдуть останній шаблон(</b>), вони продовжують шукати його далі по строці. Цю багу можна вилікувати за допомогою ? // preg_match('#<b>(.+?)</b>#', $subject, $matches); echo $matches[1]; // I am bold.
		Флаг U (PCRE_UNGREEDY) - Этот модификатор инвертирует жадность квантификаторов, таким образом они по умолчанию не жадные. Но становятся жадными, если за ними следует символ ?. Такая 			возможность не совместима с Perl. Его также можно установить с помощью (?U) установки модификатора внутри шаблона или добавив знак вопроса после квантификатора (например, .*?).
			- $subject = '<b>I am bold.</b> <i>I am italic.</i> <b>Iam also bold.</b>'; preg_match('#<b>(.+)</b>#U', $subject, $matches); echo $matches[1]; // I am bold.

 Модификаторы (флаги)
 - З регістронезалежним і з мультистроковим тут так само як і в скріпті
 // m Многострочный поиск
	$subject = "ABC\nDEF\nGHI";
	preg_match('/^DEF/', $subject, $matches);
	echo $matches[0]; // preg_match('/^DEF/m', $subject, $matches);
	echo $matches[0]; // DEF

// S Однострочный поиск: "." = . + перевод строки. Тобто якщо поставити цей флаг, крапка('/./s') буде крапкою, а не всім крім перевода строки і символи перевода строки будуть вирізатись
	$subject = "ABC\nDEF\nGHI";
	preg_match('/BC.DE/', $subject, $matches);
	echo $matches[0]; //
	preg_match('/BC.DE/S', $subject, $matches); у мене працювало тільки з малою s. і наскільки я зрозумів при парсінгу, він перетворює текст в одну строку, але запамятовує де вони були, тому при echo $matches[0]; виведеться BC\nDE. По ходу це придумали для того, щоб не писати флаг мультистрочності 
	echo $matches[0]; // BC\nDE 

​
// x Пропуск пробелов и комментариев(#) в тексте шаблона. Для читабельності регулярки можна використовувати пробіли і коменти. Щоб при парсінгу їх не враховувати, треба поставити флаг 'x'
	$subject = "ABC\nDEF\nGHI";
	preg_match('/A B C/', $subject, $matches);
	echo $matches[0]; //
	preg_match('/A B C/x', $subject, $matches);
	echo $matches[0]; // ABC

// D Что и $, если строка не заканчивается \n
	preg_match('/BC$/', "ABC\n", $matches);
		echo $matches[0]; // BC -Типу доллар по ходу не враховує перевод строки і всеодно вважає що строка закінчується на BC, а не на BC і пробіл вкінці, А з флагом D почне враховувати
	preg_match('/BC$/D', "ABC\n", $matches);
		echo $matches[0]; //
​// A Что и ^ (начало строки)
	preg_match('/[a-c]{3}/i', '123ABC', $matches);
		echo $matches[0]; // ABC
	preg_match('/[a-c]{3}/iA', '123ABC', $matches);
		echo $matches[0]; //

// Функции поиска 
	$subject = '<b>I am bold.</b> <i>I am italic.</i>';
	$pattern = '#<[^>]+>(.*)</[^>]+>#U';
	preg_match($pattern, $subject, $matches);
		print_r($matches); // [0]=><b>I am bold.</b>, [1]=>Iam bold.
	preg_match_all($pattern, $subject, $matches,PREG_PATTERN_ORDER);
		print_r($matches);


 - preg_match_all - те ж саме що і preg_match, але він працює не першого сходження, а знайде всі сходження. Типу флага global к скріпті. Дані що підходять він розкладе у багатовимірний масив. Яким чином він це буде робити, можна регулювати константами. Наприклад, можна вказати, що групіровані елементи будуть в одномі підмасиві з знайденим шаблоном чи отдільно.
	- $subject = '<b>I am bold.</b> <i>I am italic.</i>'; 	$pattern = '#<[^>]+>(.*)</[^>]+>#U';
		preg_match_all($pattern, $subject, $matches,PREG_PATTERN_ORDER);
		print_r($matches);
			// [0][0] => <b>I am bold.</b>, [0][1] => <i>I amitalic.</i>
			// [1][0] => I am bold., [1][1] => I am italic.

		preg_match_all($pattern, $subject, $matches,PREG_SET_ORDER);
		print_r($matches);
			// [0][0] => <b>I am bold.</b>, [0][1] => I am bold.
			// [1][0] => <i>I am italic.</i>, [1][1] => I am italic.

// Функция замены. До даних, що я згрупував у дужках, можна буде звернутись по принципу - доллар($) і порядковий номер даних у дужках 
	$subject = 'April 15, 2003';
	$pattern = '/(\w+) (\d+), (\d+)/i'; // '$1' '$2', '$3';
		$replace = '$2 $1, $3'; // "\$2 \$1, \$3" - Якщо у подвійних кавчках, то треба екранувати доллари 
		echo preg_replace($pattern, $replace, $subject); // 15 April, 2003

// Функция разделения
 - preg_split - типу explode, тільки регуляркою можу настроювати як хочу по чому розбивати. Вона варіативна, є різні константи для неї, її можна настроювати, не буду все розписувати, краще загуглити 
	$subject = 'hypertext language, programming';
	$pattern = '/[\s,]+/';
	$words = preg_split($pattern, $subject);
	print_r($words); // [0]=>hypertext, [1]=>language, [2]=>programming


 Флаг u - говорит, что выражение и текст, по которому идет поиск, исплоьзуют кодировку utf-8, а не только латинские буквы. Без него поиск русских (и любых других нелатинских) символов может работать некорректно, потому стоит ставить его всегда.












