- Шаблони проектування
1) Агрегація - коли обєкт без іншого може жити.
2) Композиція - коли обєкт без іншого не може жити.

- Я не зрозумів в якій степені мають бути залежності. Чи це видалення чи навіть редагування. У прикладі "Композиція" спеаціаліст стврорив клас і у цьому класі у конструкторі створив обєкт "Б" через оператор new. Потім від цього класа створив обєкт А. І коли видалити/видалити обєкт А, видалиться/створиться і обєкт Б.

3) шаблон білдер - типу jquery. Коли ф-ція повертає сам обєкт і бажано шоб метод дав підсказку що він робить. Щоб потім можна було бродити стрілками // $obj->remove()->addClass();

 - Взагалі шаблони проектування роздыляються на 3 групи. самих шаблонів є більше 20 і ще дописуються

Шаблоны проектирования
	 Порождающие шаблоны проектирования - вони створюють обєкт
		○ Factory Method/Фабричный метод - суть в тому що в залежновті від введених даних, я получаю інший функціонал. На тестовому прикладі у мене був 1 інтерфейс, реалізований у декількох класах з різним функціоналом. І був ще 1 клас який і вибирав який з вище описаний класів вибирати. Від цього класа я й робив обєкт. У нього був метод, який по аргументу оприділяв який саме клас я буду використовувати. Тобто я спочатку поклав у змінну обєкт з класом який вибирає потрібний клас, а потім поклав у змінну метод, який викликається у цьому обєкті з потрібним аргументом // $f = new ShapeFactory(); $r = $f->getShape('r');
		○ Abstract Factory/Абстрактная фабрика - я так зрозумів, це те саме що фабрика, тільки коли інтерфейсів більше як 1
		○ Singleton/Одиночка - завжди повертають 1 і той же обєкт. приватний конструктор i __clone() завжди. Якщо я десь побачу статичну змінну $instanse, статичний метод getInstanse() - це вже напевно singlton. 
			- $instanse це то що буде завжди повертатись. У ньому буде хранитись екземпляр класа у якому він зназодиться. Тому мабуть це і є статична змінна, на відміну від $this вона принадлежить класу і у всіх обєктах буде одинакова. $instanse буде завжди приватний і статичний.
			- До речі прикольна особливість. Якщо створювати новий обєкт оператором new у класі, то можна написати так $obj = new self; (або парент)
			- Конструктор закрыт private function __construct() {}
			- Клонирование запрещено private function __clone() {}
			- Сериализация запрещена private function __sleep() {}
  			- Десериализация запрещена private function __wakeup() {}

 
	 Структурные шаблоны - для костилів
		○ Adapter/Адаптер (wraper) - створений для того щоб соєдинити 2 або декілька функціоналів. На тестовому прикладі були 2 плеєри для різних форматів і я написав клас адаптер, щоб їх зєднати.
		○ Decorator/Декоратор - Крутий шаблон. Типу бем. Суть у тому, що може бути ситуація, коли часто треба міняти легкий функціонал у класі. На тестовому варіанті я міняв колір. І щоб кожного разу не екстендити новий обєкт з існуючого і не дописувати новий функціонал (тоді по ходу старий вже не буде потрібен, але і видаляти його не можна), можна створити клас декоратор, який буде це робити декількома строчками коду
	 Поведенческие шаблоны - оприділяють поведінку
		○ Observer/Наблюдатель
		○ Strategy/Стратегия
	




