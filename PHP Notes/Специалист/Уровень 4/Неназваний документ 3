 1. У тестовій новосній ленті на 4-му курсі, у мене правильний підхід до роботи з базою. Тобто у самому файлі підключення до бази зроблені обертки до операціями з базою, а в файлі класів я не вліяю на ці налаштування, тільки працюю з базою. І якщо схочу поміняти базу, то в файлі бази треба буде трохи змінити обертку ( поміняти базу і методи поміняти на ті які треба для роботи з нею - вставити, апдейтнути, помилки... ), але у файлі класів нічого не зміниться і все залишиться робочим
	- У пхп за замовчуванням є вже всі налаштування і драйвери для цього. і в залежності з тим з чим я буду працювати то і загрузиться
 2) У старому підході навіть треба було по різному підключатись до бази в залежності від процедурного програмування або ооп
 3) Тепер майже всі підключення виглядають так - new PDO(...)
/* СТАЛО */
​У файлі до уроку є підключення до всіх баз, я виписав декілька
// MySQL
$pdo = new PDO('mysql:host=host;dbname=db', $user, $pass);
// PostgreSQL
$pdo = new PDO('pgsql:host=host;dbname=db', $user, $pass);
// SQLite
$pdo = new PDO('sqlite:db');

// Постоянное соединение
$pdo = new PDO('mysql:host=host;dbname=test', $user, $pass, [PDO::ATTR_PERSISTENT => true]);

 4) PDO::getAvailableDrivers() - покаже, які я використовую драйвери(бази) тепер
 5) запроси можна поділити на безотвені (insert, update, delete) і ответні (select)
	- з безответними взагалі стало просто - $result = $pdo->exec($sql); // Проверка ошибок if($result === false) echo "Ошибка в запросе"; І ця команда для всіх баз підходить. І на провірці помилок треба ставити 3 дорівнює, оскільки ця команда повертає к-сть строк над якими пройшла операція. А наприклад у мене код так працює, що якщо шо, то треба видалити з бази мусор, а там немає що видаляти. По факту помилки не було, просто не було що видаляти і повернеться 0, і в такому разі якщо не поставити 3 дорівнює, буде помилка 
 6) Екранування апострофів теж стало простим. Було ~ mysqli_escape_query_string, а тепер метот quote. $name = $pdo->quote($name);
	- $sql = "INSERT INTO users(name) VALUES($name)"; - підходить для всіх баз незважаючи на те що всі бази по різному еканують
	- quote повертає строку вже в апострофах('...'), тому $name написаний не в лапках. І не треба писати, а то буде помилка
	- Ще одне велике приймещество, це то що quote повертає строку і він типу і є вже підготовлений запрос. На рахунок проізводітельності не знаю, але хвости до запросу вже точно не можна буде добавляти. 
 7) Выборка данных (ответний запрос) - $sql = "SELECT id, name FROM users";
	- /* СТАЛО */ $stmt = $pdo->query($sql); - для всіх баз. Повертає або фолс або обєкт (він буде тру якщо шо). Його можна фетчити(fetch) $pdo->query($sql) or die('Ошибка в запросе!');
	// Обработка результата
	- $row = $stmt->fetch(); // PDO::FETCH_BOTH
	- $row = $stmt->fetch(PDO::FETCH_NUM);
	- $row = $stmt->fetch(PDO::FETCH_ASSOC);
 8) обработка помилок
 - $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
	- PDO::ATTR_ERRMODE - Це по ходу викличеться його кастомізіровавний обработчик помилок  
	- PDO::ERRMODE_EXCEPTION - Вид помилки. Що робити при помилці. Це я вказав що має викидувати в разі помилки Ecseption. Замість цього можна вказати константу щоб викидувало Wrning, або нічого не робити або ще щось. Короче загуглити
	- Помилка буде наслыдуватись выд класу PDOEcseption. Цей висновок я зробив тому що в кетч буже такий запис catch(PDOEcseption $e)
	- // Не выводить никаких сообщений
		$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_SILENT);
		​
	- echo $pdo -> errorCode(); - опис помилки
	- print_r( $pdo -> errorInfo() ); - опис помилки
	- echo $e->getMessage(); - $e - це з cetch // catch(PDOEcseption $e)
	- До речі досить подробно помилки описує, типу General error: no such column: title ( не має поля тайтл )
	- Тут робота з помилками набагато простіша. Вона і менш заморочена, оскільки багато функціоналу вже написано і плюс він сам шукає помилки, типу я кинув великий кусок коду ( роботи з БД ) в try, а він сам знайде помилку і сам опише її. 
 - Можна щоб ф-ція фетч повертала дані не в масив а в обєкт // Приведение результата к объекту​
	$stmt = $pdo->query($sql);
	$obj = $stmt->fetch(PDO::FETCH_OBJ);
 - Або можна зробити на всі випадки і користувати як зручно // Ленивое приведение
	$stmt = $pdo->query($sql);
	$obj = $stmt->fetch(PDO::FETCH_LAZY);
	​
	echo $obj[0] . "\n";
	echo $obj['name'] . "\n";
	echo $obj -> email . "\n";
 10) у пхп э клас пустишка - stdClass. Він завжди повертається якщо я вказав що треба повернути клас, але не вказав який.
 - Якщо у ф-ції fetch, я вказав що мені треба повернути дані в класі, але не вказав в якому, то він поверне клас stdClass. Справа в тому що зазвичай першим стовбцем у базі йде айді. А ф-ція $obj = $stmt->fetch( PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE ); працює так, що перше значення(айді) буде його імям, а інші вже свойствами. Але ж число не може бути імям класа, тому у нтого буде імя stdClass. Іполучається так що айдішник тіряєся - stdClass Object ( [name] => First [email] => first@email.ru )
	 - працювати воно буде приблизно так - $obj1 = $stmt->fetch( PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE ); тут буде перший рядок таблиці. $obj2 = $stmt->fetch( PDO::FETCH_CLASS|PDO::FETCH_CLASSTYPE ); - тут другий ... Короче як фетч
 - Якщо першим стовбцем і не айді буде всеодно є можливість що дані попадуть у клас stdClass. Наприклад першим буде Vasya А у мене немає описаного класа Vasya, тоді теж дані попадуть у stdClass. Щоб вони попали у клас який у мене є описаний спеціаліст і імя першого значення поставив не айді і описав клас з цим значенням. Також у цого класа були свойства, у які клались дані з фетча. Айдішник у класі теж був, але так як фетч його не повернув, у нього був NULL. Але скоріш за все мены не треба у описаному класі створювати свойства, вони і так там будуть
 - Спеціаліст казав що це удобно у тому випадку, якщо я насоздавав собі класів з іменем як у першого стовбця у таблиці а зразу при витягуванні з бази поприсвоював дані класу
 11) Можна і нормально вказати клас щоб присвоїти йому дані фетча 
	- $obj = $stmt->fetchObject("User"); дані фетча присвояться класу User. Якщо цей клас не описаний або у дужках буде пусто, $obj буде належати класу stdClass // stdClass Object ( [id] =>1 [name] => NULL [email] => first@email.ru )
	- Аналог - $stmt -> setFetchMode(PDO::FETCH_CLASS, "User"); - у спеціаліста не працювало
 - !ВАЖЛИВО Тобто дані будуть у обєкті $obj ($obj->id), але наскільки я зрозумів вони будуть наслідуватись з класа а не то що клас пустий а дані будуть тільки у обєкта.
 12) Якщо я хочу передавати дані не класу а обєкту $user( User клас для нього вже описаний ), запис буде такий - 
	- $user = new User();
	- $stmt->setFetchMode(PDO::FETCH_INTO, $user); 
	- $obj = $stmt->fetch(PDO::FETCH_ASSOC);​ // $obj = $user;
 - В попередніх записах, дані присвоювались конструктору до того як визвався конструктор. і тому якщо в конструкторі були свойства, які прийшли з фетча, вони перезаписувались. Якщо я хочу, щоб дані прийшли після того як визветься конструктор і перезаписали конструкторські, є спосіб - // 	Cвойства заполняются значениями после отработки конструктора - $stmt -> setFetchMode(PDO::FETCH_CLASS|PDO::FETCH_PROPS_LATE, "User");

 13) Полная выборка. По ходу зразу вся база.
	- Получаем массив массивов - $arr = $stmt->fetchAll(PDO::FETCH_ASSOC); // по-умолчанию PDO::FETCH_BOTH 
	- Получаем массив объектов класса User - $arr = $stmt->fetchAll(PDO::FETCH_CLASS, 'User'); class User {
													public $id, $name, $email;
												   }
	- $arr = $stmt->fetchAll(PDO::FETCH_COLUMN, 0); - Выбираем данные только из первого поля

 - // Используем функцию обратного вызова
	function foo($name, $email){
	return $name . ': '. $email . "\n");
	}
	$arr = $stmt->fetchAll(PDO::FETCH_FUNC, 'foo');

 14) Підготовлені запроси тут теж є, але є різні синтаксиси тож краже загуглити або подивити у файлі до уроку, тут нічого важкого 







