1) Анонімна ф-ція у пхп це коли ф-ція присвоюється знінній
	- По функціоналу дуже схоже на java-script, але ж різниця трохи
	- імя змінної і буде імям ф-ції
	- не забувати що в пхп, якщо у змінній є текст і цей текст такий самий як імя ф-ції, то цю змінну можна визвати як ф-цію // $var();
	- Анонімеа ф-ція - це обєкт. Кожен обєкт у пхп, створений віж якогось класу. Всі анонімні ф-ції створені від класу Closure
	- Після визову звичайної ф-ції, вона стає глобальна. Якщо я не хочу щоб вона була глобальна, наприклад мені її троеба визвати один раз, можна для цього використати анонімну ф-цію. Якшо у ф-ції не має імені, то вона анонімна і буде викликатись автоматично. Ці висновкм я зробив з цього прикладу // Самый удобный вариант:
					$new_arr = array_map(function($v){
						return $v * 10;
					}, $x);
	- Замикання - це можливість ф-ції захватувати змінні вищележачого контексту і замикати у собі ці значення. Щоб ф-ція мала цю здатнісь, є оператор use. $string = "Hello, world!";
		$closure = function() use ($string (параметри, які я хочу замкнути. Але тут буде не ссилка на змінну, я копія. Тож не забути про амперсант &)) { 
			echo $string
		};
		$closure();
------------- Нжче будуть описані Інтерфейси SPL (Standard PHP Library)	- це не всі. є отдільна бібліотека SPL з всякими плюшками ---------


- На скільки я зрозумів, у пхп усі ф-ції від чогось наслідуюься. Оскільки майже всюди у їхніх класах інкапсуляція, то щоб переписати їх функціонал, треба знайти їхній інтерфейс мабуть, клас з якого вони робляться і трохи переробити. Я розумію що тут трохи сумбурно написано, але це щось віддалено нагадує джава скріпт, коли у кожен обєкт можна залізти і переписати його. а то описувати для кожного класу звідки він береться, який(які) інтерфейси реалізує, буде дуже довго
	- Спеціаліст казав що тут трохи заморочено ( Наскільки я помітив, тут жодної ф-ції не було у тому коді що писав спеціаліст) так як тут все через ООП. Не знаю чи можна комбінувати  ООП і процедурне

2) Інтерфейс ітератор - цей інтерфейс наслідує інтерфейс Traversable, який по своїй структурі дуже простий (він пустий) і не цікавий. Пусті інтерфейси зазвичай використовують для провірки, типу якшо клас реалізує цей інтерфейс, то ....
	- Ітератор в програмуванні, це зазвичай обєкт, задача якого перебирати колекцію, незалежно від її реалізації. Не всі колекції в програмуванні влаштовані так як в скріпті і в пхп. У якихось мовах наприклад є масиви, по яких можна рухатись тільки вперед
	- наприклад цикл foreach - за замовчуванням перебирає обєкти і масиви. Він реалізує class Іterator і перебирає тільки ті обєкти я які реалізують цей клас. Масиви і обєкти по ходу реалізують. Інтерфейс Іterator має реалізувати декілька методів. Писати не буду, краще загуглити, або подивити в учбових файлах. // rewind() key() next() current() ...
	- Спеціаліст зробив надстройку на foreach, яка виводила уточнення до елементыв якы перебирались. Суть foreach така як у плагінів jquery. З колекції яка перебирається, він робить обєкт, ця колекція буде $this і цього обєкта є методи які використовуються при переборі 

1) IteratorAggregate теж наслідує Traversable;
	- Він відрізняється від простого ітератора тим що це abstract-ний клас. У нього є метод getIterator, який Возвращает внешний итератор, яким обробиться потрібний обєкт(мабуть не факт що обєкт, скоріш за все під це поняття підпадають і строки і числа і тд). Типу тип шаблона Factory. В залежності від введених даних, буде вибиратись якиїсь з ітераторів
	
2) ArrayAccess - дозволяє поводитись з обєтом як з масивом. У нього є 4 методи, які викликаються автоматом в залежності від того що я ввів. Наприлад є клас який наслідує інтерфейс ArrayAccess. ($0bj = new Registry(); ) Тепер у нього є ці 4 методи. І по ходу ці методи, не є реалізовані, їх треба описати. Наскільки я зрозумів, суть у тому, що головне щоб ці 4 методи реалізовували мінімальний функціонал, а вже дописувати до них можна що хочу.
	- offsetExists() - Спрацьовує коли я викликаю ф-цію isset, перевіряючи чи є у цього обєкта потрібне свойство/метод. // if( isset( $obj['login'] ) )
	- offsetGet() - Спрацьовує коли я хочу взяти якесь свойство/метод. // $obj['login'];
	- offsetSet() - Спрацьовує коли я добавляю свойство до обєкту. Так як тут поведінка як у масива, то вони додаються таким чином - // $obj['login'] = 'root'; 
	- offsetUnset() - Спрацьовує коли я викликаю ф-цію unset // unset( $obj['login']
	
 - Спеціаліст використав це для роботи з базою. Все описувати не буду, тут нічого важкого. Цей код знаходиться в /php4/demo/spl/04-arrayAccess.php

Забув написати що getIterator і IteratorAggregate знаходяться в розділі інтерфейси. Хоча не розумію чому, так як у getIterator не має методів вроді, а IteratorAggregate - це абстрактний клас і мабуть метод getIterator, що знаходиться в ньому - не обовязковий


3)  ( Інтерфейс ) Serializable - має 2 методи 
	- abstract serialize()
	- abstract unserialize()
	- Я взагалі не зрозумів для чого це потрібно. Тобто у цих функціях спеціаліст просто достукувався до приватних свойств і пропускав через звичайний серіалайз і ансеріалайз

4) ( клас ) Generator.
Приклад де замісь return використаю yeild
	- Generator реалізує інтерфейс Iterator. У ньому вже є ті ф-ції, що я писав у лабораторних, типу current, key...

	function numbers(){
		echo 'Start';
		for($i = 0; $i < 5; ++$i){
			yield $i; - yeild поверне обєкт ( екземпляр класа Generator ) "колекцію" з елементів який створив цикл for [1,2,3,4,5]; Це дуже добра практика з точки зору продуктивності. Спеціаліст взагалі казав, що це працює так, що змінна $value яка описана нижче в циклі foreach, кожен раз буде звартатись у цю ф-цію по змінну $i, а вона завжди буде інша (ф-ція next() мыняє елемент на слідуючий) І у такому випадку по ходу, ця ф-ція не хранить у собі цілий масив, а тільки той його елемент, який мені треба. хоча наскільки я зрозумів це більш схоже на статичну змінну. 
			echo '<br>'; - Це спрацює. Тепер не треба це писати у foreach який це буде виводити. Спеціаліст це пояснював тим, що це те саме як лабораторних роботах, коли я реалізовував ітератор. Там же на кожен степ є метод. і цей ехо пішов у потрібний метод. $i"."<br>"; 
		}
		echo 'Finish';
	}

foreach ( numbers() as $value ){
	echo "VALUE: $value"."<br>";
}

 - Короче. Коли пхп бачить yeild, він заморажує виконання скріпта, поки не зробиться yeild. Створює колекцію, і кидає перший елемент в цю колекцію і так далі, поки не закінчить і продовжує робити код

 - По ходу якщо yeild не поверне елемент колекції, то він поверне фолс. Це щоб можна було перевіряти в if

 - Як воно работае (Котеров). Коли я перебираю генератор, коли скріпт доходить до змінної, у яку кладеться текущий елемент ( foreache(generator() as змінна) ), перескакує в ф-цію генератора і робить те що там описано. Потім в момент когда итерпритатор достигает оператора  yeild, управление аозваращается внешнему циклу foreach. Функция-генератор помнит свое состояние и при следующем вызове выполнение начинается не с начала, а с точки последнего вызова yeild. Типу код продовжиться з того місця звідки закінчився 

До речі робота з файлами за допомогою генератора теж зручна

/* Чтение данных из файла с помощью генератора*/
 function getLines($file) {
 	$f = fopen($file, 'r');
 	if (!$f) throw new Exception();
 		while ($line = fgets($f)) {
 			yield $line;
 	}
 	fclose($f);
 }
 foreach(getLines('data.txt') as $line)
   echo "$line\n";

 - Також можна щоб генератор повертав дані у форматі ключ - значення // yeild $key => $value; foreach(getLines('data.txt') as $key => $value)

 4.2) Yeild може і приймати значення.
	- Метод Send() - присвоїть значення yield // $obj->send("значення для yield"); // echo yield;
	- yield - двоякий. Коли він виводить значення, то він схожий на ретурн, а коли приймає, то він виводить значення, яке йому передали через Send()
	 
// Комбинируем возврат и приём значений

	function numbers() {
		$i = 0;

		while (true) {
			$cmd = (yield $i);
			++$i;
			echo $cmd;
			if ($cmd == 'stop')
				return; // Выход из цикла
		}

	}
	$gen = numbers();
	foreach ($gen as $v) {
		if ($v == 3)
			$gen->send('stop');
		//echo $v;
	}


 ------------- Создание итератора из масива --------

 - ArrayIterator ітератор для перебору масива. Це стандартний ітератор, тільки у ньому вже є імплементовані інтерфейси. Не знаю що до інших, але у цей можна покласти декілька обєктів масивом
	- ArrayIterator implements Iterator,
					Traversable,
					ArrayAccess,
					SeekableIterator,
					Countable, - Якщо у обєкт реалізує Countable, можна викликати метод count()
					Serializable
	- iterator_to_array робить з ітератора масив. Типу я зробив ітератор, зробив всі ф-ції над ним, а потім цією ф-цією роблю з нього знов масив. Хоча і простим приведенням до типу масива теж канає, але я не впевнений що це правильно // (array) $myArrayObject;
	- ArrayIterator - працює тільки з одновимірними масивами

 - RecurciveArrayIterator - як ArrayIterator, але працює і з багатовимірними масивами
	- типу я кинув масив у цей ітератор, тим самим пояснив йому що це багатовимірний масив // $arr = [1, [2, [3]]]; Але на даний момент я не можу його поставити в foreach RecurciveArrayIterator($arr);
	- RecurciveArrayIteratorIterator - я зможу його поставити в foreach після цього // $arr = [1, [2, [3]], [4]]; $it = RecurciveArrayIterator($arr); $rii = new RecurciveArrayIteratorIterator($it); Це буде схоже на RecurciveArrayIterator ( в ньому будуть його методи ), але тут ще добавиться функціонал
		- Метод getDepth(); - поверне глубину елемента в масиві.
		- Метод beginChildren() - викликається, коли ітератор доходить до вложеного масива // Наприклад можна це використати для багаторівневого меню - коли зустрічаю дитину - echo "<ul>";
		- Метод endChildren() - викликається, коли ітератор виходить з вложеного масива - коли я вихожу з дитячого підмасиву, закриваю ul - echo "<ul>";
		- Метод hasChildren() - Возвращает TRUE, если текущий элемент является массивом (array) или объектом (object), FALSE в противном случае.
		- Є і інші методи, краще загуглити. До речі ті константи, які передоються у другому аргументі важливі, від них залежить, як буде працювати ф-ція. У мене не працювало нормально, поки не поміняв - $rit = new MyMenu(new RecursiveArrayIterator($menu), RecursiveIteratorIterator::ця константа);

	$menu = [
		  'Homepage',
		  'Register',
		  'About' => [
		              'The Team',
		              'Our Story'
		            ],
		  'Contact' => [
		                'Locations',
		                'Support'
		              ]
		];
	// Наследуем RecursiveIteratorIterator
	class MyMenu extends RecursiveIteratorIterator{
	  public function beginChildren(){
	    echo "<ul>\n";
	  }
	  public function endChildren(){
	    echo "</ul></li>\n";
	  }
	}
	// Рекурсивная итерация
	$rit = new MyMenu( new RecursiveArrayIterator($menu), RecursiveIteratorIterator::SELF_FIRST );
	echo "<ul>\n";

	foreach($rit as $key => $value) {

	  if ($rit->hasChildren()) {  // - по ходу $rit у цьому випадку, не статична змінна головного масива, а вона буде мінятись в злежності від текущого вдоженого масиву. Це ж рекурсивна ф-ція, мабуть коли ва знаходить вложений багатовимірний масив, вона викликається ще раз і $rit зміниться, буде тільки для цього масиву. Типу в кожного вложеного масиву буле свій $rit.
		  echo "<li>$key\n";
		  continue;
	  }
	  echo "<li>$value</li>\n";

	}
	echo "</ul>\n";

 ------------- Фільтрація елементів --------
 1) FilterIterator. abstract FilterIterator extends IteratorIterator
					   implements OuterIterator,
					   Traversable,
					   Iterator
	- Метод accept() — Проверяет, является ли текущий элемент итератора допустимым. Типу у неї всередині є return; І зразу в цій ф-ції писати умови
	function accept(){
	    if($this->getInnerIterator()->current() % 2 != 0){
	      return false;
	    }
	    return $this->getInnerIterator()->current();
	  } - це звичайно валідний код, але сенс цієї ф-ції в тому, шо це ф-ція-умова, тобто буде повертати тільки то що тру // return $this->getInnerIterator()->current() > 5;

 2) LimitIterator - Класс LimitIterator позволяет сделать перебор ограниченного количества элементов в Iterator. Цим спеціаліст робив класну пагінацію. у $_GET було значення від якого залежало який контент з масива буде попадати на текущу сторінку цією формулою $fromTo = ($getId * $countOfElements) - $countOfElements; $fromTo - тут буде елемент з якого почнеться показ, ну а к-сть елементів може бути заданий і статично
	foreach (new LimitIterator($getId, 10) as $item) {
	    echo $item;
	}
	- OutOfBoundsException - Создается исключение, если значение не является действительным ключом. У ітераторів є свої помилки. Понятно що це трохи переписаний стандартний обєкт помилок, але все ж ними корисно користуватись. Наприклад як ця. Вона спрацюэ якщо немає жодного елемента із тих що я прошу





 - Перед тим як давати запроси до бази, краще точно уточнити синтаксис, а то тут у спеціаліста лапки навіть у змінної - "SELECT count(*) FROM users WHERE name = '$name'" - хоча це може тільки у SqLite
 - І спеціаліст часто згадував інкапсуляцію у контексті того, що для того щоб зробити щось, програмісту не треба було лізти у реалізаціюцього коду. Типу логіку пише 1 програміст, а інші її можуть тільки викликати. Наприклад ф-ція pow(); І завжди коли спеціаліст говорив про інкапсуляцію, у класі були приватні змінні. Це мабуть спеціально для того щоб інші не могли нашкодити роботі ф-ції


 3) AppendIterator - декілька ітераторів зєднуються в 1 ітератор.
	// Объединение итераторов
	$arrayIterator = new AppendIterator();
	$arrayIterator->append($arrayIterator1);
	$arrayIterator->append($arrayIterator2);

 4) InfiniteIterator - безкінечний ітератор
	- У він може обробляти і AppendIterator (зєднані ітератори)
	- Він справді безкінечний. Якщо його не зупинити, то він буде крутитись вічно. Спеціаліст зупиняв його ф-цією(методом) у якому було описано коли він має зупинятись 
		$it = new InfiniteIterator($arrayIterator);
		foreach ($it as $object){
		$r = $object -> action();
			if(!$r) break;
		}

 5) SPLFileInfo - для роботи з файлами. $file = new SplFileObject('data.csv'); Сам по собі він не має великого функціоналу, тільки по мелочі. SPLFileInfo implements RecursiveIterator,
																			            Traversable,
																			            Iterator,
																			            SeekableIterator
	- $file->getFilename();
	- $file->getPathname();
	- $file->getSize();
	- $file->getTime();
	- $file->getType();
	- $file->isWriteble();
 6) SplFileObject - Наслідує SPLFileInfo. Тут є більше функціоналу як в SPLFileInfo// SplFileObject extends SplFileInfo
	- Хоча я не впевнений, що SPLFileInfo вже має в собі ті інтерфейси, що я описав. Оскільки і в спеці і в лабі я їх імплементую - SPLFileInfo implements Iterator, SeekableIterator
 7) DirectoryIterator - Ітератор, який пробігається по директорії і дивисться що там за файли. DirectoryIterator extends SplFileInfo
													      implements SeekableIterator,
															 Traversable,
															 Iterator
	foreach(new DirectoryIterator('.(Крапка - це текуща папка. Цей клас у конструкторі приймає директорію)') as $fileInfo( у цій змінній буде екземпляр класа SPLFileInfo ) {
		echo $fileInfo->getFileName() . "\n";
	}
 8) RecursiveDirectoryIterator - для рекурсивного обходження папок. Тут так само як з масивами. Тобто спочатку треба взяти його в DirectoryIterator, а потім в RecursiveDirectoryIterator 
	// $rdi = new RecursiveDirectoryIterator('.'); $rii = new RecursiveIteratorIterator($rid);
 9) RecursiveTreeIterator щоб працювати з деревом елементів. Спеціаліст вивів цілу структуру файлів курсу і красиво з символами, перед файлами які можна міняти вмонтованими константами
	|-./15-Stack.php
	|-./12-splFileObject.php
	|-./13-2-RecursiveDirectoryIterator.php
	|-./05-2-serialize+.php
	|-./. 
	- Щоб все працювало, треба спочатку взяти директорію в RecursiveDirectoryIterator, а потім в RecursiveDirectoryIterator. Хоча я не розумію чому перед цим не треба це брати в DirectoryIterator
	$rdi = new RecursiveDirectoryIterator('.');
	$tree = new RecursiveTreeIterator($rdi);
	foreach ($tree as $item) {
		echo $item . "\n";
	}
	- Внимание - К настоящему времени эта функция еще не была документирована; для ознакомления доступен только список аргументов.
 10) ArrayObject - Масив как обєкт. Данный класс позволяет объектам работать как массивы. ArrayObject implements IteratorAggregate,
														 ArrayAccess,
														 Traversable,
														 Iterator,
														 Countable
	- $usersObj = new ArrayObject($usersArr); $usersObj->append('Ира');
	- Можливо це і є десь вверху, але я ще раз розпишу.  Є масив - $usersArr = ['Вася', 'Петя', 'Иван', 'Маша', 'Джон', 'Майк', 'Даша', 'Наташа', 'Света']; 
Я роблю з нього обєкт ітератора - $usersObj = new ArrayObject($usersArr); Тепер у нього будуть ті методи(key, current, next...). Саме у ArrayObject є і свої власні методи, щоь працювати з ним як з масивом:
	- $usersObj->offsetExists(4) // Проверяем, существует ли пятый элемент массива
	- $usersObj->offsetSet(4, "Игорь"); // Меняем значение пятого элемента массива
	- $usersObj->count(); // Получаем количество элементов массива
	- $usersObj->natcasesort(); // Сортируем по алфавиту
	- Є ще інші, краще загуглити

// Выводим данные массива
	for( $it = $usersObj->getIterator(); $it->valid(); $it->next() ){ // У $it буде попадати текущий елемент колекцїї
		echo $it->key() . ': ' . $it->current() . "\n"; // Цей функціонал він унаслідував з ArrayObject скоріш за все, але все ж. Цей масив($usersArr) - індексований, але він може вивести і $it->current() і $it->key()(тут буде індекс)
	}
	- getIterator - This function will return an iterator from an ArrayObject. Короче я не знаю, чому воно так працює. Це робочий варіант, але чому у циклі $usersObj викликає метод getIterator(), я не до кінця зрозумів.

 11) SplObjectStorage - предоставляет соответствие объекты-данные или набор объектов, игнорируя данные. Эта двойная цель может быть полезна во многих случаях, включая необходимость уникальной идентификации объектов. SplObjectStorage implements ArrayAccess, - нагадаю, що реалызуючи цей клас, з обэктом можна буде працювати як з масивом - $storage[$object1] = "John";
						    Serializable,
						    Traversable,
						    Iterator,
						    Countable
	- Особливість цього класу в тому, що в якості ключа, тут можуть виступати обєкти. - $storage[$object1] = "John";
	- Метод attach() — Добавляет объект в контейнер
	- Метод detach();
 ---------- Структуры данных: Стек (LIFO) -------
 12) Це основна структура даних, на якій все тримається. Останній прийшов, першим вийшов. Як магазин у автоматі - першим вистріллить той, що останній у магазині. Наприклад як у масиві $array = []; $array[] = 'first'; $array[] = 'second'; $array = 'first';  $array->pop(); - видалити елемент, який останнім прийшов.

 12) SplDoublyLinkedList - Класс SplDoublyLinkedList обеспечивает основные функциональные возможности двусвязного списка.




 - В пхп можна по ходу переписати функціонал фції. Спеціаліст переписав ф-цію var_export. Типу як в скріпті. Після цього вона вже роила зовсім по інакшому class var_export extends SPLFileInfo
            																			implements Iterator, SeekableIterator {...}
 - class SplDoublyLinkedList implements Iterator, // Класс SplDoublyLinkedList обеспечивает основные функциональные возможности двусвязного списка.
				  	Countable,
				  	ArrayAccess
 - class SplStack(предоставляет основные функциональные возможности стека, реализованные с использованием двусвязного списка.) extends SplDoublyLinkedList	​
	- $stack = new SplStack();
	- $stack -> push("John");
	- $stack -> push("Mike");
	- $stack -> pop(); // Mike
	- $stack -> pop(); // John

	- Метод bottom() — Получает узел, находящийся в начале двусвязного списка
	- Метод top() — Получает узел, находящийся в конце двусвязного списка
	- Метод rewind() — Возвращает итератор в начало
	- Метод current() — Возвращает текущий элемент массива
	- Є ще інші, краще загуглити. Ті що він вже унаслідував від інших ітераторів, я декілька з них описував вище.
	

 ---------- Структуры данных: Очередь -------
 - Як стек, тільки тут - перший прийшов - перший вийшов 
 13) - SplDoublyLinkedList implements   Iterator,
					Countable,
					ArrayAccess
	- SplQueue extends SplDoublyLinkedList - Класс SplQueue предоставляет основные функциональные возможности очереди, реализованные с использованием двусвязного списка.
	- Метод enqueue($value); // Добавляет value в конец очереди. enqueue() - псевдоним SplDoublyLinkedList::push(). Эта функция не возвращает значения после выполнения.
	- Метод dequeue($value); // Удаляет value из начала очереди. Це в спеці так пише, а на практиці якщо у дужках нічого не писати, то видалиться останній елемент. В принципі це і є цей принцип  - перший прийшов - перший вийшов
	- Метод bottom($value); - поверне перший елемент
	- Метод top($value); - поверне останній елемент
	- І ДО РЕЧІ НЕ ЗАБУВАТИ що завжди можна заекстендитись від цих стандартних класів і переписати їх на свої і дописати свої.

 ---------- Структуры данных: Очередь с приоритетом -------
 14) SplPriorityQueue implements Iterator, Countable; Схоже на "Очередь", тільки тут можна задавати приорітети, який буде перший, який останній, який другий ...
	- Метод insert($value, priority); // $queue = new SplPriorityQueue(); $queue -> insert($work1, 2); У кого быльший приорітет, той буде перший випльовуватись з циклу, і т. Добавляет елемент в чергу. Аналог enqueueж. У лабі спеціаліст робив це. Цей функціонал достигався сортуванням елементів у масиві. Тобто це не метод extract() якось специфічно вибирав, елементи в колекції вже були відсортовані як треба.
	- Метод extract(); - вибирає елемент з черги. Аналог dequeue
	- Короче я і це не поняв нахер воно. Спеціаліст робив з нього аналог черги ( в лікарні наприклад ). Перемішував масив (типу случайний набор людей), і циклом додавав елементи в SplPriorityQueue, ставлячи по порядку приорітети їм. І якщо привести аналогію з життям, то тепер я буду знати, в кого який приорітет і хто обслужиться перший

 ---------- Структуры данных: Куча -------

	abstract SplHeap implements Iterator,
				    Countable
	SplMinHeap extends 	SplHeap
		   implements   Iterator,
				Countable
	SplMaxHeap extends SplHeap
		   implements   Iterator,
				Countable
 15) SplHeap - це основний обєкт. В ноьго є метод compare, яким і робиться вся сортіровка. В лабі він є кастомізірований
	- в пхп є вмонтовані 2 класи, які екстендяться від нього, Але це вже плюшки, які основані на методі compare, який і робить сортіровку. Звичайно його можна переписати як хочу, щоб можна було використати для строк, для обєктів ...
	- SplMinHeap(); SplMaxHeap(); - В них можна накидати елементи (вроді тільки числа) і вони там будуть сортуватись від мінімального до максимального і навпаки
	
	- методи insert, remove - додати, забрати елементи. Короче краще загуглити, які є ще

$minHeap = new SplMinHeap();

	$minHeap -> insert(2);
	$minHeap -> insert(3);
	$minHeap -> insert(1);

	foreach ($minHeap as $value)
		echo $value . " " . '<br>'; // 1 2 3

	$maxHeap = new SplMaxHeap();
	$maxHeap -> insert(2);
	$maxHeap -> insert(3);
	$maxHeap -> insert(1);
	foreach ($maxHeap as $value)
	echo $value . " " . '<br>'; // 3 2 1
	
 ---------- Массив фиксированной длины -------

	SplFixedArray implements Iterator,
				 ArrayAccess,
				 Countabl
 16) SplFixedArray - Створює фіксований масив, у якого буде стільки елементів, скільки я вказав у конструкторі. У прикладі спеціаліст показував різницю між створенням звичайного масиву і масивом, створеним за допомогою SplFixedArray. SplFixedArray забирав менше ресурсів(памяті).
	- Він створить фіксований масив(індексований). якщо я створив масив з 5-ма елементами $splArray = new SplFixedArray(5); і захочу туди передати 6-й елемент, буде помилка - $splArray[5] = "bar"; // Ошибка! Якщо я хочу збільшити к-сть елементів у цьому масиві без помилки, є ф-ція $array->setSize(10);
	- Хоча це і схоже трохи на масив, не забувати що це обєкт і функціонал у нього не буде як у масива, буде тільки його власний функціонал або той що він унаслідував. 

 ---------- Автозагрузка классов -------

 17) Заміна стандартного __autoload. Якщо я описав його, то стандартний автолоад не буде працювати. Стандартний автолоад в наступній версії буде діпрікейтед. Це той же, самий автолоад, тільки тут можна ставити порядок загрузки класів в очередь ф-цією spl_autoload_register('loadInterface', true, 1); Типу можна описати декілька ф-цій, які будуть викликатись у разі того що метода не має і вказувати яка в яку чергу має робитись
	- spl_autoload_unregister - Видаляє ф-цію з списку тих які мають робитись якщо клас не знайшовся
	- В случаї коли метод автозагрузки описаний в класі, то і це можна вирішити вказавши клас - spl_autoload_register(['Class', 'autoload']); Але метод автозагрузки вроді має бути статичним вроді
	- spl_autoload_register(['Main', 'autoload']); // Список зарегистрированных функций
 




 17) memory_get_usage — Возвращает количество памяти, выделенное для PHP. Возвращает количество памяти в байтах, которое было выделено PHP-скрипту на данный момент.
 18) Я не поняв чому, але є різниця в підключенні до БД в процедурному програмуванні і в ООП.

 - Це що я писав всі залежності класа, щоб працювати з ним, мабуть не обовязково це все прописувати. В ідеалі мало б бути так як завжди, типу $minHeap = new SplMinHeap(); Хоча є виключення. В будь якому разі це все що я описав можна подивити в лабораторних. Там все це є і розкладено по файлах робочі варіанти.

 Я не розумію навіщо у файлі 12-splFileObject.php ( Уровень 4. Урок 2 ) він у конструкторі визвав родительський конструктор і передав йому той самий файл як і конструктору

 Якщо клас/метод является статическим, нам не обязательно создавать экземпляр класса example для его вызова. Типу не треба створювати обєкт, можна зразу писати class::method();



 boring bored; - Одне вліяє на інше. до живих істот треба використовувати bored, а boring використовується до того, що що викликає у живої істоти ці емоції. I am bored becouce this lilm is borring



 - for - налогова, яка просить документи
 - php - Начальник, який не буде цим займатись і поручить це помощнику - Ітератору
