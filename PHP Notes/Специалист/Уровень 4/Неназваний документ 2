1) Анонімна ф-ція у пхп це коли ф-ція присвоюється знінній
	- По функціоналу дуже схоже на java-script, але ж різниця трохи
	- імя змінної і буде імям ф-ції
	- не забувати що в пхп, якщо у змінній є текст і цей текст такий самий як імя ф-ції, то цю змінну можна визвати як ф-цію // $var();
	- Анонімеа ф-ція - це обєкт. Кожен обєкт у пхп, створений віж якогось класу. Всі анонімні ф-ції створені від класу Closure
	- Після визову звичайної ф-ції, вона стає глобальна. Якщо я не хочу щоб вона була глобальна, наприклад мені її троеба визвати один раз, можна для цього використати анонімну ф-цію. Якшо у ф-ції не має імені, то вона анонімна і буде викликатись автоматично. Ці висновкм я зробив з цього прикладу // Самый удобный вариант:
					$new_arr = array_map(function($v){
						return $v * 10;
					}, $x);
	- Замикання - це можливість ф-ції захватувати змінні вищележачого контексту і замикати у собі ці значення. Щоб ф-ція мала цю здатнісь, є оператор use. $string = "Hello, world!";
		$closure = function() use ($string (параметри, які я хочу замкнути. Але тут буде не ссилка на змінну, я копія. Тож не забути про амперсант &)) { 
			echo $string
		};
		$closure();
------------- Нжче будуть описані Інтерфейси SPL (Standard PHP Library)	- це не всі. є отдільна бібліотека SPL з всякими плюшками ---------

- На скільки я зрозумів, у пхп усі ф-ції від чогось наслідуюься. Оскільки майже всюди у їхніх класах інкапсуляція, то щоб переписати їх функціонал, треба знайти їхній інтерфейс мабуть, клас з якого вони робляться і трохи переробити. Я розумію що тут трохи сумбурно написано, але це щось віддалено нагадує джава скріпт, коли у кожен обєкт можна залізти і переписати його

2) Інтерфейс ітератор - цей інтерфейс наслідує інтерфейс Traversable, який по своїй структурі дуже простий (він пустий) і не цікавий. Пусті інтерфейси зазвичай використовують для провірки, типу якшо клас реалізує цей інтерфейс, то ....
	- Ітератор в програмуванні, це зазвичай обєкт, задача якого перебирати колекцію, незалежно від її реалізації. Не всі колекції в програмуванні влаштовані так як в скріпті і в пхп. У якихось мовах наприклад є масиви, по яких можна рухатись тільки вперед
	- наприклад цикл foreach - за замовчуванням перебирає обєкти і масиви. Він реалізує class Іterator і перебирає тільки ті обєкти я які реалізують цей клас. Масиви і обєкти по ходу реалізують. Інтерфейс Іterator має реалізувати декілька методів. Писати не буду, краще загуглити, або подивити в учбових файлах. // rewind() key() next() current() ...
	- Спеціаліст зробив надстройку на foreach, яка виводила уточнення до елементыв якы перебирались. Суть foreach така як у плагінів jquery. З колекції яка перебирається, він робить обєкт, ця колекція буде $this і цього обєкта є методи які використовуються при переборі 

1) IteratorAggregate теж наслідує Traversable;
	- Він відрізняється від простого ітератора тим що це abstract-ний клас. У нього є метод getIterator, який Возвращает внешний итератор, яким обробиться потрібний обєкт(мабуть не факт що обєкт, скоріш за все під це поняття підпадають і строки і числа і тд). Типу тип шаблона Factory. В залежності від введених даних, буде вибиратись якиїсь з ітераторів
	
2) ArrayAccess - дозволяє поводитись з обєтом як з масивом. У нього є 4 методи, які викликаються автоматом в залежності від того що я ввів. Наприлад є клас який наслідує інтерфейс ArrayAccess. ($0bj = new Registry(); ) Тепер у нього є ці 4 методи. І по ходу ці методи, не є реалізовані, їх треба описати. Наскільки я зрозумів, суть у тому, що головне щоб ці 4 методи реалізовували мінімальний функціонал, а вже дописувати до них можна що хочу.
	- offsetExists() - Спрацьовує коли я викликаю ф-цію isset, перевіряючи чи є у цього обєкта потрібне свойство/метод. // if( isset( $obj['login'] ) )
	- offsetGet() - Спрацьовує коли я хочу взяти якесь свойство/метод. // $obj['login'];
	- offsetSet() - Спрацьовує коли я добавляю свойство до обєкту. Так як тут поведінка як у масива, то вони додаються таким чином - // $obj['login'] = 'root'; 
	- offsetUnset() - Спрацьовує коли я викликаю ф-цію unset // unset( $obj['login']
	
 - Спеціаліст використав це для роботи з базою. Все описувати не буду, тут нічого важкого. Цей код знаходиться в /php4/demo/spl/04-arrayAccess.php

Забув написати що getIterator і IteratorAggregate знаходяться в розділі інтерфейси. Хоча не розумію чому, так як у getIterator не має методів вроді, а IteratorAggregate - це абстрактний клас і мабуть метод getIterator, що знаходиться в ньому - не обовязковий


3)  ( Інтерфейс ) Serializable - має 2 методи 
	- abstract serialize()
	- abstract unserialize()
	- Я взагалі не зрозумів для чого це потрібно. Тобто у цих функціях спеціаліст просто достукувався до приватних свойств і пропускав через звичайний серіалайз і ансеріалайз

4) ( клас ) Generator.
Приклад де замісь return використаю yeild
	- Generator реалізує інтерфейс Iterator. У ньому вже є ті ф-ції, що я писав у лабораторних, типу current, key...

	function numbers(){
		echo 'Start';
		for($i = 0; $i < 5; ++$i){
			yield $i; - yeild поверне обєкт ( екземпляр класа Generator ) "колекцію" з елементів який створив цикл for [1,2,3,4,5]; Це дуже добра практика з точки зору продуктивності. Спеціаліст взагалі казав, що це працює так, що змінна $value яка описана нижче в циклі foreach, кожен раз буде звартатись у цю ф-цію по змінну $i, а вона завжди буде інша (ф-ція next() мыняє елемент на слідуючий) І у такому випадку по ходу, ця ф-ція не хранить у собі цілий масив, а тільки той його елемент, який мені треба. хоча наскільки я зрозумів це більш схоже на статичну змінну. 
			echo '<br>'; - Це спрацює. Тепер не треба це писати у foreach який це буде виводити. Спеціаліст це пояснював тим, що це те саме як лабораторних роботах, коли я реалізовував ітератор. Там же на кожен степ є метод. і цей ехо пішов у потрібний метод. $i"."<br>"; 
		}
		echo 'Finish';
	}

foreach ( numbers() as $value ){
	echo "VALUE: $value"."<br>";
}

 - Короче. Коли пхп бачить yeild, він заморажує виконання скріпта, поки не зробиться yeild. Створює колекцію, і кидає перший елемент в цю колекцію і так далі, поки не закінчить і продовжує робити код

 - По ходу якщо yeild не поверне елемент колекції, то він поверне фолс. Це щоб можна було перевіряти в if

 - Як воно работае (Котеров). Коли я перебираю генератор, коли скріпт доходить до змінної, у яку кладеться текущий елемент ( foreache(generator() as змінна) ), перескакує в ф-цію генератора і робить те що там описано. Потім в момент когда итерпритатор достигает оператора  yeild, управление аозваращается внешнему циклу foreach. Функция-генератор помнит свое состояние и при следующем вызове выполнение начинается не с начала, а с точки последнего вызова yeild. Типу код продовжиться з того місця звідки закінчився 

До речі робота з файлами за допомогою генератора теж зручна

/* Чтение данных из файла с помощью генератора*/
 function getLines($file) {
 	$f = fopen($file, 'r');
 	if (!$f) throw new Exception();
 		while ($line = fgets($f)) {
 			yield $line;
 	}
 	fclose($f);
 }
 foreach(getLines('data.txt') as $line)
   echo "$line\n";

 - Також можна щоб генератор повертав дані у форматі ключ - значення // yeild $key => $value; foreach(getLines('data.txt') as $key => $value)

 4.2) Yeild може і приймати значення. 
	- Метод Send() - 
	 





 - Перед тим як давати запроси до бази, краще точно уточнити синтаксис, а то тут у спеціаліста лапки навіть у змінної - "SELECT count(*) FROM users WHERE name = '$name'" - хоча це може тільки у SqLite
 - І спеціаліст часто згадував інкапсуляцію у контексті того, що для того щоб зробити щось, програмісту не треба було лізти у реалізаціюцього коду. Типу логіку пише 1 програміст, а інші її можуть тільки викликати. Наприклад ф-ція pow(); І завжди коли спеціаліст говорив про інкапсуляцію, у класі були приватні змінні. Це мабуть спеціально для того щоб інші не могли нашкодити роботі ф-ції







 boring bored; - Одне вліяє на інше. до живих істот треба використовувати bored, а boring використовується до того, що що викликає у живої істоти ці емоції. I am bored becouce this lilm is borring


