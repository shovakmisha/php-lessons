1. На сайті PHP у розділі директиви у колонці 'место изменения' можна вказувати, які настройки PHP і де, можна їх міняти. У php.ini, .htacess або де хочу. Тобто мабуть може бути ситуація, коли акест значенн не можна міняти у php.ini або .htacess 
1. Ф-ція subst(); - вибірка підстроки // subst("строка", з цього елемента, скільки елементів вибрати(необов’язково));
	- Можна задавати мінусові значення.
2. Ф-ція str_replace(); - заміна підстроки. % - використовується, щоб уточнити, інакше заміняться всі схожі підстроки. // $bodytag = str_replace("%text%", "text_2", "Цей %text% заміниться на text_2", $count); В змінній $count буде хранитися, скільки раз була заміна %text% у записі "Цей text заміниться на text_2".
3. Ф-ція expolde(); - повертає масив строк, які получились після того як я розбив масив. $p = "1 2 3 4"; $z = explode(" ", $p); - $z[1,2,3,4];
	- Можна зразу використати ф-цію list($one, $two, $three, $four) = explode(" ", $p);
4. Ф-ції для роботи з масивами
	- array_key_exist(); - Проверяет, присутствует ли в масиве указанный ключ или индекс
	- in_array(); - Проверяет, присутствует ли в масиве значение
	- array_keys(); - Возвращает все или некоторое подмножество ключей масива, масивом
	- array_values(); - Выбирает все значения массива
	- array_merge(); - Сливает один или большее количество массивов
	- array_diff(); - Вычисляет расхождение массивов
	- array_intersect(); - Вычисляет схождение массивов
	- array_push() - добавляє елементи в кінець масива
	- array_pop() - видаляє елемент з кінця масива. Якщо застосувати до немасива або пустого масива, буде NULL. Скидує указатель масива. Якщо присвоїти процес змінній, то їй присвоїться вирізана змінна.
	- array_unshift(); - добавляє елементи в початок масива
	- array_shift(); - Видаляє перший елемент масива
	- Ф-ції сортіровки не буду записувати, бо їх дуже много.
4.Ф-ція getdate(); - Возвращает ассоциативній массив, содержащий информацию о дате, представленной меткой времени timestamp, или текущем системном времени, если timestamp не был передан. У ньому є все про дату. Щоб витягти, наприклад дату $d = getdate(); print_r($today); - [second] => 40. 
	- Взагалі цей масив асоціативний, але оснтанній елемент у ньому не асоціативний. У останньому елементі інформація, про те, скільки пройшло секунд з 01 01 1970р. до тепер.
4. Коли я працюю з датами у PHP не забувати про те, що є поняття "правильна дата". Тож якщо є якась помилка, можливо із за цього.
5. Ф-ція echo нічого не повертає, а print повертає 1. // echo 2 + print 1; буде 13
6. Є псевдоконстанти. Імя у них одне, а значення міняється. Наприклад __line__ поверне лінію, у якій вона знаходиться. Псевдоконстанта знаходиться між 4 нижніми підкреслюваннями.
 - ENV - Тут зберыгаються усы дані про дату на машині
7. Якщо я звертаюсь до змінної, якої нема, повернеться null. НО між несуществующов зміннов і змінною, якій присвоєно нуль є різниці. Аж я видалив змінну, то її ніде не буде, а змінна, якій присвоєно NULL, буде в глобальному масиві, але пуста.
8. require - схожий на include, тільки якщо я вкажу неіснуючий файл, буде фатальна помилка, а не WARNING.
8. Зазвичай у підключаємого файла закінчення перед 'php' добавляють 'inc', щоб знати, що це підключаємий файл // fail.inc.php хоча можна навіть без 'php', але небажано 
9. Якщо я підключаю 1 файл у різні участки документа, це ніби я просто вставляв код документа у участок документа. Тож не забувати про редекларацію(дві ф-ції з одинаковим іменем).
	- Можна використати замість include, include_once (котеров рекомендує). include_once прослідить, щоб 1 файл підключався тільки 1 раз, 2-й раз він його проігнорує, зробить вигляд ніби я не підключав файл. // include_once файл; // include_once файл;
	- require_once - схожий на include_once, тільки якщо я вкажу неіснуючий файл, буде фатальна помилка, а не WARNING.
	- require_once(include_once) І require(include) - хранять увесь код у одній області памяті. Тож коли я вже вставив код методом include, include_once нема сенсу вставляти, це вже і так буде знов просто include
10. Старатися робити ф-ції, які повертають якийсь результат, хоча б false/true. І можна далі перевіряти if(functionName == true){Можна виводити}
	
