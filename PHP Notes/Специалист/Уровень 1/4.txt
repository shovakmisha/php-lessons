1. Цикл foreach - тіпа 'for in' у java-script. // foreach(array as $value){} . В основному це для простих масивів. У простому масиві, у змінну занесеться не ключ елемента, а його значення. // $array = ["Вася", "Michael", "Vitaly"]; У змінну будуть заноситись "Вася", "Michael", "Vitaly";
	- Для асоціативних масивів його можна розширити // foreach(array as $kay => $value){} - у першу змінну($kay) він кине ключ, а у другу його значення. Якщо вказати тільки одну змінну, виведе тільки значення ключа
	- Важливо. Цей цикл буде працювати з копіями змінних, а не з самими змінними, тож якщо я поміняю значення елементів масива у циклі, - значення не зміняться. Щоб змінити, треба покласти перед новою змінною амперсант // foreach(array as &$value){}
	- Якщо ввести імя несуществуємого масива, боде помилка
	- Взагалі оператор & є для того щоб працювати почати працювати з самим елементом як з обєктом. Тобто в змінній буде ссилка на участок памяті з цим елементом
	- Цей оператор можна ставити тільки у правій стороні виразу (тобто після =)
2. ВАЖЛИВО! PHP не має різних областей видимості для циклів (для інших не знаю)
3. Ім’я ф-ції регістронезависиме.
4. Ф-ція має йти зразу блоком і не можна її розривати // <? function(){ ?> <? } ?>
5. Не можна називати 2 різні ф-ції одним іменем. Може бути помилка не лише тоді, коли я назвав ф-ції одинаково, а й тоді, коли я назвав ф-цію іменем зашитої у PHP ф-ції. На цей випадок є ф-ція function_exist('імя ф-ції'); - вона перевірить чи існує вже така ф-ція.
6. Якщо визов ф-ції стоїть вище самої ф-ції, PHP діє так само, як java-script
7. Якщо ф-ції має передатися аргумент, а я не передав, буде WARNING
8. PHP воспринімає ф-цію як змінна/свойство, а за нею дужки. Тож якщо я буду обращатися до елемента масива через круглі дужки, може вискочити помилка Function name must be string // $name('...'){}
	- Така помилка може вискочити, якщо я назвав змінну 'test' так само як ф-цію 'test' і присвоїв їй якийсь елемент(10 наприклад). І якщо я забув, що я це зробив, буде - замість test(); - 10();
9. PHP не дає можливість переоприділити або видалити ф-цію.
10. Якщо ф-ція знаходиться в конструкції if-else, то PHP при початковову просмотрі коду не помітить її і не занесе собі у блокнот.
11. Це є і в java-script. Коли PHP  бачить ф-цію, він просто перевіряє її на синтаксичні помилки і запам’ятовує, що така ф-ція є. А при визові ф-ції, він вже звертається до тіла ф-ції. 	Тож коли ф-ція (а) знаходиться в ф-ції (в), ф-цію 'а' не можна буде викликати, поки я не викликав ф-цію 'в', PHP не буде знати, що така ф-ція існує, бо коли він перший раз продивляв код, він заніс в блокнот ф-цію 'в' і пішов далі, не залізаючи в тіло ф-ції.
	- І ф-цію "в", можна викликати тільки 1 раз, інакше беде помилка, PHP подумає, що я знову хочу создати ф-цію з іменем "a". Як я зрозумів, PHP виносить ф-цію в глобальну видимость, зразу після ф-ції 'в';
. Щоб не було помилки, якщо у ф-цію не передасться аргумент, можна перестрахуватися і дати змінній значення по умолчанию // function drawTable($rows=10). І тепер якщо значення для $rows не прийде, воно залишиться 10.
12. Для змінних існує дві області видимості - глобальна і локальна. І глобальна не побачить локальну, а локальна не побачить глобальну.  Щоб локальну змінну стало видно у глобальній області, можна 
	- Поставити перед нею 'global' // echo $name;;. І тепер локальна змінна видалиться і залишиться тільки глобальна. Но коли я написав зразу 2 операції, вийшла помилка - global $name = 3;
 - Всі глобальні масиви храняться у глобальному масиві GLOBALS. Тобто $name = 3, теж саме, що і GLOBALS['$name']= 3;
	- Тож якщо я хочу создати у ф-ції глобальну змінну і не видаляти локальну, можна - GLOBALS['$name']= 3;
14. Ф-ція живе, поки з того момента як я її виклилав, до того, як вона завершила свою ф-цію. В інших випадках її ніби й не існувало і значення змінних внутрі ф-ції не сохраняються.
	- Щоб значення змінної зберігалось, треба поставити перед нею static //  static $n = 3++; І тепер кожного разу, коли я буду звертатись до ф-ції, $n буде більша.
15. Після return код не читається // return 3; echo 5; - мертвий код
	- Якщо у ф-ції я не написав return, то неявно повернеться NULL.
16. Якщо я хочу повернути декілька значень ф-ції, можна поставити елементи в масив.
	- Ф-ція list(); - Можна зразу присвоїти елементи масива у змінні. Але цей спосіб діє тільки для поверненого масива з ф-ції, для простого масива буде помилка // list($s1, $s2, $s3) = numbers(); (ф-ція numbers() повертає масив.)
	- Можна зразу працювати з поверненим масивом. Нарпиклад ф-ція numbers повертає масив - $name = nembers()[1]; // Діє з версії 5.4 
	- Можна навіть так записати, щоб не вставляти перше значення - list(, $s2, $s3) = numbers();
17. Ф-ція func_num_args(); - к-сть параметрів, які передані в ф-цію.
	- Ф-ція func_get_args(); - масив параметрів(елементів) ф-ції
	- Ф-ція func_get_arg(ключ); - витягне елемент масива з елементів ф-ції, указаний мною в дужках.
18. Мош нараз зробити ф-цію, яка обробляє тільки масиви, а якщо буде не масив, буде помилка // function foo(array $var){}
19) Коли я додаю елемент в асоціативний масив ($arr["key"] = "value"),він завжди поставиться в кінець (якщо такого ключа немає в масиві звичайно)
