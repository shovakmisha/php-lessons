1) Якшо свойство метода не public, його вын починаэться з підчеркування - $_name; общеприйнята рекомендація
	- XML
2) Якщо будуть не англійські символи у документі, треба вказати кодіровку
3) XML - регістрозависимий
3) У XML має знаходитись 1 корневий каталок, вище і нище нього не має бути нічого ( типу <html> у html ) 
4) <?xml version="1.0"> - це мінімум, який треба вказати документу xml
	 encoding="utf-8" - краще вказати кодіровку. За замовчкванням xml документи обробляються кодіровкою utf-8, але щоб мій документ оброблявся цією кодіровкою, обработчику( ф-ція xml_parser_create наприклад ) треба знати з якої кодіровки треба переробляти. Тому я її вказав, щоб він знав.
5) PHP може працювати з DOM. Ресурсозатратна штука.
	- Сама специфыкація дому це і є набор інтерфейсів абстрактних.
	- В принципі тут теж саме що і в скріпті, але в пхп я працюю не з хтмл а з хмл. Типу тут не буде боді або getElementById ...
	- Далі будуть ф-ції, які працюють з документом через SAX
6) xml_parser_create('utf-8') - Це я создав парсер. Ним я буду обробляти документи ф-ціями, які я опишу нижче або якимось іншими
	- зачитує елемент у одній з 3-х кодіровок. Кирилиці не має
	- розпарсить xml документ. Кодіровку мож і не указувати, вона і так за замовчуванням 'utf-8'.
7) До речі робота з xml документами це вже не ооп, а процедурний стиль
8) Робота з xml проходить через собтія. Типу як в скріпті. коли зустрічається якиїсь елемент, виконати якусь ф-цію. Вказати що робити з тегами, які є у елемента і тд..
9) Є 3 собтія, на які можна повісити ф-ції. Ф-ції можна називати як хочу, але у них мають бути обовязкові аргументи
	- Ф-ція для відкриваючого тега someFunction(
							'1-й аргумент не обовязковий. У ньому буде змінна, якій присвоїться ф-ція xml_parser_create' ($var = xml_parser_create('utf-8') ). Взагалі воно трохи дивно, оскільки це процедурне програмування і парсер я створюю у гдобальній області бачення, і треба бавати його аргументом у ф-ції, а це вже локальна область. На сайті php.net був приклад, де вони цю всю двыжуху описали в обєкті, і ці ф-ції були його методами.
							Тут буде тег(імя елемента точніше. Це ж не хтмл). Теги за замовчуванням приводяться до верхнього регістру, 
							атрибути цього тега){}; Так - function onStart($parser, $tag, $attributes){...};
	- Ф-ція для закриваючого тега - Так само як і для відкриваючого тега, тільки тут немає аргумента для атрибутів, так як у закриваючого тега немає атрибутів // function onEnd($parser, $tag){
	- Ф-ція для текста - Тут перший аргумент, як у 2-х попередніх, а інший аргумент буде для тексту - function onText($parser, $text){...}
10) Щоб привязати ці собтія до документа, є 2 ф-ції
	- для Тегів - xml_set_element_handler( $sax ($sax = xml_parser_create('utf-8') - обовязково по ходу ), 'onStart', 'onEnd');
	- для Текста - xml_set_character_data_handler($sax ($sax = xml_parser_create('utf-8') - обовязково по ходу ) , 'onText');

 --- DOM ---
 - Тут вже ООП;
 1) DOM - DomDocument(); // $dom = DomDocument(); - пустий дом документ
 2) $dom->load("catalog.xml"); - Загружає в память і розвертає його
 3) documentElement - Цей корневий елемент, який має бути у хмл єдинм і ніщо не має бути під ним або над ним (типу <html>), називається елемент документа.
	- Щоб його вибрати, є ф-ція - documentElement; $root = $dom->documentElement; І тепер у змінній $root є ця вся двіжуха, що в мадженті.
- Я взяв корневий елемент, але це буде діяти для всіх
	- $root->nodeType; - тип(число), який має вузел.
	- $root->textContent; - Весь текст, що є в елементі
	- ......
 4) Тут по ходу є ф-ції getElementsByTagName і ця вся двіжуха, але спеціаліст коли хотів взяти якиїсь дочерній елемент, добирався до нього через корневий узел
 5) Якщо у елемента є декілька дітей, і я хочу їх взяти $obj = $elem->childNodes; то вони будуть у змінній $obj. Цей обєкт можна перебрати через foreach і в ньому будуть діти
	
 ----- Вище були ф-ції, які читали документ, тепер буде єдиний спосіб, який створює його.
 6) $dom = new DomDocument("1.0", "utf-8"); - Створить новий документ(вузел). Тільки вузел-документ може щось створювати 
	- $root = $dom->documentElement; - // $root - корневий елемент документа
		- $book = $dom->createElement('book'); - створення нового елемента
		- $title = $dom->createElement('title'); - створення нового елемента
		- $text = $dom->createTextNode('Назва книги наприклад'); - створення текстового вузла

		- І тепер це все добавити в документ
		- $title->appendChild($text);
		- $book->appendChild($title);
		- $root->appendChild($book);
	- Мош мало упростити і зробити інакше. Мош створити нараз текстовий вузел і елемент у якому він буде одним махом // $title = $dom->createElement("title", "Назва книги наприклад");
		- $book->insertBefore($author, $title); - типу $author вставиться перед  $title
7) Символи в хмл називаються PCDATA (текст, який треба розпарсити)
	- для PCDATA спеціальні символи, які є в хтмл (типу пробіла або ще щось &alt;) це не стандарт і коли він їх побачить буде плохо. PCDATA Це типу подвійні лапки у пхп, він буде парсити хмл
	- щоб воно не парсило код, а записувало як є (типу одинарні лапки у пхп), треба використовувати не PCDATA а CDATA. Виглядати в кінечному варанті воно буде приблизно <title>(тобто xml_tag)><!CDATA[тут буде текст, який не треба парсити]></title> . Щоб не парсилось, треба обробити текст при його створенні ф-ціями, які зроблять з нього CDATA
		- $description = $dom->createElement('description');
		- $cdata = $dom->createCDATASection('... описание книги ...');
		- $description->appendChild($cdata);
		- і далі вже стандартно
	- Перероблювати в CDATA по ходу взагалі дуже важлтво. Спеціаліст казав що для даних, які приходять з форми, це взагалі обовязково. З форми з напевне можуть прийти якісь крокозябри, а не тільки стандартний текст.
8) save() - зберегти. Перенести з памяті в документ. // $dom->save('document-name.xml');
9) Коли я редагував уже существующий файл ( $dom->load("catalog.xml"); ), то щоб зміни сохранились, досить було додати нові елементи в корневий каталог. Спеціаліст казав, шо якщо я буду не редагувати документ, а створювати повністю новий, треба буде додавати і корневий каталок у вузел його батька щоб збереглось.
10) Rss - мова на основі хмл.
11) Упрощено - саме головне, що в хмл все вузли. Це головний вузел - <?xml version="1.0" encoding="utf-8"?> У ньому буде його дитина - корневий елемент і тд.. В принципі так будуть виглядати усі документи хмл, але мабуть можна вносити трохи свої корективи
12) Щоб хмл нормально форматувався, були відступи і тд, треба написати ці строчки $dom->formatOutput = true; $dom->preserveWhiteSpace = false;
13) Я зробив RSS. Він є у файлах курса. В принципі він майже нічим не відрізняється від стандартної хмл
14) Атрибути теж може створювати тільки дом
15) Тут повністю ооп. Тобто навіть значення атрибутам треба давати через ооп $version = $dom->createAttribute('version'); $version->value = '2.0';
---- Simple Xml ---
// catalog.xml
<catalog>
	<book>
		<title>450 Градусов по Фаренгейту</title>
		<description><![CDATA[вчыф]]></description>
	</book>
</catalog>
 - То що я писав вверху - це стандартий варіант, але є упрощений. По аналогії java-script, jquery;
1) $sxml = simplexml_load_file("catalog.xml"); - Загружаем документ и преобразуем его в объект // Це вже зразу корінь документа. Тобто вже не треба заморачуватись, що спочатку берем документ, потім його корінь ....
	- simplexml_load_string("XML строка ($string)"); - Загружаем XML-строку и преобразуем его в объект // Я думав це типу  getElementsByTagName(); але в спеці пише що це для цього $string = <<<XML
									<?xml version='1.0'?> 
									<document>
									 <title>Forty What?</title>
									 <from>Joe</from>
									 <to>Jane</to>
									 <body>
									  I know that's the answer -- but what's the question?
									 </body>
									</document>
									XML;
	- Всі елементи цього $sxml будуть його свойствами. Наприклад це корневий каталог. у ньому є книжки(<book>) і я хочу до них достукатись // $sxml['book'][0(порядковий індекс)]. 
		- Якщо у <book> є діти і я хочу вибрати їх - $sxml['book'][0]->title;
		- $sxml['book'][0]->title['lang']; - якщо title має атрибут lang, то вибрати його можна так
		- $sxml['book'][0]->title - "Цей текст буде у тезі title";
		- Велике приймущество у тому, що коли перебираю вузли якогось елемента, то те треба писати ці дурні провірки на типи. Оскільки пробел це теж вузел, , типу, якщо це пробіл або перевод строки - не виводь, виводь якщо текст і тд. По аналогії java-script, jquery;
2) $xml = $sxml->asXML(); - Преобразование объекта в строку // Типу simplexml_load_file зробив з строки дерево (у памяті) і ці всі ф-ції, типу $sxml['book'][0]->title - "Цей текст буде у тезі title"; - це я працював з деревом у памяті. Тобто  після цього $sxml['book'][0]->title - "Цей текст буде у тезі title"; у змінній $sxml лежить дерево цього документа, але з іншим тайтлом. Щоб зробити знов з нього строку ( xml файл ), треба використати ф-цію - asXML(); І вже потім вставляти цю строку у хмл файл - file_put_contents("catalog.xml", $xml);
	- Но спеціаліст, коли виводив строку разом з тегами, яку зробила ф-ція asXML(); у браузері вона не показувалась, тільки в ісходному коді
3) foreach теж має break;
4) Не знаю чи є це і у простому хмл, але у RSS ф-ція simplexml_load_file не бере зразу корінь документа (типу <html>), а бере вузел вище нього. Тобто щоб взяти корінь, треба буде вибрати його. $file = simplexml_load_file('file.xml'); $file['имя-кореня'];


5) Обмін даними між клієнтом і сервером проходить через xml;




















https://eax.me/lxc/

