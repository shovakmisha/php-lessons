1) Фція у класі залишається ф-цією з усіма її свойствами. Вона не буде бачити свойства класа, якщо не вказати this.
	- global тут вже не канає
2) Псевдоконстанти класа
	- __FUNCTION__ - імя текущої ф-ції
	- __CLASS__ - імя текущого класа
	- __METHOD__ - імя текущого класа і ф-ції ClassName::methodName
3) такий запис теж коректний - echo "my mame is {$obj->name}"
4) Конструктор зразу викликається при створенні обєкту
	- викликається він зразу тільки у обєктів, які створились від класа. 
5) круглі дужки, які вказуються при створенні обєкта, це дужки конструктора // $obj = new obj(); // дужки в c-подыбних мовах, це запуск ф-цїї
7) По суті конструктор, це встроєна ф-ція класа. Якщо подивити, яке імя має конструктор, то він буде мати імя класа // __constructor = function className(of this constructor)
	- $obj = new Class() - цей запис означає, що я присвоюю обєкту клас і викликаю при цьому конструктор
6) Деструктор, типу конструктора, але запускається при видаленні обєкту. Обєкт видадяється в 2-х випадках
	- Коли скріпт закінчився ( коли скріпт закінчився все видаляється )
	- Ф-цією unset() // unset() // вызов деструктора unset($obj);
	- теж запускається автоматично
	- в круглі дужки нічого не передається, вони просто для синтаксису
8) В пинципі обєкти теж не можна переприсвоювати.  так само як і в скріпті. Тобто обєкт, це 1 участок памяті і на нього можуть ссиатись різні змінні, але якщо якась з змінних змінить його, то у всіх змінних що ссилаються на обєкт він зміниться.
	- Хоча є костиль. Ф-ція clone - склонує обект. І щоб я не роби з склонованим обєктом, той з якого я склонував не зміниться// $newObj = clone obj(10);
	- Але у цьму випадку не буде конструктора. Він буде тільки якшо буде присвоюватись через оператор new. Можна написати костиль, якщо птсати те що має робити конструктор у ф-ції __clone // function __clone(){...}
 - клон треба писати у класі
 - екстендити можна і екстенджений обєки
	- кожен екстенджений обєкт може достукатись до того, від якого він екстендився методом parent // parent::someFunction(); Це зручно у випадках коли до цієї ф-ції або після неї треба викликати інші ф-ції.
	- Якщо є ситуація що треба звернутись до парента парента, це означає що у мене хренова архітектура. Тобто не має виникати такої ситуації, що мені це треба зробити

	
9) extend - щоб створювати свый клас на основы іншого класу і можна буде доповнити його
10) try catch працює та само, тільки тут є можливість вивести строку, файл і меседж у якому сталась ця помилка. Хоча можливо є ще якась інфа
	- Exeption у try catch це встроэний клас. його наслідувати можна. але якщо наслідувати, то стандартний Exeption має бути останній, оскільки пхп продивлює код перед тим як виповнювати. І перший раз завжди виконується клас від якого інші наслідуються і так далі
	- Якщо у try попала помилка, код під ним не виконається, виконання коду перепригне у catch


 - Абстрактий клас - такий самий клас, але його не можна присвоїти обєкту, він використовується для як образец. Його можна тільки екстендити і вже заекстенджений можна присвоїти
	- може мати абстрактні методи - abstract function name(); Абстрактний метод не маэ реалізації. Тобто він обявлений, але у фігурних дужках нічого не описано. Кожен може писати що хоче. І вставляти його можна куди хочу у будь яке місце екстендного класу, головне щоб він там був
	- Його обовязково треба описати. Тобто якщо він є у абстрактному класі. я від нього заекстендився. У заекстендженому класі має бути цей абстрактий метод. але вже звичайно без abstract
 - Інтерфейс - це абстрактий клас який содержить тількьки абстрактні методи
	- У ньому вже не треба писати abstract перед ф-цією, це й так зрозуміло. // interface Name{ function(){...} }
	- Інтерфейси не екстендяться, а реалізуються командою іmplements. По суті це те ж саме що екстенд class A implements AbstractAClass
	- Якщо робити класи з з абстактних методів і не вказувати присвоювати обєктам, це означає програмування на ріівні інтерфейсів
	- У один клас можна реалізувати декілька інтерфейсів class A implements A, B C{}
	- Взагалі інтерфейс це як БЕМ. Їх навіть називають щоб було зрозуміло, що він робить. Типу я створюю клас і реалізую в нього ті інтерфейси які мені треба
	- Можна зразу і екстендити і реалізовквати одночасно // class MyClass extend Class implement A, B, C{...}
	- Якщо я реалізував 2 різні інтерфейси у яких є одинакові методи, то так не получиться, так не можна. Хоча якщо спеціаліст ставив одному аргументи то канало. в будь якому разі це погана практика

 - InstanceOf - чи наслідується обєкт від класа // false/true
20) У класі модна обявляти константу. Ця константа буде обща для всіх наслідуємих обєктів. const ConstNAme
	- Щоб до нех доступитись використовується оператор self // self::ConstNAme -
	- Або прямо з класа - ClassName::ConstNAme
	- Без доллара. Якщо з долларом то це буде змінна static $ConstNAme
21) static $ConstNAme - типу що залишає своє значення, а не скидує його кожного разу // public static static $variableName;
	- звернутись до неї можна - self::$variableName або Classname::$variableName
	- зазвичай використовуються для того щоб перевырити скыльки від нього екстендиться обєктів
	- Статична змінна не належить до обєкта, вона належить до класа, вона одна для всіх обєктів
22) Те ж саме модуть бути статичны методи // static function methodName(){}
	- звернутись до нього можна - self::methodName() або Classname::methodName()
23) Якщо я створюю обєкт методом new від класа якого немає, то буде фатальна помилка. Але всеж таки у цього обєкта може зявитися ф-ція __autolad, якщо я її пропишу
	- Ця ф-ція може мати 1 аргумент. У аргументі буде хранитись імя цього обєкта
	- Коли ще не було неймспейсів, то тоді ця ф-ція загружала код методом, рекваєр(інклюд) клас з іншого файлу.
	- типу якщо у моєму файлі пфдключаються декілька класів і в них помилка, то ця фція буде працювати не одноразово // Якщо всі класи в одній папці, то цей код підключить всі, навіть якщо у підключаємих класів є залежності
	function __autoload($className) {
        	require_once "classes/$className.class.php";
    	}
24) Модифікатори доступу. Області бачення класа
	- public - доступ з будь якої області бачення
	- privat - забороняє доступ з глобальної області. Щоб доступитись до privat з глобальної області, можна написати біля цього privat ф-цію, яка буде получати з нього дані Наприклад - function getPrivat(){ return $this->privat; } . Те ж саме для  protected
	- protected - забороняє доступ з глобальної області. Безполезний, майже ніхто його не використовує. Так як він дає доступ до себе ектендженому класу. На відміну від privat, який не дає доступ до себе з інших класів і до нього можна доступитись тільки з того у якому він створений
25) Методи(function) обєкта в php по умолчанію public 
	- свойства в принципі теж але їх треба указувати // public variable //
26) Наприклад у мене пустий є клас. Від нього я створив обєкт. І динамічно добавив якесь свойство у обєкт. Можна називати це багою або фічею, але в будь якому разі це не порядок, так як в класі цього свойства немає, і шукати його значення по проекту, не очень камельфо.
	- Доречі не обовязково щоб це свойство було відсунє, воно може бути і приватне або протектед
	- Перед тим як записати динамічно ці свойства, він дивить чи у класа немає магічної ф-ції сет. Ф-ція __set(свойство, значення) має 2 параметри - свойство і значення які я хочу кинути в обєкт. І там вже описувати що з ними робити і куди їх додавати
	- __get() - Те ж саме що сет. Якщо я запросив у обєкта, свойство, якого в нього немає, то перед тим як кидати помилку, він спрочатку подивить чи не описаний в класі метод гет у якого є 1 аргумент - імя свойства
	- Не обовязково ці свойства, яких не має в класі прям записувати в клас через this, як свойство обєкта. можна просто виводити, або класти їх у масив, короче будь що. Спеціаліст робив і так і так
 - В двох словах - додаю свойство, а воно є в класі тільки приватне, то сет спрацює. Якщо публічне, не спрацює
 - По аналогії, якщо я хочу вивести метод, якого не існує, визветься __call(імя метода, масив аргументів){}
	- Якщо це статичний метод, то для нього визветься __callStatic()
27) Якщо я хочу вивести обєкт ( echo object ), то буде помилка. Але перед тим визветься ф-ція __toString(){} Я можу її описувати як хочу
	function __toString(){
		return " цей обєкт - екземпляр класа ". __CLASS__
	}
28) Якщо я хочу визвати обэкт як ф-цію, буде помилка
	- Але по аналогії з преддущими, якщо я опишу ф-цію __invoke(аргументи які хочу і скільки хочу), то викличеться ця ф-ція
29) Серіалізація (створення файлика і занесення туди наних. Типу як кукі). Так як життя обєкта дуже коротке (виповнився і його вже немає). Щоб був доступ до його даних (наприклад юзер і пароль), використовується серіалізація. І вже з файлика беруться дані
	- На можна просто серіалізувати обєкт, серіалізуюються свойства обєкта. Тобто у дужки ф-ції серіалізавції попадає обєкт, але серіалізуються тільки ті свойства, шо я вказав в __sleep() // serialize($obj);
	- Щоб серіалізувати декілька свойств, треба поставити їх у масив
	- __sleep(тут писати які свойства класа серіалізовувати) - каже які свойства серіалізовувати. Ця ф-ція викликається перед серіалізацією
	- коли буде ансеріалізація обєкта, конструктор не викличеться і ті свойства, які я не указав у __sleep теж не відновляться. Якщо я захочу, щось зробити після ансеріалізації, є ф-ція __wakeup(), яка автоматом викличеться  після ансеріалізації
	// Вызывается после сериализации
		function __wakeup(){
		$this->params = $this->getUser();
	}
30) Є ще фінальні класи, які не можна екстендити. Такі класи використовуються, якщо розробник планує доробити клас і щоб там нічого не поламалось, екстенд забороняється.
	- По аналогії з цим є фінальний метод
31) Наприклад є клас з статичними методами, якщо серед цих методів буде метод, який буде викликати інший метод, то self::method не підійде, тому що в цьому випадку він буде звертатись до оригінального класа, і при екстенді оришінального класа це не буде підходити. Краще використати static:: У такому випадку екстенджений клас і буде їх батьківським класом // static function foo(){ static::neededFunction() } викликати 

Подивити останні хвилини ще раз 1-го уроку

sqlite - екранування строк escapeString

10) наслідуваний клас, це теж клас 

https://www.linkedin.com/in/lyudmyla-lepen-a305aa152/
