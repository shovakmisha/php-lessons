 1) Дата знаходиться в php.ini в ключі date.timezone. Коли сервак устанювлює дату, він звертається сюди. Якщо її не вказати, буде помилка. Щоб всказати, треба дати цьому ключу значення "Europe/Moscow" наприклад. аБО Ф-цією date_default_timezone_set("Europe/Moscow");
 2) int time() - повертає таймстеп часу (текущого за замовчуванням), починаючи з 1970 01 01
	- microtime() - більш точний таймстемп. Цією ф-цією можна перевіряти швидкість скріпта. Якщо сервер загружений, скріпт виконується довше
 3) date() - може хранити у собі не тільки текущу дану, але і таймстеп, якщо я покладу його туди. І з цього можна витягнути дату у якому хочу форматі, головне правильно вказати формат в дужках
	- strftime() - Те ж саме, хоча ця ф-ція залежить від того, де знаходиться користувач і буде пробувати показувати дату на його мові // ru_RU
 - mktime() - зробить таймстемп. Аргументи ф-ції підставляти не обовязково, замість них підставиться значення текущого часу. Не обовязково підставляти, я маю на увазі з права на ліво, рік на приклад можна вказувати, підставиться текущий. Останній аргумент у цій ф-ції - це зимній, літній час.
	- осторожно з цією ф-цією. Вона не має помилок вроді. Тут діє вся ця херня з 13-м місяцем і тд
 - getdate( $timestamp ) - получиться масив з датою. У мавиві будуть ключі секунда, день...
 4) Julian Day Count (JDC) - Юліанський календар. Ми з ним працюєм в програмуванні
	- Коли треба працювати з дуже древніми або дуже далекими (3000р), то тут вже треба вказувати дату чере ф-цію GreqorianToJ
	- там ще є ф-ціє з цим календарем і з іншими і переводами 1 в інший, але довго розписувати, краще загуглити
 5) checkdate() - перевіряє чи існує дата, яку я їй передав в дужках в Григоріанському календарі. Дивно що в григоріанському, раніше він писав, що пхп використовує Юліанський, можливо помилявся
	- Типу у цій ф-ції перевіряється правильність формату, наприклад 30 лютого.
 6) В файлі calendar.php, Котеров написав хороший календар на теперішній місяць
	- До речі тернарний оператор можна написати і так - <?= $i == 6 ? 'color:red' : '' ?>
 7) Greenwich Mean Time - GMT; теж саме, що UTC;
	- Наприклад у місті Грінвіч тепер 01 00, Москва має +03 00, то ж в Москві тепер 4 години ночі
	- Котеров не дав універсального рецепта, як працювати з датами, Сказав тільки, що якщо є ситуація, де треба кожному користувачу виводити дату, і щоб був час такий як його країні ( Наприклад у користувача виводиться інфа, коли він останній раз заходив на сайт ), то у базі треба буде хранити час по Грінвічу, а йому вже коли буде виводитись, то треба буде оприділити його місцеположення і приплюсувати йому години (+03 00)
 8) Котеров робив приклад ф-ції, де він визначав локальний час користувача // 375 ст
 9) ПХП розробники дають можливість написати свою фі-цю при завершенні скріпта і не важлило чи він просто завершився чи із за помилки. її можна використати щоб занести інфу у буфер або у файл логів або як заманеться
	- Для цього треба зареєструвати її як фіналізатор - register_shutdown_function ().
	- exit() i die() теж викличуть цю ф-цію
	- вивести у браузер цією ф-цією нічого не можна // echo не спрацює
	- зазвичай вона викликається вже після зєднання сервера з клієнтом. Тож виводити дані сервера цією ф-цією нема сенсу
	 - І взазалі в пхп після помилки мало що можна зробити
 10) В пхп теж є анонімні ф-ції
 11) usleep(), sleep() - скріпт може завмерти на скільки вкажу. Це можна використати, токи закриється файл, або щось таке

------------ ООП --------------
 - Можна сказати що методи належать до класу ( у всіх одинакові мали б бути ), а свойства належать до обєкта (у кожного обєкта різні)  
 12) Клас - тип (якоїсь змінної). Наприкдад у класа int є свойства(методи) для всіх операцій з числами +-*/....
	- Типу клас - це кастомний тип даних
 13) Змінна класа - обєкт класа
 Інкапсуляція - дані, які належать до класа, зберігаються в його свойствах і до них огранічений доступ в основному за допомогою інших методів
 14) Клас - тип даних. Створюється за допомогою команди class
 15) Рекомендація - 1 файл - 1 клас. Для полегшення пошуку
 16) значення не обовязково храниться у змінних - echo 1 + 2 створить значення 3 до якого не пивязана ніодна змінна
 17) Щоб створити обєкт класа, використовується ключове слово new
	$obj = new SomeClass; - $obj буде хранити всі дані класа

<?php ## Пример класса.
  class MathComplex
  {
    // Свойства: действительная и мнимая части.
    public $re, $im;
    // Метод: добавить число к текущему значению. Число задается
    // своей действительной и мнимой частью.
    function add($re, $im)
    {
      $this->re += $re;
      $this->im += $im;
    }
  }
?>
 18) $this завжди присутній внутрі методів класу
 19) Ф-ція, яка находится в класі, може бачити $this. І всі його змінні теж.
	  class MathComplex
	  {
	    public $re, $im;
	    function add($re, $im)
	    {
	      $this->re += $re; MathComplex->add(10,20) збільшить public $re, $im; на 10 і 20
	      $this->im += $im;
	    }
	  }

 20)  Агрумен у ф-цїї може бути будь що, наприклад обєкт класа. Наприклад є якиїсь обєкт і зразу у дужках ф-ції я присвою його обєкту 
	// class MyClass{}; function (MyClass $myObj){}; І тепер $myObj обвязково має бути обєктом MyClass. ТОбто $myObj має або наслідувати MyClass або шось у тому роді. Короче я десь писав вверху що клас це тип даних. MyClass - це тип. Так само як і масив або строка. Щоб привести елемент до якогось типу треба написати перед ним цей тип. Як я робив провірку для даних форми, які мають бути числами (id наприклад) // int $id.
Тут так само тыльки замість int MyClass
	- Трохт запутано. ця конструкція в круглих дужках ф-ції (MyClass $myOb) присвоює MyClass змінній $myOb традиційним методом скоріш за все, типу $myOb = MyClass; Але так обєкти не створюються, вони створюються оператором new. Мабуть краще щоб при виклику такої ф-ції у дужках була змінна вже з готовим обєктом, створеним через цей оператор, але якщо її немає і мені треба поставити туди клас, то треба дописати тудм оператор new // (new MyClass $myOb) або $add = new Context( new Add );
 21) В Котерова був код, де він спочатку створював масив, накидував туди строки текстового файла а потім перед закриванням файлу він записав ці дані у файл. І казав що це продуктивний метод
 22) Деструктори зазвичай освобождають память машини - типу записують дані у файл і закривають його, або форматують диск
	- Якщо обєкт, клас, знаходяться у змііній, то якщо цій зміннії переприсвоїти щось інше, визветься деструктор, хоча якщо перед переприсвоєнням, кинути його кудись (наприклад в масив), то деструктор не визветься
	- обєкти, на які в програмі немає ссилок, зразу видаляються. Він це оприділяє по внутрішньому счотчику, який збільшується, зменшується при новій ссилці на обєкт. Цей счетчик храниться і в привоєному обєкті і в присваємому
	- циклічні лінки, коли 1-й обєкт ссилається на 2-й обєкт, а 2-й ссилається на 1-й. Їх може бути більше, але суть в тому, що обєкти збережені один в одному, і коли розірвати лінку ф-цією unset наприклад, то обєкт не видалться з участка памяті, оскіольки на нього ще ссилається у іншому обєкті. А якщо зробити unset і для того обєкта, то він теж не видалиться, оскільки счотчик = 1, так як на нього ссилаєтья видалений обєкт. і получиться так, що вони будуть займати память, але до них не можна буде достукатись. У пхп є інструмент для збору такого мусора, він ресурсойомкий і його можна буде відключити у php.ini
	- Якщо Котеров говорив тільки про обєкти в контексті ресурсопамяті, то мабуть з класами цієї херні не має

 22) Модифікатори доступу - Старатись по максимуму все скривати, залишаючи доступ тільки до того, що дійсно потрібно. Відкрити метод завжди краще ніж закрити, може все поламатись
	- Зазвичай писати спочатку відкриті методи, а потім закриті.
	- Свойства взагалі робити закритими і робити доступ до них тільки з відкритих методів
 23) Зазвичай protected це методи а не свойства якы створені для виконання низькорівневих задач
 24) Можна змінні присвоювати свойствам обєкта на ходу, але не статичним
	$key = "test";
	$obj->$key = 314;	
 25) Свойство, якому нічого не присвоїно теж саме, що йому присвоїли null
 26) Коли я працюю з self, то завжди використовую ::  двы двокрапки. Коли я виукликаю метод або свойство через клас, то теж через 2 двокрапки. Мабуть у цьому випадку, вони будуть статичні
 27) Хоча статичні класи, методи і не можна викликати через $this, їх все ще можна викликати через обєкт - $objs->getCount()
 28) Метод create - Створення обєкта класа
 29) До констант теж треба обращатись через подвійні двокрапки, і тільки з класа або через self. Щоб опридылити чи вона існує, є метод define і провіряти через клас, за селф Котеров не казав
 30) _get ( ), _set ( ) - не будуть працювати, якщо свойсва існують
 31) $y = clone $x; - клонування. Він нічого не говорив про конструктор, просто сказав, що вклон склонований побайтово
 32) Якщо у обєкта є дочірні обєкти, при його серіалізації, будуть серіалізуватись і вони, тобто для них теж виклечеться __sleep( і __wakeup) при ансериалізації
	- Важливо щоб при ансеріалізації обєкта, був доступ до класа цього обєкта, інакше востановлення буде не повністю, без методів
 33) При екстенді, старий клас уже не використовувати
 34) У екстендженого класа модифікатор не має бути більш жосткий як у парента
 35) Php 7 дає можливість створювати анонімні обєкти. Приклад створення на льоту 
	Dumper::print( new class { - у класа Dumper є метод print, який приймає у аргумент обєкт і виводить його ф-цією print_r
	    public $title;
	    public function __construct(){
	      $this->title = "Hello world!";
	    }
	  }); print_r(new Class) - виведе масив з імям класа і його змінними
	- внутрі класів можна створювати анонімні класи. але вони не будуть бачить захищені дані. Щоб побачили протектед, треба щоб він заекстендився від класа в якому він знаходиться, а щоб побачив приват, треба додати його в конструктор - return new class($this->title) extends Container{}; - title - приватний. Ретурн і крапка з комою вкіці - обовязкові
 36) Лічні кабінети користувача не можна кешувати


