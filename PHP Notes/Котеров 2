 1) Дата знаходиться в php.ini в ключі date.timezone. Коли сервак устанювлює дату, він звертається сюди. Якщо її не вказати, буде помилка. Щоб всказати, треба дати цьому ключу значення "Europe/Moscow" наприклад. аБО Ф-цією date_default_timezone_set("Europe/Moscow");
 2) int time() - повертає таймстеп часу (текущого за замовчуванням), починаючи з 1970 01 01
	- microtime() - більш точний таймстемп. Цією ф-цією можна перевіряти швидкість скріпта. Якщо сервер загружений, скріпт виконується довше
 3) date() - може хранити у собі не тільки текущу дану, але і таймстеп, якщо я покладу його туди. І з цього можна витягнути дату у якому хочу форматі, головне правильно вказати формат в дужках
	- strftime() - Те ж саме, хоча ця ф-ція залежить від того, де знаходиться користувач і буде пробувати показувати дату на його мові // ru_RU
 - mktime() - зробить таймстемп. Аргументи ф-ції підставляти не обовязково, замість них підставиться значення текущого часу. Не обовязково підставляти, я маю на увазі з права на ліво, рік на приклад можна вказувати, підставиться текущий. Останній аргумент у цій ф-ції - це зимній, літній час.
	- осторожно з цією ф-цією. Вона не має помилок вроді. Тут діє вся ця херня з 13-м місяцем і тд
 - getdate( $timestamp ) - получиться масив з датою. У мавиві будуть ключі секунда, день...
 4) Julian Day Count (JDC) - Юліанський календар. Ми з ним працюєм в програмуванні
	- Коли треба працювати з дуже древніми або дуже далекими (3000р), то тут вже треба вказувати дату чере ф-цію GreqorianToJ
	- там ще є ф-ціє з цим календарем і з іншими і переводами 1 в інший, але довго розписувати, краще загуглити
 5) checkdate() - перевіряє чи існує дата, яку я їй передав в дужках в Григоріанському календарі. Дивно що в григоріанському, раніше він писав, що пхп використовує Юліанський, можливо помилявся
	- Типу у цій ф-ції перевіряється правильність формату, наприклад 30 лютого.
 6) В файлі calendar.php, Котеров написав хороший календар на теперішній місяць
	- До речі тернарний оператор можна написати і так - <?= $i == 6 ? 'color:red' : '' ?>
 7) Greenwich Mean Time - GMT; теж саме, що UTC;
	- Наприклад у місті Грінвіч тепер 01 00, Москва має +03 00, то ж в Москві тепер 4 години ночі
	- Котеров не дав універсального рецепта, як працювати з датами, Сказав тільки, що якщо є ситуація, де треба кожному користувачу виводити дату, і щоб був час такий як його країні ( Наприклад у користувача виводиться інфа, коли він останній раз заходив на сайт ), то у базі треба буде хранити час по Грінвічу, а йому вже коли буде виводитись, то треба буде оприділити його місцеположення і приплюсувати йому години (+03 00)
 8) Котеров робив приклад ф-ції, де він визначав локальний час користувача // 375 ст
 9) ПХП розробники дають можливість написати свою фі-цю при завершенні скріпта і не важлило чи він просто завершився чи із за помилки. її можна використати щоб занести інфу у буфер або у файл логів або як заманеться
	- Для цього треба зареєструвати її як фіналізатор - register_shutdown_function ().
	- exit() i die() теж викличуть цю ф-цію
	- вивести у браузер цією ф-цією нічого не можна // echo не спрацює
	- зазвичай вона викликається вже після зєднання сервера з клієнтом. Тож виводити дані сервера цією ф-цією нема сенсу
	 - І взазалі в пхп після помилки мало що можна зробити
 10) В пхп теж є анонімні ф-ції
 11) usleep(), sleep() - скріпт може завмерти на скільки вкажу. Це можна використати, токи закриється файл, або щось таке

------------ ООП --------------
 - Можна сказати що методи належать до класу ( у всіх одинакові мали б бути ), а свойства належать до обєкта (у кожного обєкта різні)  
 12) Клас - тип (якоїсь змінної). Наприкдад у класа int є свойства(методи) для всіх операцій з числами +-*/....
	- Типу клас - це кастомний тип даних
 13) Змінна класа - обєкт класа
 Інкапсуляція - дані, які належать до класа, зберігаються в його свойствах і до них огранічений доступ в основному за допомогою інших методів
 14) Клас - тип даних. Створюється за допомогою команди class
 15) Рекомендація - 1 файл - 1 клас. Для полегшення пошуку
 16) значення не обовязково храниться у змінних - echo 1 + 2 створить значення 3 до якого не пивязана ніодна змінна
 17) Щоб створити обєкт класа, використовується ключове слово new
	$obj = new SomeClass; - $obj буде хранити всі дані класа

<?php ## Пример класса.
  class MathComplex
  {
    // Свойства: действительная и мнимая части.
    public $re, $im;
    // Метод: добавить число к текущему значению. Число задается
    // своей действительной и мнимой частью.
    function add($re, $im)
    {
      $this->re += $re;
      $this->im += $im;
    }
  }
?>
 18) $this завжди присутній внутрі методів класу
 19) Ф-ція, яка находится в класі, може бачити $this. І всі його змінні теж.
	  class MathComplex
	  {
	    public $re, $im;
	    function add($re, $im)
	    {
	      $this->re += $re; MathComplex->add(10,20) збільшить public $re, $im; на 10 і 20
	      $this->im += $im;
	    }
	  }

 20)  Агрумен у ф-цїї може бути будь що, наприклад обєкт класа. Наприклад є якиїсь обєкт і зразу у дужках ф-ції я присвою його обєкту 
	// class MyClass{}; function (MyClass $myObj){}; І тепер $myObj обвязково має бути обєктом MyClass. ТОбто $myObj має або наслідувати MyClass або шось у тому роді. Короче я десь писав вверху що клас це тип даних. MyClass - це тип. Так само як і масив або строка. Щоб привести елемент до якогось типу треба написати перед ним цей тип. Як я робив провірку для даних форми, які мають бути числами (id наприклад) // int $id.
Тут так само тыльки замість int MyClass
	- Трохт запутано. ця конструкція в круглих дужках ф-ції (MyClass $myOb) присвоює MyClass змінній $myOb традиційним методом скоріш за все, типу $myOb = MyClass; Але так обєкти не створюються, вони створюються оператором new. Мабуть краще щоб при виклику такої ф-ції у дужках була змінна вже з готовим обєктом, створеним через цей оператор, але якщо її немає і мені треба поставити туди клас, то треба дописати тудм оператор new // (new MyClass $myOb) або $add = new Context( new Add );
 21) В Котерова був код, де він спочатку створював масив, накидував туди строки текстового файла а потім перед закриванням файлу він записав ці дані у файл. І казав що це продуктивний метод
 22) Деструктори зазвичай освобождають память машини - типу записують дані у файл і закривають його, або форматують диск
	- Якщо обєкт, клас, знаходяться у змііній, то якщо цій зміннії переприсвоїти щось інше, визветься деструктор, хоча якщо перед переприсвоєнням, кинути його кудись (наприклад в масив), то деструктор не визветься
	- обєкти, на які в програмі немає ссилок, зразу видаляються. Він це оприділяє по внутрішньому счотчику, який збільшується, зменшується при новій ссилці на обєкт. Цей счетчик храниться і в привоєному обєкті і в присваємому
	- циклічні лінки, коли 1-й обєкт ссилається на 2-й обєкт, а 2-й ссилається на 1-й. Їх може бути більше, але суть в тому, що обєкти збережені один в одному, і коли розірвати лінку ф-цією unset наприклад, то обєкт не видалться з участка памяті, оскіольки на нього ще ссилається у іншому обєкті. А якщо зробити unset і для того обєкта, то він теж не видалиться, оскільки счотчик = 1, так як на нього ссилаєтья видалений обєкт. і получиться так, що вони будуть займати память, але до них не можна буде достукатись. У пхп є інструмент для збору такого мусора, він ресурсойомкий і його можна буде відключити у php.ini
	- Якщо Котеров говорив тільки про обєкти в контексті ресурсопамяті, то мабуть з класами цієї херні не має

 22) Модифікатори доступу - Старатись по максимуму все скривати, залишаючи доступ тільки до того, що дійсно потрібно. Відкрити метод завжди краще ніж закрити, може все поламатись
	- Зазвичай писати спочатку відкриті методи, а потім закриті.
	- Свойства взагалі робити закритими і робити доступ до них тільки з відкритих методів
 23) Зазвичай protected це методи а не свойства якы створені для виконання низькорівневих задач
 24) Можна змінні присвоювати свойствам обєкта на ходу, але не статичним
	$key = "test";
	$obj->$key = 314;	
 25) Свойство, якому нічого не присвоїно теж саме, що йому присвоїли null
 26) Коли я працюю з self, то завжди використовую ::  двы двокрапки. Коли я виукликаю метод або свойство через клас, то теж через 2 двокрапки. Мабуть у цьому випадку, вони будуть статичні
 27) Хоча статичні класи, методи і не можна викликати через $this, їх все ще можна викликати через обєкт - $objs->getCount()
 28) Метод create - Створення обєкта класа
 29) До констант теж треба обращатись через подвійні двокрапки, і тільки з класа або через self. Щоб опридылити чи вона існує, є метод define і провіряти через клас, за селф Котеров не казав
 30) _get ( ), _set ( ) - не будуть працювати, якщо свойсва існують
 31) $y = clone $x; - клонування. Він нічого не говорив про конструктор, просто сказав, що вклон склонований побайтово
 32) Якщо у обєкта є дочірні обєкти, при його серіалізації, будуть серіалізуватись і вони, тобто для них теж виклечеться __sleep( і __wakeup) при ансериалізації
	- Важливо щоб при ансеріалізації обєкта, був доступ до класа цього обєкта, інакше востановлення буде не повністю, без методів
 33) При екстенді, старий клас уже не використовувати
 34) У екстендженого класа модифікатор не має бути більш жосткий як у парента
 35) Php 7 дає можливість створювати анонімні обєкти. Приклад створення на льоту 
	Dumper::print( new class { - у класа Dumper є метод print, який приймає у аргумент обєкт і виводить його ф-цією print_r
	    public $title;
	    public function __construct(){
	      $this->title = "Hello world!";
	    }
	  }); print_r(new Class) - виведе масив з імям класа і його змінними
	- внутрі класів можна створювати анонімні класи. але вони не будуть бачить захищені дані. Щоб побачили протектед, треба щоб він заекстендився від класа в якому він знаходиться, а щоб побачив приват, треба додати його в конструктор - return new class($this->title) extends Container{}; - title - приватний. Ретурн і крапка з комою вкіці - обовязкові
 36) Лічні кабінети користувача не можна кешувати
	  });
 36) Я зрозумів навіщо викликати родительський конструктор. Наприклад у родительському конструкті я передаю у свойства класа дані, але при екстенді цього класа, конструктор не викликається і ці дані не переадуться. А коли я роблю екземпляр класа з екстендженого обєкта, $this це і є цей обєкт і йому похер який клас був викликаний, $this від цього не міняється. В родительському конструкторі є запис - $this->title = $title(Цей тайтл, який передається при створенні обєкта); - parent::__construct($title) - присвой у цьому обєкту, свойству title те, що передали в дужках
 37) Котеров створив головний клас і оприділив туди свойства методи, які будуть всюди використовуватись (Персональна сторінка користувача не кешується, це обовязково), але не обовязково кінечні, іноді абстрактні. Потім створив клас кешування, і там зробив так само, тільки вже конкретизував. А вже кінечний функціонал метода, він написав у екстендженому класі для статичної сторінки, коли вже на руках були всі дані, у цьому і заключається суть поліморфізму 
	- Віртуальний метод - це переопридылений метод
	- Я поки це не розумію, але поліморфізм придуманий для того щоб було поменше if
 38) $class = "Page"; if ($obj instanceof $class)){...}
 39) Суть інтерфейсів у тому щоб залічити неможливість екстендитись від 2-х і більще класів. і щоб головний клас не тримав у собі весь код, то тим дітям, яким треба якиїсь функціонал, хай беруть
 40) Інтерфейси теж можуть наслідуватись один від одного
 41) Якщо клас імплементує інтерфейс, але не реалізує методи, він автоматом стає абстрактним. Типу якщо не реалізувати методи і додати перед ним abstract, все б мало бути ок
 42) Трейди - те саме що і інтерфейси але дозволяє описувати ф-ції в ньому. Він призначений для того, шоб не описувати у різниз класах майже одинакові коди. Там є всякі плюшки, щоб не було конфліктів і т д
	- Трейди перезагружають методи класа, від якого заексендився текущий клас, але не методи текущого класу
	- Якщо я раелізував трейди з різними методами, цей конфлікт можна вирішити, указавши який трейд використовувати. Також в домомогу для вирішення конфлікту методів є оператор as. Це схоже як сказувати аліаси при запросі з 2-х баз даних