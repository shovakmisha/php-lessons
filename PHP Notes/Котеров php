 1) Упрощенно, протокол
 2) Айпішка. Складається з 4-х восьмирозрядних чисел, від нуля до 255. В кожгого унікальна і вона надається користувачу судячи з його місцезнаходження, але є і зарезервовані айпішки. Наприклад 127.0.0.1 - це локалхост.
 3) Порт записываэтся после айпи адреса или доменного имени через двоэточие. Тобто можна написати не http://yandex.ru , a http://yandex.ru:80
	- Порт 80 - стандартний для обміну даними з веб-сервером. Порт 443 ( http://yandex.ru:443 ) - стандартний для зашифрованого SSL - зєднання. Зазвичай браузери або інші мережеві клієнти назначають порти автоматом. Але якщо сервер використовує нестандартний порт ( наприклад 8080 )б його треба указати явно
 4) Сервер - це машина ( залізо ), а не логічна частина мережі. Тобто він може мати деклька айпішок і тим паче декілька доменів
 5) Зазвичай сервер використовує 1 протокол TCP/IP. На даний момент компютери не настільк мощні щоб на них були 2 ОС і вони мали 2 протоколи
 6) Будь що, що має свій унікальний айпі в інтернеті, називається вузлом.
	- Хост це не обовязково вузел. Буває декілька віртуальних хостів на одному вузлі. Тобто одна айпішка на декілька хостів
 7) Порт - це число яке ідентифікує програму, яка буде приймати дані на веб-сервері. Программа, яку ідентифікує порт на сервері працює постійно. Вона відсилає http запити клієнтів. ЇЇ називають демоном. Зазвичай вона працює сама по собі і її не налаштовують. 
	- По ходу для кожного протоколу є свій демон. Але з браузера до протоколів не http не підключишся
 8) html сторінка це мінімум, який я браузер може потрубувати у веб-сервера
 9) Якщо юрл дуже довгий, то при клацанні на лінку нічого не буде
 10)\n\n - обовязкові символи, які означають кінець запиту. Поки їх нема, сервер не буде обробляти запит
 11) Протокол http задає правила формування заголовка
 12) Набір заголовків, якими обмінюються сервер і браузер
 13) CGI - сценарій по якому передаються дані. Типу, тут указується поведінка серрвера на якісь запити. Типу якщо я ввожу якусь адресу, на цю адресу є конретний сценарій
	- Мабуть цей файлик (script.cgi) буде розміщений в корневій папці сервера
 14) При передаванні методом get ( можливо і іншими ) Символ з шіснадцятиричним кодом 9e - буде виглядати як %9e. Пробел превратится в плюс (але наапаки не зробиться. Тобто якщо в адресній строці +, він не переформатується в пробіл ).
 15) Заголовки запроса мають бути у такому ж форматі як заголовки ответа
 16) Заголовок Location - краще використовувати повший шлях до сторінки
 17) ЮРЛ і хтмл кодировка це не одне й теж саме
 18) Поля форми у яких немає name - не будуть передаватись. Так наприклад можна дати кноіуі імя і значення і перевіряти чи кнопка була нажата перед тим як я попав на сторінку обработки форми
 19) Для сценарія всерівно чи це було скрите поле (type hidden) чи звичайне
 20) ПРи щелчку на type="image" сценарію будуть передаватись координати, де був клік
 21) Якщо у тега option не заданий value, то його значенням буде його текст
 22) Синтаксичної помилки не буде, якщо у полях форми будуть одинакові імена. Можна зробити це для чекбоксів name=vasya&name="ivan"
 23) Символи, які не можна відсилати, треба заміняти еквівалентими їм. Треба шукати в неті короче. Типу чим замінити лапки і т д
 24) Коли я буду надсилати дані на сервер, розділятимуться блоки будуть так 
	-----12345678(ідентифікатор строки )\n. 
	Content-type (Заголовок Якийсь)
	Але до неї не можна привязуватись. Вона може мінятись, це не константа і тим паче різні браузери посилають її по своїх правилах, ставлячи в кінці \n або \n\r
 25) Не обовязково, що кожного разу я буду мати одну й ту саму айпішку. Може бути таке, що провайдер дасть мені іншу, більш підходящу
 26) В метатезі теж можна працювати з куками, і вони будуть оброблятись пізніше як заголовки
 27) Кукі може бути тільки ЮРЛ кодірованим, тобто складатись з алфівітно цифрових символів
 28) Параметр домаін в кукі можна міняти. Тобто можна щоб кукі читав інший хост. по замовчуванню ставиться домаін користувача
 29) Айпішка, яка починається з 127 - завжди буде локальна вроді
 30) Якщо я хочу щоб мій локальний хось бачили, то можна прописати йому айпішку 0.0.0.0 і тоді до нього можна буде достукатись. Але у тих хто буде стукатись в файлі хоста має бути моя айпішка 192.168.....
 31) Імя метода не може співпадати з імям класа
 32) Якщо я хочу вставити xml в код ( <?xml ... ?> ) треба перевірити чи short_open_tag виключений, інакше пхп подумає що це початок пхп коду і видасть помилку
 33) Якщо є помилка, що не задана тайм зона, треба вказати її у файлі php.ini - date.timezone = 'Europe/Moscow' наприклад
 34) Змінні у пхп не беруть багато ресурсів
 35) Якщо в програмі щось храниться, то воно завжди зберігається у змінній. Виключення - це константа, але вона може хранити тільки число і строку, починаючи з пхп7 і масив
 36) Якщо число виходить за діапазон можливостей пхп, воно трансформується в тип числа double
 37) Числа в степені теє мають тип флоат
 38) будь які операції з NaN, повертають NaN
 39) Змінні в пхп хранять не обєкти, а лінки на обєкти
 40) інкремент, декремент мали б переробляти булеан, але не переробляють
 41) Якщо відключити помилки в пхп, то всі необявлені змінні трансформуються в пусту строчку
 
 43) settype() - не зробить зі змінної буліан, все інше зробить. Якщо не зробить, поверне false
 44) В PHP можна робити змінну, яка буде ссилатись на змінну ( Як у обєктів )
	- Але в масиві наприклад, воно працює по іншому. наприклад якщо я ссилаюсь на елемент, якого не існує, то пхп створить цей елемент з тим ключем, який я вказав зі значенням NULL (echo null до речі виводиться в пхп як пуста строка)
	- unset() не видалить елемент, на який ссилається змінна, просто розірве звязок між змінними
 45) Якщо у мене в коді є строка, яка називється так само як змінна ( 'red' i $red = 'red-color' ), то цю строку можна присвоїти змінній і в цій змінній буде значення тої змінної ( $color = 'red'; echo $$color; //'red-color' ). Можна переприсвоїти значення змінній $red - $$color = 'other-color'; 
 46) Робити з обєкта строку - погана ідеяю
	- Якщо з масива робити строку, получится "Array";
 47) ПХП не розпізнає константу в строціє
 48) В пхп є константи які оприділяють текущу строку, файл, лінію, ОС, .....
 49) print_ виведе елементи зберігши струкруру коду ( Звичайно треба щоб це було у тегах <pre> ). Через кому ще можна вказати параметр $return, якому присвоїться фолс або тру і від цього буде залежати чи виведуться дані чи просто присвояться змінній у яку присвоїна ця ф-ція. 
	- Взагалі то є ще декілька подібних ф-цій, які можна виуористати як куски програми. Це по ходу буде синтаксично правильний код і робочий, або щось в тому роді
 50) echo false - виведе пусту строку, echo true - виведе true
 51) Правило - Якщо зрівнювати число і строку, то пхп буде приводити строку в число ( intrger("моя строка") - тут буде 0 ). Отже "str" == 0 // true
	- При зрівненні масивів або обєктів, пхп рекурсивно проходиться по елементах і зрівнює кожен елемент по цих лояльних правилах
	- Хоча для обєктів === буде тру, не лише коли типи будуть одинакові, треба щоб вони ссилались на 1 обєкт.
 52) ПХП хранить усі помилки у змінній $php_errormsg; 
 53) @ - кладеться перед виразом, а не перед строкою.
	- Але все ж таки краще його не використовувати. Зазвичай помилки показуються тільки на проді, при розробці його виключають. Тим паче він не виводить помилки тільки в браузер, у файл журнала помилок, він виводить все.
 54) Тернарний оператор може бути тільки з одним значенням, без else
 55) В пхп 7 зявився оператор ??; Він перевіряє декілька змінних і виводить існуючу. Типу $x = null; $y = 5; $zminna = ($x ?? $y); // $zminna присвоїться 5
 56) Змінна $_REQUEST обєднує в собі дані з 2-х масивів ( get i post )
 57) <?= Так зазвичай пишуть коли це в контексті хтмл ( <form action="<?=$_SERVER['SCRIPT_NAME']?>"> ), а не программа ?>
 58) Якщо у формі є є поля з оинаковим name, то попадає тільки остання. Це знадобиться у селекті. Тому що якщо юзер зажав контрол і клацнув на декілька, то вибереться декілька. Але і це можна обійти, якщо у атрибуті селекта name, написати Sel[] (name="Sel[]"). Тоді у нейм попаде масив з вибраними елементамию
 59) Так сталось, що коли працювати з масивами, то до свойств краще звертатись, беручи їх у лапки(апострофи), а до тегів форм( нейм наприклад ), без них
 60) коли пхп починає обробляти форму, він створює 4 масиви - get, post, cookie, request, server;
 61) 178 сторінку повторити
 62) В асоціативному масиві, ключі з одинаковими буквами, але з різним регістром, це різні ключі
 63) 3 php 7 можна у константу покласти масив
 64) Оператор +(+=) не підходить для зливання індексованих масивів. Тому що він діє так що коли бачить одинакові ключі, то залишає тільки перший. І при додаванні індексованих, він сприймає індекс як ключ. Ф-ція array_merge допоможе в цьому
 65) Якщо ф-ція приймає декілька аргументів, то коли я викликаю цю ф-цію, ці аргументи можна вказати масивом // $arr[.,.,.,.]; foo(...$arr)
	- Оператор ... розверне масив
 66) Строга типізація в пхп робиться коли в ф-ції declare, аргумент strict_types = 1 // declare(strict_types = 1);
 67) В пхп немає такого, що якщо я пишу змінну внутрі ф-цїї, а змінної там немає, то він буде шукати її в глобальній видимості. Там все жостко розподілено. І якщо я хочу все є таки знайти глобальну змінну, треба сказати йому що я шукаю в глобальній видимості, написавши перед зсінною global $zminna; або через масив GLOBALS;
	- Хочаколи я передав змінну аргументом, то проканало
 68) Масив GLOBALS доступний з будь якого місця
	- GLOBALS не можна присвоїти повністю якиїсь змінній.
	- в масиві GLOBALS є завжди змінна GLOBALS. В ній є всі елементи глобального масива GLOBALS. Це все построїно то принципу ссилок, тож якщо міняю одне, міняю і інше. А кщо це все ссилки, то коли я в функції, беру глобальну змінну, потім видаляю її через ф-цію unset(), а не через GLOBALS['a'], то я не видалю її, а тільки розірву звязок з глобальною $a
 69) Синонім в терміні пхп - це ссилка
 70) static - скаже пхп, щоб при закінченні виконання ф-ції, він запамятав значення змінної. Також він присвоїть значення ції ф-цї тільки 1 раз при першому присвоєнні ( ну в принципі це логічно, типу як в циклі )
 71) Ф-ція dumper для отладок (типу print_r). каже, що хороша
 72) Як працюють ф-ції у пхп. 
	- У пхп є внутрішня таблиця з списком ф-цій
	- У цьому списку не може бути 2 ф-ції з одинаковим імям
	- Так само як у скріпті, він проходиться по поду і кладе ці ф-ції в карман. Але є одна відмінність. Коли він виконує якусь ф-цію, бачить іншу, то якщо у цій ф-ції є ще одна ф-ція, він занесе її в карман і її можна буде викликати звідки хочу
 73) Так само як в скріпті, якщо присвоїти ф-цію змінній, то її можна викликати, написавши після змінної дужки $zminna();
 74) В аргумент можна передати і ф-цію
 75) Замикання діють тільки для анонімних ф-цій. 
	- Для замикання треба вказати ключове слово use, потім можна в дужках передати аргументи
 76) Можна зробити так, щоб ф-ція повертала ссилку на змінну, а не її значення. Вроді це не рекомендується використовувати, але опис на це в 232 рядку
 77) Я ніхера не поняв про ненератори - 237 сторінка
 78) Взагалі при зрівнюванні можна поставити змінну у лапки і тоді він точно біде зрівнювати строку
 79) ,Бути уважним з округленням чисел, оскільки ф-ція raund з константами, які вказують в яку сторону округляти, буде округляти не залежно чи це мінусове лисло чи ні, їй важливо тільки модуль, а ф-ція ceil, буде округляти до більшого числа і їй важливо який модуль. Наприклад -3 більше як -4, вона буде округляти до -3
 80) Для генерації випадкових чисел викорисовувати ф-цію mt_rand. інші не використовувати
	- За основу вона бере генератор mt_srand(). Для кращої унікальності, цьому генератору можна передати якісь декілька унікальних аргументів, наприклад дату і тд 
	- Також хороша ф-ція для випадкових чисел rondom_int, хоча не знаю чи і вона теж бере за основу генератор mt_srand(
 81) Щоб парсити, розпарсити json, є ф-ції json_decode, json_encode
 82) Є ф-ції, які повертають мінімальне, максимальне значення масиву
 83) Будь який вираз у якому є NaN, прийме значення NaN
 84) PHP сам поставить слеші (шлях до файлів), як йому треба. ТОж за це переживати не треба
	- Навпаки не треба ставити обрані (це для віндовс). Якщо вже без них ніяк, то треба екранувати слеш, слешем
 85) Можливо десь знадобиться. Юнікс ситеми для переводу строки використовують \n, a Windows \n\r(\r\n в залежноксті звідки куди передаються файли). Тож якщо я передаю файли між системами, брати це до уваги. Вони мабуть і автоматом якось переформатовуються, але запамятати, що із за цього може бути помилка
	- До речі, коли \n використовується як перевод строки, то він займає тільки 1 байт, оскільки він не в кодіровці ютф-8. Тож коли буду вибирати який маркер ставити, краще мабуть бінарний, оскільки текстовий у різних системах на 1 символ у строці може бути різним і якщо я буду відкривати файли з таркером t, всі переноси рядків переформатуються у ту систему, з якої я робив ці операції
 86) tmpfile() - ф-ція для для того, якщо я хочу чимчасово попрацювати з файлом. Можливо цей спосіб дасть тільки читати, редагувати файли. Ф-ція створить копію файла з унікальним іменем і працювати можна буде тільки зі змінною, якій я присвою цю ф-цію, оскільки з іменем вже працювати не вдасться, оскільки імя у ф-ції не таке, як імя файла
 87) Коли я відкриваю файл, цей процес присвоюється дискриптору(Можливо він у змінній). Дискрипторів на один файл може бути декілька, якщо відкрити файл декілька разів
 88) PHP дає можливість працювати з exel файлами (csv) // 320 строка
 89) Є ф-ції basemane/dirname, для того щоб взяти імя файлу текущого адреса (після останнього правого слеша), або каталог у якому лежать файли
 90) tempname() - Можна створити файл з унікальним іменем у якій хочу директорії. Разом з цією тимчасовою директорією створиться файл в ній
 91) Ф-ція realpath() - Якщо задати цій ф-ції відносний жлях файлу, вона поверне абсолютний
 92) Ф-ція copy - копіює файл. Якщо не задам імя новоствореного файлу, а замість цього вкажу існуючий, він перезапишеться
 93) Ф-ція rename - переіменовує файл. Якщо переіменувати на файл, який вже існує, буде помилка
 94) Ф-ція - unlink - видаляє файл
 95) Ф-ція - file(), типу fopen, тільки скоріша, але читає в бінарному коді і записує символи в масив - 1 ключ - 1 строка
 96) Фція fflush - записує всі файли з буферу зразу на диск. Справа у тому, що коли япрацюю з файлом, всі дані буферизуються(8кб) для більшої швидкості і кидаються на диск тільки як буфер буде повний. 
	- До речі ф-ція, яка закриває fclose теж робить цю ф-цію перед закриттям файлу
 97) set_file_buffer - задає розмір буферизації для заданого файлу
 98) Ф-ція flock() - редулює процес читання/запис файла. Щоб не було що один читає, інший регулює, треба файлу ставити цю ф-цію і і в агрументах задати потрібні константи. Ця ф-ція зробить користувача єдиним хто щось робить з файлом. І поки він його не розблокує, інші його не получать
	- Константа LOCK_NB має бути завжди, а вже до неї додавати іншу. Інакше буде зависати, а з нею управління зразу передасться
	- Маркери w i w+ ( fopen ) взагалі не використовувати з flock()
 99) Коли я роблю fopen, не можна давати права йому на ходу, в залежності чи є файл чи нема. Між цими двома процесами є деякий час, за який цей файл може створитись або щось подібне 
 100) readdir() - відкриє каталог для подальшого його считування. Якщо покласти у змінну, у змінній буде ідентифікатор і надалі я вде буду працювати з ним
 101) Коли я регіструюсь(зєднуюсь) в системі, моїй сесії присвоюється ідентифікатор - ціле число від нуля і обмежені права. Якщо я адміністратор, то 0 + усі права
	- в файлі /ect/passwd храняться дані куди я маю права, а куди ні
	- всі дочірні процеси унаслідують айді сесії і міняти його не можна
	- Типу коли я підключаюсь по фтп наприклад, сервер перевіряє мій логін і пароль з правами адміна, а якщо все успішно, назаначає сесії айді уже з унакальним айді, числом більше нуля, щоб я не міг робити на сервері те, на що в мене немаж прав
	- Можливо так буде зрозуміліше. Я підключаюсь до сервера по 80-му порту, На тому порті є демон який дивить в файл конфігів, і по ньому оприділяє, які права мені треба дати, дає і назначає нашій сесії айдішку
	- Айдішка може мати буквенну форму, хоча як її перевести я не знайшов
	- Кожен юзер(UID) має відноститьсь до якоїсь групи користувачів(GID) - це специфікація юнікс систем. Часто для юзера заводять групу з тим самим іменем що в юзера. Може бути 1 юзер на декільга груп, хоча це рідко.
	- Кожен файл у системі має атрибут, у якому вказано які права на нього має користувач, цей атрибут і є - UID. Звичайно адміністратор може змінити його
	- Але навіть якшо я створив файл, видалтити його я можу не завжди, оскільки права на файл храняться не у файлі, а у каталозі, що містить цей файл
	- Файл також має атрибут - айді групи, до якої він відноситься. Наприклад, якщо я не адмін і створив якиїсь файл, то у цього файла будуть такі права як і у мене  
 - права до файла можна відобразити в таблиці
	юзер	група	інші
 	rwx	 rwx	rwx
	- або коротше - rwxrwxr--
	- або по бітах- 111111100
	- якщо я хочу заборонити щось, то треба поставити прочерк. Наприклад "інші" користувачі не можуть записувати у файл rwxrwxr-x
	- якщо це папка, то перед буквами прав, треба додати d - drwxrwxrwx

 - Якщо переводити в числа, то це буде 
	- r-- 4 (= 4*1 + 2*0 + 1*0) 
	- r-x 5 (= 4*1 + 2*0 + 1*1)
	- r-x 5 (= 4*1 + 2*1 + 1*1) - типу я міняю тільки 1 або 0. Якщо буде 0, то число множиться на 0 і буде 0
 - Тобто 766 - це юзер може робити що хоче, а група і інші тільки читати і писати
	- Тобто ми маєм восьмеричне число (0-7). Щоб підчеркнути, що це восьмеричне число, треба поставити перед ним 0 (майже у сіх мовах так) // 0766
	- Не треба забувати вказувати 0. У двійковій системі, восьмеричне число 755 виглядає - 111000000. Те що треба rwx------ А в десятковій, воно буде 1010111100. Взалі не то. получиться щось вроді - ?-w-rwxr--. Взагі не зрозуміло що за атрибут знак запитання

 102) x - це права для просмотра атрибутів содержимого каталока. Каталог - це файл у якому є список файлів і підкаталогів. для кожного файла в каталозі, каталог хранить у себе імя файла і лінку на фізичне розположення файлу - імя=>де він знахлдиться у системі. Типу це як ключ у масиві. Якщо я кажу, що мені треба ключ, він повертає його сожержиме. Содержиме - це лінка, яка веде до файлу
 102) Чомусь тут каже, що каталог не хранить права на файли. Хранить тілки
	. - це лінка на фізичне розположення файла
	.. - лінка на родителький каталог
 103) w - дозволяє створювати, переіменовувати, видаляти фйли внутрі каталога. Мати на увазі, що немає значення, які права має файл, так як в каталозі немає цих даних. Тож бути уважним, так як я можу видалити файл, створений адміном наприклад, який дуже важливий
	 - З видаленням підкаталоків не все так просто. Коли я видаляю підкаталог, я видаляю і атрибут . в ньому. А за це вже відповідає х. Це вже я додумав, тож може це і не правда. Котеров писав, що я не можу видалити підкаталог, оскільки атрибут. який мі стиься в підкаталозі, створений адміністратором і у мене немає прав його видалити, тільки переіменувати
 104) root може робити все що завгодно
 105) Є ф-ції, які перевіряють чи файл може бути доступний для читання, запису, сиконання - is_executabl, is_writible ...
 106) Також в юнікс системах є ссилки. Елементи у яких є лінка на основний файл ( це можна використовувати, наприклад в фції fopen )
	- Їх можна видалити, не переживаючи за файли unlink(), rmdir() - хоча на рахунок цієї я не певен, що файл не видалиться
	- readlink(імя ссилки) - поверне імя файла, на яку ссилається лінка
	- symlink() - створить лінку на файл
 107) Для зовнішніх програм є оператор обратних апострофів
	`dir` - поверне результат виконання команда dir (розпечатка даного каталока)
 108) system() - виповнить команду, яку я задав у дужках - system(cd some_folder); можна сказати декілька команд system( cd some_folder; mkdir() );
	- Не можна передавати дані з браузера у ф-цію system(), exec(), не обробивши їх. А то з форми можуть прийти і такі команди - rm -rf ~/
	- Виведе результат роботи команди у браузер
	- exec() - те ж саме, тільки результат роботи не виводиться в браузер
	- passthru() - виводить дані у браузер, не ізкажаючи їх. Наприклад для картинок підійде
	- escapeshellcmd() - обезопасить. Екранує всі символи які означають команди.
	- escapeshellarg() - теж обезопасить, тільки не екранування, а візьме строку з командними символами в лапки
 109) На скільки я зрозумів під зовнішніми програмами Котеров розуміє ті команди, які я можу виконати з консолі, підключившись до сервера. Типу створити/видалити файл, змінити даректорію. Усі ці команди знаходяться у отдільній папці в будь якій системі. Але не у всіх є права їх виконувати
 110) popen() - Запускає зовншню программу, але на відміну від system(), вона запускається паралельно скріпту, тож не треба чекати, поки вона закінчиться, інтерпритатор зразу перейде на слідуючу строку.
	Котеров за допомогою цієї ф-ції, відкрив файл в системі sendmail, який выдправляє письма, записав йому дані (куди і що відправити і відправив комусь на пошту). При цьому ця вся дія, це імітація того, ніби я з консолі це все роблю, а не в скріпті написано. Якщо хтось дійсно підключився до сервера до цього файлу і працює з консолі, а в той час робиться той скріпт, який написав котеров, то після того як скріпт закриє файл, юзеру який працює з консолі у цьому файлі прийде повідомлення, що файл закрився
	- Ця ф-ція не дозволяє комусь читати і іншому редагувати файл одночасно. Хоча є спосіб
	- proc_open() - дозволяє комусь читати і іншому редагувати файл одночасно



