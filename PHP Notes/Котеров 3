 1) Неймспейси навіть не будуть конфліктувати з підключеними бібліотеками, так як це різні області бачення. Але в такому разі мабуть треба підключати їх поменше, щоб скріпт не займав багато памяті
 2) У неймспейсі може бути будь який код, але його дія діє тільки на класи, ф-ції, трейти і константи
 3) Не обовязково неймспейси класти у змінну, потім працювати з змінною, можна на ходу це все робити
 4) Не можна у одному файлі використовувати декілька пространств імен, але якщо і робити це, то треба заключати код неймспейса у фігурні дужки
	- Різні файли можуть мати 1 неймспейс. При підключенні їх у 1 файл Котеров використовував аліаси для кожного, хоча я не впевнений що будуть конфлікти без них
 5) Так як неймспейс це реальний участок памяті, це можна використати для автолоада, оскільки шляхи будуть коректні function __autoload($classname){
															    require_once(__DIR__ . "/$classname.php");
															  }
															  $page = new PHP7\Page('О нас', 'Содержимое страницы'); - навіть без use работає
	- Хоча тут я трохи загнув, у цьому файлі, що я заінклюдив, були оператори use

-- Обработка помилок --

 6) В пхп існує 2 виводи помилок, в браузер і в лог файл. error_log - це шлях до файлу лога error_reporting(E_ALL); ini_set('error_log', 'log.txt'); ini_set('log_errors', 'true');
 7) Якщо перед фиразом э @, то пхп не покаже помилки навыть якщо там є підфункції у яких є помилки
	- але це не означає що якщо я покладу @fopen у if, а файлу не буде, то буде тру. Просто помилка не виведеться
 8) set_error_handle(funcName, $errorTypes) - можна назначити, помилки якого типу, буду обробляти я своїми кастомними ф-ціями. Якщо я вже перезаписав ф-цію, яка буде викликатись при помилці, то ця ф-ція буде працювати з моєю новою ф-цією, але поверне мою попередню. Це можна використати, якщо покласти це у змінну і після того як відпрацювала нова, назначити знов стару
 	- зазвичай використовується для не серйозних помилок
 	- funcName($errno, $msg, $file, $line){ ці змінні уже будуть їй передані } // фція, яка буде пре даватись сюди, будемати 4 аргументи - помилка, текст помилки, файл і строка. якщо моя ф-ція буде повертати фолс, викличеться стандартний обработчик
	- E_PARSE, E_ERROR важко перехватити ф-цією set_error_handle. Хіба що через буферизацію, але і то важко
	- Коли я викликав set_error_handle, попередній обработчик записується у память. Щоб його викликати, є фція - restore_error_handlerl(); Але треба щоб к-сь її викликів була такою ж як і к-сть set_error_handle
	- @ не допомагає від кастомних ф-цій для помилок, тільки якщо становити error reporting - 0 (Бажано тільки на час виконання скріпта)
 10) trigger_error() - можна створити свої помилки. Ця ф-ція дозволяє створити помилки пользовательського рівня (E_USER_ERROR, E_USER_WARNING E_USER_NOTICE) Типу на 0 ділити не можна і тд
	Типу створити свою ф-цію, присвоїти її set_error_handle, і внутрі set_error_handle описати умови, коли викличеться trigger_error. Як тільки він викличеться, скріпт зразу перекинеться у ф-цію, яку я передав у trigger_error - http://joxi.ru/nAyv8gwUXPwQkr - буде типу кетч. в trigger_error передається аргумент імя помилки, і цей же аргумент передасться в аргумент $errno в ф-ції set_error_handle - як імя помилки. Можливо він ще якісь має аргументи
 11) error_log() - дополнительна фіча для ф-ції яка записує помилку в лог. За допогогою неї, можна вказати у який файл ще можна записати помилки, чи відправити його на пошту(Пошту пожна вказати), що дописати в лог файл до помилки
 12) debug_backtrace() - покаже цепочку цієї ф-ції. Тобто і родительську, яка була викликана  і взагалі досить детально розписано содержиме ф-ції або список ф-цій. Зручно дебажити
 14) Я включав щоб показувало всі типи помилок, але всеодно, якщо я зловив цю помилку через catch, скріпт попадав у кетч і продовжував працювати, а не викидував з програми. Те саме і при set_error_handler
 14) throw - Возбудити ексепшн. Створити помилку і предати її в кетч
 13) Котеров написав дерево вложених ф-цій, там де вони викликались у скобках try. За скобками try йшов catch. У одный ыз вложених ф-цій, я викинув помилку через trow new Exeption, програма зразу кинуласть в catch, але потым не продовжила йти по дереву, а пішла виповнювати той код, що після catch з фігурними дужками
	- Якщо в цьому дереві ф-цій настворювати обєктів, і десь же у цьому дереві у ф-ції, викинути помилку, то обєкти поступово пропадуть, так як дія ф-ції закінчилась. Це пройде поступово, спочатку у тої, у якій був визваний ексепшн, потім у батьківської і тд
 14) І так можна - $this->pages[$page]()
 15) class Exception це клас, а отже він має свої методи і сваойства. Свойства і методи цього класу це восновному інфа про помилку. Меседж, імя, на якій лінії вона сталась, у якому файлі і тд. ТОбто то що в кетчі передається клас і імя змінної, якій присвоїться обєкт цього класу, то з цієї змінної можна буде витягти дані помилки. До речі дані про те де сталась помилка він знаходить за допомогою debug_backtrace(). Дані про те, цепочка яких функцій привела до помилки храниться у класі ексепшн у свойстві $trace. Щоб витягти дані з неї є метод - getTrace ().
 16) Котеров наекстендив класи від ексепшна і понаствоювар інтерфейсів. Суть у тому щоб перевіряти більш детальніше типи помилок. Якиїсь клас реалізує якиїсь або декілька інтерфейсів і потім перевіряється в кетчі - Якщо ця помилка файлова, або якась інша, кидається в різний кетч catch (IFileException $e) { якщо файлова, то це роби } catch (Exception $e) { інакше це } 
 17) Exception не може відловити всі помилки. Наприклад  $str ="Hello, world!"; Sstr[] = 4; - він не відловить, а викличеться стандартий обработчик. Але його може відловити клас Error.
	try {$str ="Hello, world!"; $str[] = 4; catch (Error $e) { echo "Спіймав";}
20) клас Error - це не Exeption. Exeption мабуть придуманий для ооп. Але ловити помилки з ним можна так само - catch (Error $e) І один і інший наслідують інтерфейс Throwable.
	- Error має декілька класів, які генеруються при помилці. За допомогою них можна уточнити який тип помилки - catch (TypeError$e).. - Типу якшо помилка в типу
 21) є ще try finnaly - його фішка в тому, що код у блоці finnaly завжди виконається.
 22) Можливо буде така ситуація, коли код в catch не достатній для обробки. В такому випадку можна в catch кинути ще 1 ексепшн і обробити його наступним try catch, який буде в коді нижче
 23) В кінці коду, Котеров привів приклад class PHP_Exceptionizer, де обробив взагалі всі типи помилок. Але той код був довгий і трохи запутаний. class PHP_Exceptionizer дозволяє обробити всі типи помилок, перетворює стандартні помилки пхп в ексепшни

---- 

24) class Directory замінить rewinddir (), readdir () closedir () - // Directory dir (string $directory [, resource) - dir замість new
	- це типу ф-ція - $cat = dir($dirname); $cat->read()
	- у ньго будуть ф-ції(читати, перемістити указник, закрити) і свойства(шлях директоріх і мітка(типу та херня, що присвоюється змінній при відкритті директорії)) для роботи з каталогом. Цим функціям можна ставити аргументи. Аргументом може бути мітка іншого каталогу, але за замовчування у цього аргумента мітка текущого каталогу // Scat= dir(" . "); Scat->read(інша категорія)
	- він повність сумістимий для роботи з стандартиними ф-ціями роботи з директоріями. Типу файлова мітка буде читатись і тд
	- До речі його ф-ція read() - поверне імя елемента, це дуже зручно. Треба подивити, можливо і інші подібні, або стандартні подібні щось таке роблять
	- class Directory не нассліється
 14) Наскільки я зрозумів, якщо є yeild, це вже клас генератор. Тобто там вже зразу будуть ці ф-ції current(), next(). 
	function simple($from = O, $to= 100){ for($i = $from; $i < $to; $i++) { yield $i; $obj= simple(!, 5);}
	while($obj->valid()) { echo ($obj->current(); }

 15) bindTo() - У Замикання можна поставити $this класа $this->name=333; (обєкта). типу це з ф-ції можна вказати. Котеров зробив клас з якого буде робитись сторінка і вже вне класа через замикання указував які дані будуть у неї, оскільки мав доступ
	- схоже на те, ніби ця ф-ція була б в класі. Як call в скріпті - визви цю фцію в тілі іншого обєкта або класа. Це залежить выд того що мены треба. Оскільки статичні змінні не можна визвати через this, замість this треба писати NULL

) ) ;
 16) class IntlChar - цей клас може бути не доступний, якщо вын не активований в php.ini. Типу як є обєкт Math для роботи з числами, то це схоже для роботи з усіма елементами пхп
 17) Клас DateTime - для роботи з датами, тільки для ооп. 
	- формат дати $date= new DateTime(сюди передавати дату); $date->format(дд мм ...). 
	- Також дополнытельним параметром для DateTime можна вказати тайм зону, яку можна назначити через клас DateTimeZone. Якщо в конфігах пхп таймзона взагалі не встановлена, то видасть помилку
 18) diff() - скаже різницю у часі між двома класами DateTime() - типу різниця між часом які хранять у собі ці обєкти 1 рік 3 місяці і тд - $date= new DateTime('2015-01-01 0:0:0'); Snowdate =new DateTime(); $interval= $nowdate->diff($date); - print_r($interval); - видасть конкретнішу інфу (секунди, мілісікунди...) Також у класа буде свойство invert (1 або 0)- Воно скаже чи ця різнця плюсова чи мінусова 
 19) add(), sub() - добавити, відняти час від DateTime
	- class Daternterval - рандомна дата.  - $nowdate =new DateTime(); $date=- $nowdate->sub(new Dateinterval("P3YlM14DT12Hl9M2S")); - Дата в нього передається дивним форматом, записувати не буду, краще загуглити
 20) DatePerіod - дозволяє створити ітератор для foreach, степ якого буде залежати выд дати - $now= new DateTime();  $step= new Dateinterval('PlW'); $period= new DatePeriod($now, $step, 5); foreach($period as $datetime) { echo $datetime->forrnat("Y-m-d") ."<br />"; } - 2015-11-28
2015-12-05 2015-12-12
 21) Котеров показував у приклад якысь не знайомі ітератори папок і файлів. 
	- getIterator(Iterator) - цей метод мож написати в класі і тепер назначеним ітератором буде оброблятись окземпляр йього класу
 22) foreach ($d->getiterator() as $path=> $entry) {} == foreach ($d as $path=> $entry) {} типу можна назначити декілька ітераторів для класа, але якщо не назначу, то буде стандартний, той який я вказав у методі getIterator
	- Не забувати, що коли я вже зробив ітератор з класа (Як на лабі у спеціаліста, а потім пропускав їх через цикли), то обєкт цього класа буде мати його методи. Можна зразу писати foreach($o->rewind(); $o->valid(); $o->next()){...}

 -- рефлекшни --

 23) call_user_func() теж можна визвати методи обэкта або класа, якщо метод статичний. Вона і з рефлекшнами працює
	- call_user_func_arg() - те саме, але аргументи можна передати масивом
 24) Також є можливість створити екземпляр класа, якщо клас знаходиться в змінній. $className = "MathComplex"; $obj= new $className(6, l); 
	- Якщо при роботі з рефлекшнами є помилка, її можна перехвати, так як я знаю її, це ReflectionException // catch ReflectionException $e
	- Reflection може створити 2 обэкти з одинакових елементів. І зміна одного не повліяє на інший
	- Якщо розпечатати екстенджений рефлекшн клас, то свойства екстендженого класу, які прийшли в наслідок будуть казати, що вони відносяться до того від кого вони заекстендились, а методи будуть казати, шо вони належать до текущого класу
 25) ReflectionProperty має методи сет і гет велью. Їм у аргумент передаються обєкти, у яких це свойство буде мінятись getValue(Sobject, $value)
 




 По ходу в пхп як і в скріпті - {фігкрні дужки} означають блок, типу вказівний, що цей код разом чи щось таке



bindTo()








