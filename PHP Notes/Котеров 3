 1) Неймспейси навіть не будуть конфліктувати з підключеними бібліотеками, так як це різні області бачення. Але в такому разі мабуть треба підключати їх поменше, щоб скріпт не займав багато памяті
 2) У неймспейсі може бути будь який код, але його дія діє тільки на класи, ф-ції, трейти і константи
 3) Не обовязково неймспейси класти у змінну, потім працювати з змінною, можна на ходу це все робити
 4) Не можна у одному файлі використовувати декілька пространств імен, але якщо і робити це, то треба заключати код неймспейса у фігурні дужки
	- Різні файли можуть мати 1 неймспейс. При підключенні їх у 1 файл Котеров використовував аліаси для кожного, хоча я не впевнений що будуть конфлікти без них
 5) Так як неймспейс це реальний участок памяті, це можна використати для автолоада, оскільки шляхи будуть коректні function __autoload($classname){
															    require_once(__DIR__ . "/$classname.php");
															  }
															  $page = new PHP7\Page('О нас', 'Содержимое страницы'); - навіть без use работає
	- Хоча тут я трохи загнув, у цьому файлі, що я заінклюдив, були оператори use
 6) В пхп існує 2 виводи помилок, в браузер і в лог файл. error_log - це шлях до файлу лога error_reporting(E_ALL); ini_set('error_log', 'log.txt'); ini_set('log_errors', 'true');
 7) Якщо перед фиразом э @, то пхп не покаже помилки навыть якщо там є підфункції у яких є помилки
	- але це не означає що якщо я покладу @fopen у if, а файлу не буде, то буде тру. Просто помилка не виведеться
 8) set_error_handle - можна назначити, помилки якого типу, буду обробляти я своїми кастомними ф-ціями. Якщо я вже перезаписав ф-цію, яка буде викликатись при помилці, то ця ф-ція буде працювати з моєю новою ф-цією, але поверне мою попередню. Це можна використати, якщо покласти це у змінну і після того як відпрацювала нова, назначити знов стару
 	- зазвичай використовується для не серйозних помилок
 20) тип Error - це не Exeption. Exeption мабуть придуманий для ооп. Але ловити помилки з ним можна так само - catch (Error $e) І один і інший наслідують інтерфейс Throwable.
	- Error має декілька класів, які генеруються при помилці. За допомогою них можна уточнити який тип помилки - catch (TypeError$e).. - Типу якшо помилка в типу
 21) є ще try finnaly - його фішка в тому, що код у блоці finnaly завжди виконається.
 22) Можливо буде така ситуація, коли код в catch не достатній для обробки. В такому випадку можна в catch кинути ще 1 ексепшн і обробити його наступним throw, який буде в коді
 23) В кінці коду, Котеров привів приклад PHP _Exceptionizer, де обробив взагалі всі типи помилок. Але той код був довгий і трохи запутаний
 24) class Directory замінить rewinddir (), readdir () closedir () - // Directory dir (string $directory [, resource) - dir замість new
	- це типу ф-ція - $cat = dir($dirname); $cat->read()
	- у ньго будуть ф-ції(читати, перемістити указник, закрити) і свойства(шлях директоріх і мітка(типу та херня, що присвоюється змінній при відкритті директорії)) для роботи з каталогом
	- він повність сумістимий для роботи з стандартиними ф-ціями роботи з директоріями. Типу файлова мітка буде читатись і тд
	- До речі його ф-ція read() - поверне імя елемента, це дуже зручно. Треба подивити, можливо і інші подібні, або стандартні подібні щось таке роблять
	- class Directory не нассліється
	- фція, яка буде пре даватись сюди, будемати 4 аргументи - помилка, текст помилки, файл і строка. якщо моя ф-ція буде повертати фолс, викличеться стандартний обработчик
	- Коли я викликав set_error_handle, попередній обработчик записується у память. Щоб його викликати, є фція - restore_error_handlerl(); Але треба щоб к-сь її викликів була такою ж як і к-сть set_error_handle
	- @ не допомагає від кастомних ф-цій для помилок, тільки якщо становити error reporting - 0 (Бажано тільки на час виконання скріпта)
 9) E_PARSE, E_ERROR важко перехватити ф-цією set_error_handle. Хіба що через буферизацію, але і то важко
 10) trigger_error() - можна створити свої помилки. Ця ф-ція дозволяє створити помилки пользовательського рівня (E_USER_ERROR, E_USER_WARNING E_USER_NOTICE) Типу на 0 ділити не можна і тд
	Типу створити свою ф-цію, присвоїти її set_error_handle, і внутрі set_error_handle описати умови, коли викличеться trigger_error. Як тільки він викличеться, скріпт зразу перекинеться у ф-цію, яку я передав у trigger_error - http://joxi.ru/nAyv8gwUXPwQkr - буде типу кетч
 11) error_log() - дополнительна фіча для ф-ції яка записує помилку в лог. За допогогою неї, можна вказати у який файл ще можна записати помилки, чи відправити його на пошту(Пошту пожна вказати), що дописати в лог файл до помилки
 12) dabug_backtrace() - покаже цепочку цієї ф-ції. Тобто і родительську, яка була викликана  і взагалі досить детально розписано. Зручно дебажити
 13) Котеров написав дерево вложених ф-цій, там де вони викликались у скобках try. За скобками try йшов catch. У одный ыз вложених ф-цій, я викинув помилку через trow new Exeption, програма зразу кинуласть в catch, але потым не продовжила йти по дереву, а пішла виповнювати той код, що після catch з фігурними дужками
	- Якщо в цьому дереві ф-цій настворювати обєктів, і десь же у цьому дереві у ф-ції, викинути помилку, то обєкти поступово пропадуть, так як дія ф-ції закінчилась. Це пройде поступово, спочатку у тої, у якій був визваний ексепшн, потім у батьківської і тд
 14) І так можна - $this->pages[$page]()
 15) bindTo() - У Замикання можна поставити $this класа $this->name=333; (обєкта). типу це з ф-ції можна вказати. Котеров зробив клас з якого буде робитись сторінка і вже вне класа через замикання указував які дані будуть у неї, оскільки мав доступ
 16) class IntlChar - цей клас може бути не доступний, якщо вын не активований в php.ini. Типу як є обєкт Math для роботи з числами, то це схоже для роботи з усіма елементами пхп
 17) Клас DateTime - для роботи з датами, тільки для ооп. 
	- формат дати $date= new DateTime(сюди передавати дату); $date->format(дд мм ...). 
	- Також дополнытельним параметром для DateTime можна вказати тайм зону, яку можна назначити через клас DateTimeZone
 18) diff() - скаже різницю у часі між двома класами DateTime() - типу різниця між часом які хранять у собі ці обєкти 1 рік 3 місяці і тд - $date= new DateTime('2015-01-01 0:0:0'); Snowdate =new DateTime(); $interval= $nowdate->diff($date); - print_r($interval); - видасть конкретнішу інфу (секунди, мілісікунди...) Також там буде свойство invert (1 або 0)- Воно скаже чи ця різнця плюсова чи мінусова 
 19) add(), sub() - добавити, відняти час від DateTime
	- class Daternterval - рандомна дата.  - $nowdate =new DateTime(); $date=- $nowdate->sub(new Dateinterval("P3YlM14DT12Hl9M2S")); - Дата в нього передається дивним форматом, записувати не буду, краще загуглити
 20) DatePerіod - дозволяє створити ітератор для foreach, степ якого буде залежати выд дати - $now= new DateTime();  $step= new Dateinterval('PlW'); $period= new DatePeriod($now, $step, 5); foreach($period as $datetime) { echo $datetime->forrnat("Y-m-d") ."<br />"; } - 2015-11-28
2015-12-05 2015-12-12
 21) Котеров показував у приклад якысь не знайомі ітератори папок і файлів. 
	- getIterator(Iterator) - цей метод мож написати в класі і тепер назначеним ітератором буде оброблятись окземпляр йього класу
 22) foreach ($d->getiterator() as $path=> $entry) {} == foreach ($d as $path=> $entry) {} типу можна назначити декілька ітераторів для класа, але якщо не назначу, то буде стандартний, той який я вказав у методі getIterator










