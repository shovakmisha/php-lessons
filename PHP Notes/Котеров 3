 1) Неймспейси навіть не будуть конфліктувати з підключеними бібліотеками, так як це різні області бачення. Але в такому разі мабуть треба підключати їх поменше, щоб скріпт не займав багато памяті
 2) У неймспейсі може бути будь який код, але його дія діє тільки на класи, ф-ції, трейти і константи
 3) Не обовязково неймспейси класти у змінну, потім працювати з змінною, можна на ходу це все робити
 4) Не можна у одному файлі використовувати декілька пространств імен, але якщо і робити це, то треба заключати код неймспейса у фігурні дужки
	- Різні файли можуть мати 1 неймспейс. При підключенні їх у 1 файл Котеров використовував аліаси для кожного, хоча я не впевнений що будуть конфлікти без них
 5) Так як неймспейс це реальний участок памяті, це можна використати для автолоада, оскільки шляхи будуть коректні function __autoload($classname){
															    require_once(__DIR__ . "/$classname.php");
															  }
															  $page = new PHP7\Page('О нас', 'Содержимое страницы'); - навіть без use работає
	- Хоча тут я трохи загнув, у цьому файлі, що я заінклюдив, були оператори use
 6) В пхп існує 2 виводи помилок, в браузер і в лог файл. error_log - це шлях до файлу лога error_reporting(E_ALL); ini_set('error_log', 'log.txt'); ini_set('log_errors', 'true');
 7) Якщо перед фиразом э @, то пхп не покаже помилки навыть якщо там є підфункції у яких є помилки
	- але це не означає що якщо я покладу @fopen у if, а файлу не буде, то буде тру. Просто помилка не виведеться
 8) set_error_handle - можна назначити, помилки якого типу, буду обробляти я своїми кастомними ф-ціями. Якщо я вже перезаписав ф-цію, яка буде викликатись при помилці, то ця ф-ція буде працювати з моєю новою ф-цією, але поверне мою попередню. Це можна використати, якщо покласти це у змінну і після того як відпрацювала нова, назначити знов стару
 	- зазвичай використовується для не серйозних помилок



 20) тип Error - це не Exeption. Exeption мабуть придуманий для ооп. Але ловити помилки з ним можна так само - catch (Error $e) І один і інший наслідують інтерфейс Throwable.
	- Error має декілька класів, які генеруються при помилці. За допомогою них можна уточнити який тип помилки - catch (TypeError$e).. - Типу якшо помилка в типу
 21) є ще try finnaly - його фішка в тому, що код у блоці finnaly завжди виконається.
 22) Можливо буде така ситуація, коли код в catch не достатній для обробки. В такому випадку можна в catch кинути ще 1 ексепшн і обробити його наступним throw, який буде в коді
 23) В кінці коду, Котеров привів приклад PHP _Exceptionizer, де обробив взагалі всі типи помилок. Але той код був довгий і трохи запутаний
 24) class Directory замінить rewinddir (), readdir () closedir () - // Directory dir (string $directory [, resource) - dir замість new
	- це типу ф-ція - $cat = dir($dirname); $cat->read()
	- у ньго будуть ф-ції(читати, перемістити указник, закрити) і свойства(шлях директоріх і мітка(типу та херня, що присвоюється змінній при відкритті директорії)) для роботи з каталогом
	- він повність сумістимий для роботи з стандартиними ф-ціями роботи з директоріями. Типу файлова мітка буде читатись і тд
	- До речі його ф-ція read() - поверне імя елемента, це дуже зручно. Треба подивити, можливо і інші подібні, або стандартні подібні щось таке роблять
	- class Directory не нассліється
