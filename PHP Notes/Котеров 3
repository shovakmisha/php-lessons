 1) Неймспейси навіть не будуть конфліктувати з підключеними бібліотеками, так як це різні області бачення. Але в такому разі мабуть треба підключати їх поменше, щоб скріпт не займав багато памяті
 2) У неймспейсі може бути будь який код, але його дія діє тільки на класи, ф-ції, трейти і константи
 3) Не обовязково неймспейси класти у змінну, потім працювати з змінною, можна на ходу це все робити
 4) Не можна у одному файлі використовувати декілька пространств імен, але якщо і робити це, то треба заключати код неймспейса у фігурні дужки
	- Різні файли можуть мати 1 неймспейс. При підключенні їх у 1 файл Котеров використовував аліаси для кожного, хоча я не впевнений що будуть конфлікти без них
 5) Так як неймспейс це реальний участок памяті, це можна використати для автолоада, оскільки шляхи будуть коректні function __autoload($classname){
															    require_once(__DIR__ . "/$classname.php");
															  }
															  $page = new PHP7\Page('О нас', 'Содержимое страницы'); - навіть без use работає
	- Хоча тут я трохи загнув, у цьому файлі, що я заінклюдив, були оператори use
 6) В пхп існує 2 виводи помилок, в браузер і в лог файл. error_log - це шлях до файлу лога error_reporting(E_ALL); ini_set('error_log', 'log.txt'); ini_set('log_errors', 'true');
 7) Якщо перед фиразом э @, то пхп не покаже помилки навыть якщо там є підфункції у яких є помилки
	- але це не означає що якщо я покладу @fopen у if, а файлу не буде, то буде тру. Просто помилка не виведеться
 8) set_error_handle - можна назначити, помилки якого типу, буду обробляти я своїми кастомними ф-ціями. Якщо я вже перезаписав ф-цію, яка буде викликатись при помилці, то ця ф-ція буде працювати з моєю новою ф-цією, але поверне мою попередню. Це можна використати, якщо покласти це у змінну і після того як відпрацювала нова, назначити знов стару
	- фція, яка буде пре даватись сюди, будемати 4 аргументи - помилка, текст помилки, файл і строка. якщо моя ф-ція буде повертати фолс, викличеться стандартний обработчик
	- Коли я викликав set_error_handle, попередній обработчик записується у память. Щоб його викликати, є фція - restore_error_handlerl(); Але треба щоб к-сь її викликів була такою ж як і к-сть set_error_handle
	- @ не допомагає від кастомних ф-цій для помилок, тільки якщо становити error reporting - 0 (Бажано тільки на час виконання скріпта)
 9) E_PARSE, E_ERROR важко перехватити ф-цією set_error_handle. Хіба що через буферизацію, але і то важко
 10) trigger_error() - можна створити свої помилки. Ця ф-ція дозволяє створити помилки пользовательського рівня (E_USER_ERROR, E_USER_WARNING E_USER_NOTICE) Типу на 0 ділити не можна і тд
	Типу створити свою ф-цію, присвоїти її set_error_handle, і внутрі set_error_handle описати умови, коли викличеться trigger_error. Як тільки він викличеться, скріпт зразу перекинеться у ф-цію, яку я передав у trigger_error - http://joxi.ru/nAyv8gwUXPwQkr - буде типу кетч
 11) error_log() - дополнительна фіча для ф-ції яка записує помилку в лог. За допогогою неї, можна вказати у який файл ще можна записати помилки, чи відправити його на пошту(Пошту пожна вказати), що дописати в лог файл до помилки
 12) dabug_backtrace() - покаже цепочку цієї ф-ції. Тобто і родительську, яка була викликана  і взагалі досить детально розписано. Зручно дебажити
 13) Котеров написав дерево вложених ф-цій, там де вони викликались у скобках try. За скобками try йшов catch. У одный ыз вложених ф-цій, я викинув помилку через trow new Exeption, програма зразу кинуласть в catch, але потым не продовжила йти по дереву, а пішла виповнювати той код, що після catch з фігурними дужками
	- Якщо в цьому дереві ф-цій настворювати обєктів, і десь же у цьому дереві у ф-ції, викинути помилку, то обєкти поступово пропадуть, так як дія ф-ції закінчилась. Це пройде поступово, спочатку у тої, у якій був визваний ексепшн, потім у батьківської і тд
 14) 
